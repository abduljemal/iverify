(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // certificate-signer-library/certificate-context.js
  var require_certificate_context = __commonJS({
    "certificate-signer-library/certificate-context.js"(exports, module) {
      var CertificateContext2 = {
        "@context": {
          "@version": 1.1,
          "@protected": true,
          "id": "@id",
          "type": "@type",
          "infoUrl": "schema:infoUrl",
          "importPermitCertificate": {
            "@id": "cred:importPermitCertificate",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "applicationNumber": "schema:applicationNumber",
              "performaInvoiceNumber": "schema:performaInvoiceNumber",
              "amount": "schema:amount",
              "agentName": "schema:agentName",
              "agentTin": "schema:agentTin",
              "decisionDate": "schema:decisionDate",
              "supplierName": {
                "@id": "cred:importPermitCertificate",
                "@context": {
                  "name": "schema:name",
                  "country": "schema:country"
                }
              },
              "products": {
                "@id": "cred:importPermitCertificate",
                "@context": {
                  "name": "schema:name",
                  "quantity": "schema:quantity",
                  "manufacturer": "schema:manufacturer"
                }
              }
            }
          },
          "marketAuthorizationCertificateMedicine": {
            "@id": "cred:marketAuthorizationCertificateMedicine",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "registrationNo": "schema:registrationNo",
              "typeOfRegistration": "schema:typeOfRegistration",
              "productName": "schema:productName",
              "agentName": "schema:agentName",
              "approvalDate": "schema:approvalDate",
              "validUntil": "schema:validUntil",
              "manufacturer": {
                "@id": "cred:marketAuthorizationCertificateMedicine",
                "@context": {
                  "name": "schema:name",
                  "country": "schema:type"
                }
              }
            }
          },
          "marketAuthorizationCertificateDevice": {
            "@id": "cred:marketAuthorizationCertificateDevice",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "registrationNo": "schema:registrationNo",
              "typeOfRegistration": "schema:typeOfRegistration",
              "productName": "schema:productName",
              "agentName": "schema:agentName",
              "approvalDate": "schema:approvalDate",
              "validUntil": "schema:validUntil",
              "manufacturer": {
                "@id": "cred:marketAuthorizationCertificateDevice",
                "@context": {
                  "name": "schema:name",
                  "country": "schema:type"
                }
              }
            }
          },
          "marketAuthorizationCertificateFood": {
            "@id": "cred:marketAuthorizationCertificateFood",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "registrationNo": "schema:registrationNo",
              "typeOfRegistration": "schema:typeOfRegistration",
              "productName": "schema:productName",
              "agentName": "schema:agentName",
              "approvalDate": "schema:approvalDate",
              "validUntil": "schema:validUntil",
              "manufacturer": {
                "@id": "cred:marketAuthorizationCertificateFood",
                "@context": {
                  "name": "schema:name",
                  "country": "schema:type"
                }
              }
            }
          },
          "variationNotificationLetterMedicine": {
            "@id": "cred:variationNotificationLetterMedicine",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "applicationNumber": "schema:applicationNumber",
              "productName": "schema:productName",
              "agentName": "schema:agentName",
              "agentTin": "schema:agentTin",
              "manufacturer": {
                "@id": "cred:variationNotificationLetterMedicine",
                "@context": {
                  "name": "schema:name",
                  "country": "schema:type"
                }
              }
            }
          },
          "foodNotificationCertificate": {
            "@id": "cred:foodNotificationCertificate",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "registrationNo": "schema:registrationNo",
              "typeOfRegistration": "schema:typeOfRegistration",
              "productName": "schema:productName",
              "agentName": "schema:agentName",
              "approvalDate": "schema:approvalDate",
              "validUntil": "schema:validUntil",
              "manufacturer": {
                "@id": "cred:foodNotificationCertificate",
                "@context": {
                  "name": "schema:name",
                  "country": "schema:type"
                }
              }
            }
          },
          "accessoryRegistrationApprovalLetter": {
            "@id": "cred:accessoryRegistrationApprovalLetter",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "productName": "schema:productName",
              "agentName": "schema:agentName",
              "approvalDate": "schema:approvalDate",
              "validUntil": "schema:validUntil"
            }
          },
          "licenseInspectionLetter": {
            "@id": "cred:licenseInspectionLetter",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              "certificateId": "schema:id",
              "facility": "schema:facility",
              "agentName": "schema:agentName",
              "agentTin": "schema:agentTin",
              "applicationNumber": "schema:applicationNumber",
              "licenseNumber": "schema:licenseNumber",
              "decisionDate": "schema:decisionDate"
            }
          }
        }
      };
      module.exports = {
        CertificateContext: CertificateContext2
      };
    }
  });

  // node_modules/security-context/js/constants.js
  var require_constants = __commonJS({
    "node_modules/security-context/js/constants.js"(exports) {
      "use strict";
      exports.SECURITY_CONTEXT_V1_URL = "https://w3id.org/security/v1";
      exports.SECURITY_CONTEXT_V2_URL = "https://w3id.org/security/v2";
    }
  });

  // node_modules/util/support/isBufferBrowser.js
  var require_isBufferBrowser = __commonJS({
    "node_modules/util/support/isBufferBrowser.js"(exports, module) {
      module.exports = function isBuffer(arg) {
        return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
      };
    }
  });

  // node_modules/util/node_modules/inherits/inherits_browser.js
  var require_inherits_browser = __commonJS({
    "node_modules/util/node_modules/inherits/inherits_browser.js"(exports, module) {
      if (typeof Object.create === "function") {
        module.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        };
      } else {
        module.exports = function inherits(ctor, superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        };
      }
    }
  });

  // node_modules/util/util.js
  var require_util = __commonJS({
    "node_modules/util/util.js"(exports) {
      var formatRegExp = /%[sdj%]/g;
      exports.format = function(f) {
        if (!isString(f)) {
          var objects = [];
          for (var i = 0; i < arguments.length; i++) {
            objects.push(inspect(arguments[i]));
          }
          return objects.join(" ");
        }
        var i = 1;
        var args = arguments;
        var len = args.length;
        var str = String(f).replace(formatRegExp, function(x2) {
          if (x2 === "%%")
            return "%";
          if (i >= len)
            return x2;
          switch (x2) {
            case "%s":
              return String(args[i++]);
            case "%d":
              return Number(args[i++]);
            case "%j":
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return "[Circular]";
              }
            default:
              return x2;
          }
        });
        for (var x = args[i]; i < len; x = args[++i]) {
          if (isNull(x) || !isObject(x)) {
            str += " " + x;
          } else {
            str += " " + inspect(x);
          }
        }
        return str;
      };
      exports.deprecate = function(fn, msg) {
        if (isUndefined(global.process)) {
          return function() {
            return exports.deprecate(fn, msg).apply(this, arguments);
          };
        }
        if (process.noDeprecation === true) {
          return fn;
        }
        var warned = false;
        function deprecated() {
          if (!warned) {
            if (process.throwDeprecation) {
              throw new Error(msg);
            } else if (process.traceDeprecation) {
              console.trace(msg);
            } else {
              console.error(msg);
            }
            warned = true;
          }
          return fn.apply(this, arguments);
        }
        return deprecated;
      };
      var debugs = {};
      var debugEnviron;
      exports.debuglog = function(set) {
        if (isUndefined(debugEnviron))
          debugEnviron = process.env.NODE_DEBUG || "";
        set = set.toUpperCase();
        if (!debugs[set]) {
          if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
            var pid = process.pid;
            debugs[set] = function() {
              var msg = exports.format.apply(exports, arguments);
              console.error("%s %d: %s", set, pid, msg);
            };
          } else {
            debugs[set] = function() {
            };
          }
        }
        return debugs[set];
      };
      function inspect(obj, opts) {
        var ctx = {
          seen: [],
          stylize: stylizeNoColor
        };
        if (arguments.length >= 3)
          ctx.depth = arguments[2];
        if (arguments.length >= 4)
          ctx.colors = arguments[3];
        if (isBoolean(opts)) {
          ctx.showHidden = opts;
        } else if (opts) {
          exports._extend(ctx, opts);
        }
        if (isUndefined(ctx.showHidden))
          ctx.showHidden = false;
        if (isUndefined(ctx.depth))
          ctx.depth = 2;
        if (isUndefined(ctx.colors))
          ctx.colors = false;
        if (isUndefined(ctx.customInspect))
          ctx.customInspect = true;
        if (ctx.colors)
          ctx.stylize = stylizeWithColor;
        return formatValue(ctx, obj, ctx.depth);
      }
      exports.inspect = inspect;
      inspect.colors = {
        "bold": [1, 22],
        "italic": [3, 23],
        "underline": [4, 24],
        "inverse": [7, 27],
        "white": [37, 39],
        "grey": [90, 39],
        "black": [30, 39],
        "blue": [34, 39],
        "cyan": [36, 39],
        "green": [32, 39],
        "magenta": [35, 39],
        "red": [31, 39],
        "yellow": [33, 39]
      };
      inspect.styles = {
        "special": "cyan",
        "number": "yellow",
        "boolean": "yellow",
        "undefined": "grey",
        "null": "bold",
        "string": "green",
        "date": "magenta",
        "regexp": "red"
      };
      function stylizeWithColor(str, styleType) {
        var style = inspect.styles[styleType];
        if (style) {
          return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
        } else {
          return str;
        }
      }
      function stylizeNoColor(str, styleType) {
        return str;
      }
      function arrayToHash(array) {
        var hash = {};
        array.forEach(function(val, idx) {
          hash[val] = true;
        });
        return hash;
      }
      function formatValue(ctx, value, recurseTimes) {
        if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports.inspect && !(value.constructor && value.constructor.prototype === value)) {
          var ret = value.inspect(recurseTimes, ctx);
          if (!isString(ret)) {
            ret = formatValue(ctx, ret, recurseTimes);
          }
          return ret;
        }
        var primitive = formatPrimitive(ctx, value);
        if (primitive) {
          return primitive;
        }
        var keys = Object.keys(value);
        var visibleKeys = arrayToHash(keys);
        if (ctx.showHidden) {
          keys = Object.getOwnPropertyNames(value);
        }
        if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
          return formatError(value);
        }
        if (keys.length === 0) {
          if (isFunction(value)) {
            var name = value.name ? ": " + value.name : "";
            return ctx.stylize("[Function" + name + "]", "special");
          }
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          }
          if (isDate(value)) {
            return ctx.stylize(Date.prototype.toString.call(value), "date");
          }
          if (isError(value)) {
            return formatError(value);
          }
        }
        var base = "", array = false, braces = ["{", "}"];
        if (isArray(value)) {
          array = true;
          braces = ["[", "]"];
        }
        if (isFunction(value)) {
          var n = value.name ? ": " + value.name : "";
          base = " [Function" + n + "]";
        }
        if (isRegExp(value)) {
          base = " " + RegExp.prototype.toString.call(value);
        }
        if (isDate(value)) {
          base = " " + Date.prototype.toUTCString.call(value);
        }
        if (isError(value)) {
          base = " " + formatError(value);
        }
        if (keys.length === 0 && (!array || value.length == 0)) {
          return braces[0] + base + braces[1];
        }
        if (recurseTimes < 0) {
          if (isRegExp(value)) {
            return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
          } else {
            return ctx.stylize("[Object]", "special");
          }
        }
        ctx.seen.push(value);
        var output;
        if (array) {
          output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
        } else {
          output = keys.map(function(key) {
            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
          });
        }
        ctx.seen.pop();
        return reduceToSingleString(output, base, braces);
      }
      function formatPrimitive(ctx, value) {
        if (isUndefined(value))
          return ctx.stylize("undefined", "undefined");
        if (isString(value)) {
          var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
          return ctx.stylize(simple, "string");
        }
        if (isNumber(value))
          return ctx.stylize("" + value, "number");
        if (isBoolean(value))
          return ctx.stylize("" + value, "boolean");
        if (isNull(value))
          return ctx.stylize("null", "null");
      }
      function formatError(value) {
        return "[" + Error.prototype.toString.call(value) + "]";
      }
      function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
        var output = [];
        for (var i = 0, l = value.length; i < l; ++i) {
          if (hasOwnProperty(value, String(i))) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
          } else {
            output.push("");
          }
        }
        keys.forEach(function(key) {
          if (!key.match(/^\d+$/)) {
            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
          }
        });
        return output;
      }
      function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
        var name, str, desc;
        desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
        if (desc.get) {
          if (desc.set) {
            str = ctx.stylize("[Getter/Setter]", "special");
          } else {
            str = ctx.stylize("[Getter]", "special");
          }
        } else {
          if (desc.set) {
            str = ctx.stylize("[Setter]", "special");
          }
        }
        if (!hasOwnProperty(visibleKeys, key)) {
          name = "[" + key + "]";
        }
        if (!str) {
          if (ctx.seen.indexOf(desc.value) < 0) {
            if (isNull(recurseTimes)) {
              str = formatValue(ctx, desc.value, null);
            } else {
              str = formatValue(ctx, desc.value, recurseTimes - 1);
            }
            if (str.indexOf("\n") > -1) {
              if (array) {
                str = str.split("\n").map(function(line) {
                  return "  " + line;
                }).join("\n").substr(2);
              } else {
                str = "\n" + str.split("\n").map(function(line) {
                  return "   " + line;
                }).join("\n");
              }
            }
          } else {
            str = ctx.stylize("[Circular]", "special");
          }
        }
        if (isUndefined(name)) {
          if (array && key.match(/^\d+$/)) {
            return str;
          }
          name = JSON.stringify("" + key);
          if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
            name = name.substr(1, name.length - 2);
            name = ctx.stylize(name, "name");
          } else {
            name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
            name = ctx.stylize(name, "string");
          }
        }
        return name + ": " + str;
      }
      function reduceToSingleString(output, base, braces) {
        var numLinesEst = 0;
        var length = output.reduce(function(prev, cur) {
          numLinesEst++;
          if (cur.indexOf("\n") >= 0)
            numLinesEst++;
          return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
        }, 0);
        if (length > 60) {
          return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
        }
        return braces[0] + base + " " + output.join(", ") + " " + braces[1];
      }
      function isArray(ar) {
        return Array.isArray(ar);
      }
      exports.isArray = isArray;
      function isBoolean(arg) {
        return typeof arg === "boolean";
      }
      exports.isBoolean = isBoolean;
      function isNull(arg) {
        return arg === null;
      }
      exports.isNull = isNull;
      function isNullOrUndefined(arg) {
        return arg == null;
      }
      exports.isNullOrUndefined = isNullOrUndefined;
      function isNumber(arg) {
        return typeof arg === "number";
      }
      exports.isNumber = isNumber;
      function isString(arg) {
        return typeof arg === "string";
      }
      exports.isString = isString;
      function isSymbol(arg) {
        return typeof arg === "symbol";
      }
      exports.isSymbol = isSymbol;
      function isUndefined(arg) {
        return arg === void 0;
      }
      exports.isUndefined = isUndefined;
      function isRegExp(re) {
        return isObject(re) && objectToString(re) === "[object RegExp]";
      }
      exports.isRegExp = isRegExp;
      function isObject(arg) {
        return typeof arg === "object" && arg !== null;
      }
      exports.isObject = isObject;
      function isDate(d) {
        return isObject(d) && objectToString(d) === "[object Date]";
      }
      exports.isDate = isDate;
      function isError(e) {
        return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
      }
      exports.isError = isError;
      function isFunction(arg) {
        return typeof arg === "function";
      }
      exports.isFunction = isFunction;
      function isPrimitive(arg) {
        return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
      }
      exports.isPrimitive = isPrimitive;
      exports.isBuffer = require_isBufferBrowser();
      function objectToString(o) {
        return Object.prototype.toString.call(o);
      }
      function pad(n) {
        return n < 10 ? "0" + n.toString(10) : n.toString(10);
      }
      var months = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      function timestamp() {
        var d = new Date();
        var time = [
          pad(d.getHours()),
          pad(d.getMinutes()),
          pad(d.getSeconds())
        ].join(":");
        return [d.getDate(), months[d.getMonth()], time].join(" ");
      }
      exports.log = function() {
        console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
      };
      exports.inherits = require_inherits_browser();
      exports._extend = function(origin, add) {
        if (!add || !isObject(add))
          return origin;
        var keys = Object.keys(add);
        var i = keys.length;
        while (i--) {
          origin[keys[i]] = add[keys[i]];
        }
        return origin;
      };
      function hasOwnProperty(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
      }
    }
  });

  // node_modules/path/path.js
  var require_path = __commonJS({
    "node_modules/path/path.js"(exports, module) {
      "use strict";
      var isWindows = process.platform === "win32";
      var util = require_util();
      function normalizeArray(parts, allowAboveRoot) {
        var res = [];
        for (var i = 0; i < parts.length; i++) {
          var p = parts[i];
          if (!p || p === ".")
            continue;
          if (p === "..") {
            if (res.length && res[res.length - 1] !== "..") {
              res.pop();
            } else if (allowAboveRoot) {
              res.push("..");
            }
          } else {
            res.push(p);
          }
        }
        return res;
      }
      function trimArray(arr) {
        var lastIndex = arr.length - 1;
        var start = 0;
        for (; start <= lastIndex; start++) {
          if (arr[start])
            break;
        }
        var end = lastIndex;
        for (; end >= 0; end--) {
          if (arr[end])
            break;
        }
        if (start === 0 && end === lastIndex)
          return arr;
        if (start > end)
          return [];
        return arr.slice(start, end + 1);
      }
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var splitTailRe = /^([\s\S]*?)((?:\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))(?:[\\\/]*)$/;
      var win32 = {};
      function win32SplitPath(filename) {
        var result = splitDeviceRe.exec(filename), device = (result[1] || "") + (result[2] || ""), tail = result[3] || "";
        var result2 = splitTailRe.exec(tail), dir = result2[1], basename = result2[2], ext = result2[3];
        return [device, dir, basename, ext];
      }
      function win32StatPath(path) {
        var result = splitDeviceRe.exec(path), device = result[1] || "", isUnc = !!device && device[1] !== ":";
        return {
          device,
          isUnc,
          isAbsolute: isUnc || !!result[2],
          tail: result[3]
        };
      }
      function normalizeUNCRoot(device) {
        return "\\\\" + device.replace(/^[\\\/]+/, "").replace(/[\\\/]+/g, "\\");
      }
      win32.resolve = function() {
        var resolvedDevice = "", resolvedTail = "", resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1; i--) {
          var path;
          if (i >= 0) {
            path = arguments[i];
          } else if (!resolvedDevice) {
            path = process.cwd();
          } else {
            path = process.env["=" + resolvedDevice];
            if (!path || path.substr(0, 3).toLowerCase() !== resolvedDevice.toLowerCase() + "\\") {
              path = resolvedDevice + "\\";
            }
          }
          if (!util.isString(path)) {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            continue;
          }
          var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail;
          if (device && resolvedDevice && device.toLowerCase() !== resolvedDevice.toLowerCase()) {
            continue;
          }
          if (!resolvedDevice) {
            resolvedDevice = device;
          }
          if (!resolvedAbsolute) {
            resolvedTail = tail + "\\" + resolvedTail;
            resolvedAbsolute = isAbsolute;
          }
          if (resolvedDevice && resolvedAbsolute) {
            break;
          }
        }
        if (isUnc) {
          resolvedDevice = normalizeUNCRoot(resolvedDevice);
        }
        resolvedTail = normalizeArray(resolvedTail.split(/[\\\/]+/), !resolvedAbsolute).join("\\");
        return resolvedDevice + (resolvedAbsolute ? "\\" : "") + resolvedTail || ".";
      };
      win32.normalize = function(path) {
        var result = win32StatPath(path), device = result.device, isUnc = result.isUnc, isAbsolute = result.isAbsolute, tail = result.tail, trailingSlash = /[\\\/]$/.test(tail);
        tail = normalizeArray(tail.split(/[\\\/]+/), !isAbsolute).join("\\");
        if (!tail && !isAbsolute) {
          tail = ".";
        }
        if (tail && trailingSlash) {
          tail += "\\";
        }
        if (isUnc) {
          device = normalizeUNCRoot(device);
        }
        return device + (isAbsolute ? "\\" : "") + tail;
      };
      win32.isAbsolute = function(path) {
        return win32StatPath(path).isAbsolute;
      };
      win32.join = function() {
        var paths = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!util.isString(arg)) {
            throw new TypeError("Arguments to path.join must be strings");
          }
          if (arg) {
            paths.push(arg);
          }
        }
        var joined = paths.join("\\");
        if (!/^[\\\/]{2}[^\\\/]/.test(paths[0])) {
          joined = joined.replace(/^[\\\/]{2,}/, "\\");
        }
        return win32.normalize(joined);
      };
      win32.relative = function(from, to) {
        from = win32.resolve(from);
        to = win32.resolve(to);
        var lowerFrom = from.toLowerCase();
        var lowerTo = to.toLowerCase();
        var toParts = trimArray(to.split("\\"));
        var lowerFromParts = trimArray(lowerFrom.split("\\"));
        var lowerToParts = trimArray(lowerTo.split("\\"));
        var length = Math.min(lowerFromParts.length, lowerToParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (lowerFromParts[i] !== lowerToParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        if (samePartsLength == 0) {
          return to;
        }
        var outputParts = [];
        for (var i = samePartsLength; i < lowerFromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("\\");
      };
      win32._makeLong = function(path) {
        if (!util.isString(path))
          return path;
        if (!path) {
          return "";
        }
        var resolvedPath = win32.resolve(path);
        if (/^[a-zA-Z]\:\\/.test(resolvedPath)) {
          return "\\\\?\\" + resolvedPath;
        } else if (/^\\\\[^?.]/.test(resolvedPath)) {
          return "\\\\?\\UNC\\" + resolvedPath.substring(2);
        }
        return path;
      };
      win32.dirname = function(path) {
        var result = win32SplitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      };
      win32.basename = function(path, ext) {
        var f = win32SplitPath(path)[2];
        if (ext && f.substr(-1 * ext.length) === ext) {
          f = f.substr(0, f.length - ext.length);
        }
        return f;
      };
      win32.extname = function(path) {
        return win32SplitPath(path)[3];
      };
      win32.format = function(pathObject) {
        if (!util.isObject(pathObject)) {
          throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
        }
        var root = pathObject.root || "";
        if (!util.isString(root)) {
          throw new TypeError("'pathObject.root' must be a string or undefined, not " + typeof pathObject.root);
        }
        var dir = pathObject.dir;
        var base = pathObject.base || "";
        if (!dir) {
          return base;
        }
        if (dir[dir.length - 1] === win32.sep) {
          return dir + base;
        }
        return dir + win32.sep + base;
      };
      win32.parse = function(pathString) {
        if (!util.isString(pathString)) {
          throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
        }
        var allParts = win32SplitPath(pathString);
        if (!allParts || allParts.length !== 4) {
          throw new TypeError("Invalid path '" + pathString + "'");
        }
        return {
          root: allParts[0],
          dir: allParts[0] + allParts[1].slice(0, -1),
          base: allParts[2],
          ext: allParts[3],
          name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
        };
      };
      win32.sep = "\\";
      win32.delimiter = ";";
      var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
      var posix = {};
      function posixSplitPath(filename) {
        return splitPathRe.exec(filename).slice(1);
      }
      posix.resolve = function() {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? arguments[i] : process.cwd();
          if (!util.isString(path)) {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            continue;
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = path[0] === "/";
        }
        resolvedPath = normalizeArray(resolvedPath.split("/"), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      };
      posix.normalize = function(path) {
        var isAbsolute = posix.isAbsolute(path), trailingSlash = path && path[path.length - 1] === "/";
        path = normalizeArray(path.split("/"), !isAbsolute).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      };
      posix.isAbsolute = function(path) {
        return path.charAt(0) === "/";
      };
      posix.join = function() {
        var path = "";
        for (var i = 0; i < arguments.length; i++) {
          var segment = arguments[i];
          if (!util.isString(segment)) {
            throw new TypeError("Arguments to path.join must be strings");
          }
          if (segment) {
            if (!path) {
              path += segment;
            } else {
              path += "/" + segment;
            }
          }
        }
        return posix.normalize(path);
      };
      posix.relative = function(from, to) {
        from = posix.resolve(from).substr(1);
        to = posix.resolve(to).substr(1);
        var fromParts = trimArray(from.split("/"));
        var toParts = trimArray(to.split("/"));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      };
      posix._makeLong = function(path) {
        return path;
      };
      posix.dirname = function(path) {
        var result = posixSplitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      };
      posix.basename = function(path, ext) {
        var f = posixSplitPath(path)[2];
        if (ext && f.substr(-1 * ext.length) === ext) {
          f = f.substr(0, f.length - ext.length);
        }
        return f;
      };
      posix.extname = function(path) {
        return posixSplitPath(path)[3];
      };
      posix.format = function(pathObject) {
        if (!util.isObject(pathObject)) {
          throw new TypeError("Parameter 'pathObject' must be an object, not " + typeof pathObject);
        }
        var root = pathObject.root || "";
        if (!util.isString(root)) {
          throw new TypeError("'pathObject.root' must be a string or undefined, not " + typeof pathObject.root);
        }
        var dir = pathObject.dir ? pathObject.dir + posix.sep : "";
        var base = pathObject.base || "";
        return dir + base;
      };
      posix.parse = function(pathString) {
        if (!util.isString(pathString)) {
          throw new TypeError("Parameter 'pathString' must be a string, not " + typeof pathString);
        }
        var allParts = posixSplitPath(pathString);
        if (!allParts || allParts.length !== 4) {
          throw new TypeError("Invalid path '" + pathString + "'");
        }
        allParts[1] = allParts[1] || "";
        allParts[2] = allParts[2] || "";
        allParts[3] = allParts[3] || "";
        return {
          root: allParts[0],
          dir: allParts[0] + allParts[1].slice(0, -1),
          base: allParts[2],
          ext: allParts[3],
          name: allParts[2].slice(0, allParts[2].length - allParts[3].length)
        };
      };
      posix.sep = "/";
      posix.delimiter = ":";
      if (isWindows)
        module.exports = win32;
      else
        module.exports = posix;
      module.exports.posix = posix;
      module.exports.win32 = win32;
    }
  });

  // node_modules/security-context/js/index.js
  var require_js = __commonJS({
    "node_modules/security-context/js/index.js"(exports) {
      "use strict";
      var constants = require_constants();
      var path = require_path();
      exports.constants = constants;
      var contexts = exports.contexts = /* @__PURE__ */ new Map();
      function _read(_path) {
        return JSON.parse({});
      }
      contexts.set(constants.SECURITY_CONTEXT_V1_URL, _read("../contexts/security-v1.jsonld"));
      contexts.set(constants.SECURITY_CONTEXT_V2_URL, _read("../contexts/security-v2.jsonld"));
    }
  });

  // node_modules/jsonld-signatures/lib/constants.js
  var require_constants2 = __commonJS({
    "node_modules/jsonld-signatures/lib/constants.js"(exports, module) {
      "use strict";
      var { constants: securityConstants } = require_js();
      module.exports = {
        SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
        SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
        SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
        SECURITY_PROOF_URL: "https://w3id.org/security#proof",
        SECURITY_SIGNATURE_URL: "https://w3id.org/security#signature"
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js
  var require_IdentifierIssuer = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/IdentifierIssuer.js"(exports, module) {
      "use strict";
      module.exports = class IdentifierIssuer {
        constructor(prefix, existing = /* @__PURE__ */ new Map(), counter = 0) {
          this.prefix = prefix;
          this._existing = existing;
          this.counter = counter;
        }
        clone() {
          const { prefix, _existing, counter } = this;
          return new IdentifierIssuer(prefix, new Map(_existing), counter);
        }
        getId(old) {
          const existing = old && this._existing.get(old);
          if (existing) {
            return existing;
          }
          const identifier = this.prefix + this.counter;
          this.counter++;
          if (old) {
            this._existing.set(old, identifier);
          }
          return identifier;
        }
        hasId(old) {
          return this._existing.has(old);
        }
        getOldIds() {
          return [...this._existing.keys()];
        }
      };
    }
  });

  // node_modules/setimmediate/setImmediate.js
  var require_setImmediate = __commonJS({
    "node_modules/setimmediate/setImmediate.js"(exports) {
      (function(global2, undefined2) {
        "use strict";
        if (global2.setImmediate) {
          return;
        }
        var nextHandle = 1;
        var tasksByHandle = {};
        var currentlyRunningATask = false;
        var doc = global2.document;
        var registerImmediate;
        function setImmediate2(callback) {
          if (typeof callback !== "function") {
            callback = new Function("" + callback);
          }
          var args = new Array(arguments.length - 1);
          for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
          }
          var task = { callback, args };
          tasksByHandle[nextHandle] = task;
          registerImmediate(nextHandle);
          return nextHandle++;
        }
        function clearImmediate(handle) {
          delete tasksByHandle[handle];
        }
        function run(task) {
          var callback = task.callback;
          var args = task.args;
          switch (args.length) {
            case 0:
              callback();
              break;
            case 1:
              callback(args[0]);
              break;
            case 2:
              callback(args[0], args[1]);
              break;
            case 3:
              callback(args[0], args[1], args[2]);
              break;
            default:
              callback.apply(undefined2, args);
              break;
          }
        }
        function runIfPresent(handle) {
          if (currentlyRunningATask) {
            setTimeout(runIfPresent, 0, handle);
          } else {
            var task = tasksByHandle[handle];
            if (task) {
              currentlyRunningATask = true;
              try {
                run(task);
              } finally {
                clearImmediate(handle);
                currentlyRunningATask = false;
              }
            }
          }
        }
        function installNextTickImplementation() {
          registerImmediate = function(handle) {
            process.nextTick(function() {
              runIfPresent(handle);
            });
          };
        }
        function canUsePostMessage() {
          if (global2.postMessage && !global2.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global2.onmessage;
            global2.onmessage = function() {
              postMessageIsAsynchronous = false;
            };
            global2.postMessage("", "*");
            global2.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
          }
        }
        function installPostMessageImplementation() {
          var messagePrefix = "setImmediate$" + Math.random() + "$";
          var onGlobalMessage = function(event) {
            if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
              runIfPresent(+event.data.slice(messagePrefix.length));
            }
          };
          if (global2.addEventListener) {
            global2.addEventListener("message", onGlobalMessage, false);
          } else {
            global2.attachEvent("onmessage", onGlobalMessage);
          }
          registerImmediate = function(handle) {
            global2.postMessage(messagePrefix + handle, "*");
          };
        }
        function installMessageChannelImplementation() {
          var channel = new MessageChannel();
          channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
          };
          registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
          };
        }
        function installReadyStateChangeImplementation() {
          var html = doc.documentElement;
          registerImmediate = function(handle) {
            var script = doc.createElement("script");
            script.onreadystatechange = function() {
              runIfPresent(handle);
              script.onreadystatechange = null;
              html.removeChild(script);
              script = null;
            };
            html.appendChild(script);
          };
        }
        function installSetTimeoutImplementation() {
          registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
          };
        }
        var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
        attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
        if ({}.toString.call(global2.process) === "[object process]") {
          installNextTickImplementation();
        } else if (canUsePostMessage()) {
          installPostMessageImplementation();
        } else if (global2.MessageChannel) {
          installMessageChannelImplementation();
        } else if (doc && "onreadystatechange" in doc.createElement("script")) {
          installReadyStateChangeImplementation();
        } else {
          installSetTimeoutImplementation();
        }
        attachTo.setImmediate = setImmediate2;
        attachTo.clearImmediate = clearImmediate;
      })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest-browser.js
  var require_MessageDigest_browser = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/MessageDigest-browser.js"(exports, module) {
      "use strict";
      require_setImmediate();
      var crypto = self.crypto || self.msCrypto;
      module.exports = class MessageDigest {
        constructor(algorithm) {
          if (!(crypto && crypto.subtle)) {
            throw new Error("crypto.subtle not found.");
          }
          if (algorithm === "sha256") {
            this.algorithm = { name: "SHA-256" };
          } else if (algorithm === "sha1") {
            this.algorithm = { name: "SHA-1" };
          } else {
            throw new Error(`Unsupport algorithm "${algorithm}".`);
          }
          this._content = "";
        }
        update(msg) {
          this._content += msg;
        }
        async digest() {
          const data = new TextEncoder().encode(this._content);
          const buffer = new Uint8Array(await crypto.subtle.digest(this.algorithm, data));
          let hex = "";
          for (let i = 0; i < buffer.length; ++i) {
            hex += buffer[i].toString(16).padStart(2, "0");
          }
          return hex;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js
  var require_Permuter = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/Permuter.js"(exports, module) {
      "use strict";
      module.exports = class Permuter {
        constructor(list) {
          this.current = list.sort();
          this.done = false;
          this.dir = /* @__PURE__ */ new Map();
          for (let i = 0; i < list.length; ++i) {
            this.dir.set(list[i], true);
          }
        }
        hasNext() {
          return !this.done;
        }
        next() {
          const { current, dir } = this;
          const rval = current.slice();
          let k = null;
          let pos = 0;
          const length = current.length;
          for (let i = 0; i < length; ++i) {
            const element = current[i];
            const left = dir.get(element);
            if ((k === null || element > k) && (left && i > 0 && element > current[i - 1] || !left && i < length - 1 && element > current[i + 1])) {
              k = element;
              pos = i;
            }
          }
          if (k === null) {
            this.done = true;
          } else {
            const swap = dir.get(k) ? pos - 1 : pos + 1;
            current[pos] = current[swap];
            current[swap] = k;
            for (const element of current) {
              if (element > k) {
                dir.set(element, !dir.get(element));
              }
            }
          }
          return rval;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js
  var require_NQuads = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/NQuads.js"(exports, module) {
      "use strict";
      var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      var RDF_LANGSTRING = RDF + "langString";
      var XSD_STRING = "http://www.w3.org/2001/XMLSchema#string";
      var TYPE_NAMED_NODE = "NamedNode";
      var TYPE_BLANK_NODE = "BlankNode";
      var TYPE_LITERAL = "Literal";
      var TYPE_DEFAULT_GRAPH = "DefaultGraph";
      var REGEX = {};
      (() => {
        const iri = "(?:<([^:]+:[^>]*)>)";
        const PN_CHARS_BASE = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
        const PN_CHARS_U = PN_CHARS_BASE + "_";
        const PN_CHARS = PN_CHARS_U + "0-9-\xB7\u0300-\u036F\u203F-\u2040";
        const BLANK_NODE_LABEL = "(_:(?:[" + PN_CHARS_U + "0-9])(?:(?:[" + PN_CHARS + ".])*(?:[" + PN_CHARS + "]))?)";
        const bnode = BLANK_NODE_LABEL;
        const plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
        const datatype = "(?:\\^\\^" + iri + ")";
        const language = "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))";
        const literal = "(?:" + plain + "(?:" + datatype + "|" + language + ")?)";
        const ws = "[ \\t]+";
        const wso = "[ \\t]*";
        const subject = "(?:" + iri + "|" + bnode + ")" + ws;
        const property = iri + ws;
        const object = "(?:" + iri + "|" + bnode + "|" + literal + ")" + wso;
        const graphName = "(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))";
        REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
        REGEX.empty = new RegExp("^" + wso + "$");
        REGEX.quad = new RegExp("^" + wso + subject + property + object + graphName + wso + "$");
      })();
      module.exports = class NQuads {
        static parse(input) {
          const dataset = [];
          const graphs = {};
          const lines = input.split(REGEX.eoln);
          let lineNumber = 0;
          for (const line of lines) {
            lineNumber++;
            if (REGEX.empty.test(line)) {
              continue;
            }
            const match = line.match(REGEX.quad);
            if (match === null) {
              throw new Error("N-Quads parse error on line " + lineNumber + ".");
            }
            const quad = { subject: null, predicate: null, object: null, graph: null };
            if (match[1] !== void 0) {
              quad.subject = { termType: TYPE_NAMED_NODE, value: match[1] };
            } else {
              quad.subject = { termType: TYPE_BLANK_NODE, value: match[2] };
            }
            quad.predicate = { termType: TYPE_NAMED_NODE, value: match[3] };
            if (match[4] !== void 0) {
              quad.object = { termType: TYPE_NAMED_NODE, value: match[4] };
            } else if (match[5] !== void 0) {
              quad.object = { termType: TYPE_BLANK_NODE, value: match[5] };
            } else {
              quad.object = {
                termType: TYPE_LITERAL,
                value: void 0,
                datatype: {
                  termType: TYPE_NAMED_NODE
                }
              };
              if (match[7] !== void 0) {
                quad.object.datatype.value = match[7];
              } else if (match[8] !== void 0) {
                quad.object.datatype.value = RDF_LANGSTRING;
                quad.object.language = match[8];
              } else {
                quad.object.datatype.value = XSD_STRING;
              }
              quad.object.value = _unescape(match[6]);
            }
            if (match[9] !== void 0) {
              quad.graph = {
                termType: TYPE_NAMED_NODE,
                value: match[9]
              };
            } else if (match[10] !== void 0) {
              quad.graph = {
                termType: TYPE_BLANK_NODE,
                value: match[10]
              };
            } else {
              quad.graph = {
                termType: TYPE_DEFAULT_GRAPH,
                value: ""
              };
            }
            if (!(quad.graph.value in graphs)) {
              graphs[quad.graph.value] = [quad];
              dataset.push(quad);
            } else {
              let unique = true;
              const quads = graphs[quad.graph.value];
              for (const q of quads) {
                if (_compareTriples(q, quad)) {
                  unique = false;
                  break;
                }
              }
              if (unique) {
                quads.push(quad);
                dataset.push(quad);
              }
            }
          }
          return dataset;
        }
        static serialize(dataset) {
          if (!Array.isArray(dataset)) {
            dataset = NQuads.legacyDatasetToQuads(dataset);
          }
          const quads = [];
          for (const quad of dataset) {
            quads.push(NQuads.serializeQuad(quad));
          }
          return quads.sort().join("");
        }
        static serializeQuad(quad) {
          const s = quad.subject;
          const p = quad.predicate;
          const o = quad.object;
          const g = quad.graph;
          let nquad = "";
          if (s.termType === TYPE_NAMED_NODE) {
            nquad += `<${s.value}>`;
          } else {
            nquad += `${s.value}`;
          }
          nquad += ` <${p.value}> `;
          if (o.termType === TYPE_NAMED_NODE) {
            nquad += `<${o.value}>`;
          } else if (o.termType === TYPE_BLANK_NODE) {
            nquad += o.value;
          } else {
            nquad += `"${_escape(o.value)}"`;
            if (o.datatype.value === RDF_LANGSTRING) {
              if (o.language) {
                nquad += `@${o.language}`;
              }
            } else if (o.datatype.value !== XSD_STRING) {
              nquad += `^^<${o.datatype.value}>`;
            }
          }
          if (g.termType === TYPE_NAMED_NODE) {
            nquad += ` <${g.value}>`;
          } else if (g.termType === TYPE_BLANK_NODE) {
            nquad += ` ${g.value}`;
          }
          nquad += " .\n";
          return nquad;
        }
        static legacyDatasetToQuads(dataset) {
          const quads = [];
          const termTypeMap = {
            "blank node": TYPE_BLANK_NODE,
            IRI: TYPE_NAMED_NODE,
            literal: TYPE_LITERAL
          };
          for (const graphName in dataset) {
            const triples = dataset[graphName];
            triples.forEach((triple) => {
              const quad = {};
              for (const componentName in triple) {
                const oldComponent = triple[componentName];
                const newComponent = {
                  termType: termTypeMap[oldComponent.type],
                  value: oldComponent.value
                };
                if (newComponent.termType === TYPE_LITERAL) {
                  newComponent.datatype = {
                    termType: TYPE_NAMED_NODE
                  };
                  if ("datatype" in oldComponent) {
                    newComponent.datatype.value = oldComponent.datatype;
                  }
                  if ("language" in oldComponent) {
                    if (!("datatype" in oldComponent)) {
                      newComponent.datatype.value = RDF_LANGSTRING;
                    }
                    newComponent.language = oldComponent.language;
                  } else if (!("datatype" in oldComponent)) {
                    newComponent.datatype.value = XSD_STRING;
                  }
                }
                quad[componentName] = newComponent;
              }
              if (graphName === "@default") {
                quad.graph = {
                  termType: TYPE_DEFAULT_GRAPH,
                  value: ""
                };
              } else {
                quad.graph = {
                  termType: graphName.startsWith("_:") ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,
                  value: graphName
                };
              }
              quads.push(quad);
            });
          }
          return quads;
        }
      };
      function _compareTriples(t1, t2) {
        if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {
          return false;
        }
        if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {
          return false;
        }
        if (t1.object.termType !== TYPE_LITERAL) {
          return true;
        }
        return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;
      }
      var _escapeRegex = /["\\\n\r]/g;
      function _escape(s) {
        return s.replace(_escapeRegex, function(match) {
          switch (match) {
            case '"':
              return '\\"';
            case "\\":
              return "\\\\";
            case "\n":
              return "\\n";
            case "\r":
              return "\\r";
          }
        });
      }
      var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
      function _unescape(s) {
        return s.replace(_unescapeRegex, function(match, code, u, U) {
          if (code) {
            switch (code) {
              case "t":
                return "	";
              case "b":
                return "\b";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "f":
                return "\f";
              case '"':
                return '"';
              case "'":
                return "'";
              case "\\":
                return "\\";
            }
          }
          if (u) {
            return String.fromCharCode(parseInt(u, 16));
          }
          if (U) {
            throw new Error("Unsupported U escape");
          }
        });
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URDNA2015.js
  var require_URDNA2015 = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URDNA2015.js"(exports, module) {
      "use strict";
      var IdentifierIssuer = require_IdentifierIssuer();
      var MessageDigest = require_MessageDigest_browser();
      var Permuter = require_Permuter();
      var NQuads = require_NQuads();
      module.exports = class URDNA2015 {
        constructor() {
          this.name = "URDNA2015";
          this.blankNodeInfo = /* @__PURE__ */ new Map();
          this.canonicalIssuer = new IdentifierIssuer("_:c14n");
          this.hashAlgorithm = "sha256";
          this.quads = null;
        }
        async main(dataset) {
          this.quads = dataset;
          for (const quad of dataset) {
            this._addBlankNodeQuadInfo({ quad, component: quad.subject });
            this._addBlankNodeQuadInfo({ quad, component: quad.object });
            this._addBlankNodeQuadInfo({ quad, component: quad.graph });
          }
          const hashToBlankNodes = /* @__PURE__ */ new Map();
          const nonNormalized = [...this.blankNodeInfo.keys()];
          let i = 0;
          for (const id of nonNormalized) {
            if (++i % 100 === 0) {
              await this._yield();
            }
            await this._hashAndTrackBlankNode({ id, hashToBlankNodes });
          }
          const hashes = [...hashToBlankNodes.keys()].sort();
          const nonUnique = [];
          for (const hash of hashes) {
            const idList = hashToBlankNodes.get(hash);
            if (idList.length > 1) {
              nonUnique.push(idList);
              continue;
            }
            const id = idList[0];
            this.canonicalIssuer.getId(id);
          }
          for (const idList of nonUnique) {
            const hashPathList = [];
            for (const id of idList) {
              if (this.canonicalIssuer.hasId(id)) {
                continue;
              }
              const issuer = new IdentifierIssuer("_:b");
              issuer.getId(id);
              const result = await this.hashNDegreeQuads(id, issuer);
              hashPathList.push(result);
            }
            hashPathList.sort(_stringHashCompare);
            for (const result of hashPathList) {
              const oldIds = result.issuer.getOldIds();
              for (const id of oldIds) {
                this.canonicalIssuer.getId(id);
              }
            }
          }
          const normalized = [];
          for (const quad of this.quads) {
            const q = { ...quad };
            q.subject = this._useCanonicalId({ component: q.subject });
            q.object = this._useCanonicalId({ component: q.object });
            q.graph = this._useCanonicalId({ component: q.graph });
            normalized.push(NQuads.serializeQuad(q));
          }
          normalized.sort();
          return normalized.join("");
        }
        async hashFirstDegreeQuads(id) {
          const nquads = [];
          const info = this.blankNodeInfo.get(id);
          const quads = info.quads;
          for (const quad of quads) {
            const copy = {
              subject: null,
              predicate: quad.predicate,
              object: null,
              graph: null
            };
            copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, "subject");
            copy.object = this.modifyFirstDegreeComponent(id, quad.object, "object");
            copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, "graph");
            nquads.push(NQuads.serializeQuad(copy));
          }
          nquads.sort();
          const md = new MessageDigest(this.hashAlgorithm);
          for (const nquad of nquads) {
            md.update(nquad);
          }
          info.hash = await md.digest();
          return info.hash;
        }
        async hashRelatedBlankNode(related, quad, issuer, position) {
          let id;
          if (this.canonicalIssuer.hasId(related)) {
            id = this.canonicalIssuer.getId(related);
          } else if (issuer.hasId(related)) {
            id = issuer.getId(related);
          } else {
            id = this.blankNodeInfo.get(related).hash;
          }
          const md = new MessageDigest(this.hashAlgorithm);
          md.update(position);
          if (position !== "g") {
            md.update(this.getRelatedPredicate(quad));
          }
          md.update(id);
          return md.digest();
        }
        async hashNDegreeQuads(id, issuer) {
          const md = new MessageDigest(this.hashAlgorithm);
          const hashToRelated = await this.createHashToRelated(id, issuer);
          const hashes = [...hashToRelated.keys()].sort();
          for (const hash of hashes) {
            md.update(hash);
            let chosenPath = "";
            let chosenIssuer;
            const permuter = new Permuter(hashToRelated.get(hash));
            let i = 0;
            while (permuter.hasNext()) {
              const permutation = permuter.next();
              if (++i % 3 === 0) {
                await this._yield();
              }
              let issuerCopy = issuer.clone();
              let path = "";
              const recursionList = [];
              let nextPermutation = false;
              for (const related of permutation) {
                if (this.canonicalIssuer.hasId(related)) {
                  path += this.canonicalIssuer.getId(related);
                } else {
                  if (!issuerCopy.hasId(related)) {
                    recursionList.push(related);
                  }
                  path += issuerCopy.getId(related);
                }
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              for (const related of recursionList) {
                const result = await this.hashNDegreeQuads(related, issuerCopy);
                path += issuerCopy.getId(related);
                path += `<${result.hash}>`;
                issuerCopy = result.issuer;
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              if (chosenPath.length === 0 || path < chosenPath) {
                chosenPath = path;
                chosenIssuer = issuerCopy;
              }
            }
            md.update(chosenPath);
            issuer = chosenIssuer;
          }
          return { hash: await md.digest(), issuer };
        }
        modifyFirstDegreeComponent(id, component) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          return {
            termType: "BlankNode",
            value: component.value === id ? "_:a" : "_:z"
          };
        }
        getRelatedPredicate(quad) {
          return `<${quad.predicate.value}>`;
        }
        async createHashToRelated(id, issuer) {
          const hashToRelated = /* @__PURE__ */ new Map();
          const quads = this.blankNodeInfo.get(id).quads;
          let i = 0;
          for (const quad of quads) {
            if (++i % 100 === 0) {
              await this._yield();
            }
            await Promise.all([
              this._addRelatedBlankNodeHash({
                quad,
                component: quad.subject,
                position: "s",
                id,
                issuer,
                hashToRelated
              }),
              this._addRelatedBlankNodeHash({
                quad,
                component: quad.object,
                position: "o",
                id,
                issuer,
                hashToRelated
              }),
              this._addRelatedBlankNodeHash({
                quad,
                component: quad.graph,
                position: "g",
                id,
                issuer,
                hashToRelated
              })
            ]);
          }
          return hashToRelated;
        }
        async _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
          const hash = await this.hashFirstDegreeQuads(id);
          const idList = hashToBlankNodes.get(hash);
          if (!idList) {
            hashToBlankNodes.set(hash, [id]);
          } else {
            idList.push(id);
          }
        }
        _addBlankNodeQuadInfo({ quad, component }) {
          if (component.termType !== "BlankNode") {
            return;
          }
          const id = component.value;
          const info = this.blankNodeInfo.get(id);
          if (info) {
            info.quads.add(quad);
          } else {
            this.blankNodeInfo.set(id, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
          }
        }
        async _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
          if (!(component.termType === "BlankNode" && component.value !== id)) {
            return;
          }
          const related = component.value;
          const hash = await this.hashRelatedBlankNode(related, quad, issuer, position);
          const entries = hashToRelated.get(hash);
          if (entries) {
            entries.push(related);
          } else {
            hashToRelated.set(hash, [related]);
          }
        }
        _useCanonicalId({ component }) {
          if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
            return {
              termType: "BlankNode",
              value: this.canonicalIssuer.getId(component.value)
            };
          }
          return component;
        }
        async _yield() {
          return new Promise((resolve) => setImmediate(resolve));
        }
      };
      function _stringHashCompare(a, b) {
        return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URGNA2012.js
  var require_URGNA2012 = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URGNA2012.js"(exports, module) {
      "use strict";
      var URDNA2015 = require_URDNA2015();
      module.exports = class URDNA2012 extends URDNA2015 {
        constructor() {
          super();
          this.name = "URGNA2012";
          this.hashAlgorithm = "sha1";
        }
        modifyFirstDegreeComponent(id, component, key) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          if (key === "graph") {
            return {
              termType: "BlankNode",
              value: "_:g"
            };
          }
          return {
            termType: "BlankNode",
            value: component.value === id ? "_:a" : "_:z"
          };
        }
        getRelatedPredicate(quad) {
          return quad.predicate.value;
        }
        async createHashToRelated(id, issuer) {
          const hashToRelated = /* @__PURE__ */ new Map();
          const quads = this.blankNodeInfo.get(id).quads;
          let i = 0;
          for (const quad of quads) {
            let position;
            let related;
            if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
              related = quad.subject.value;
              position = "p";
            } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
              related = quad.object.value;
              position = "r";
            } else {
              continue;
            }
            if (++i % 100 === 0) {
              await this._yield();
            }
            const hash = await this.hashRelatedBlankNode(related, quad, issuer, position);
            const entries = hashToRelated.get(hash);
            if (entries) {
              entries.push(related);
            } else {
              hashToRelated.set(hash, [related]);
            }
          }
          return hashToRelated;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URDNA2015Sync.js
  var require_URDNA2015Sync = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URDNA2015Sync.js"(exports, module) {
      "use strict";
      var IdentifierIssuer = require_IdentifierIssuer();
      var MessageDigest = require_MessageDigest_browser();
      var Permuter = require_Permuter();
      var NQuads = require_NQuads();
      module.exports = class URDNA2015Sync {
        constructor() {
          this.name = "URDNA2015";
          this.blankNodeInfo = /* @__PURE__ */ new Map();
          this.canonicalIssuer = new IdentifierIssuer("_:c14n");
          this.hashAlgorithm = "sha256";
          this.quads = null;
        }
        main(dataset) {
          this.quads = dataset;
          for (const quad of dataset) {
            this._addBlankNodeQuadInfo({ quad, component: quad.subject });
            this._addBlankNodeQuadInfo({ quad, component: quad.object });
            this._addBlankNodeQuadInfo({ quad, component: quad.graph });
          }
          const hashToBlankNodes = /* @__PURE__ */ new Map();
          const nonNormalized = [...this.blankNodeInfo.keys()];
          for (const id of nonNormalized) {
            this._hashAndTrackBlankNode({ id, hashToBlankNodes });
          }
          const hashes = [...hashToBlankNodes.keys()].sort();
          const nonUnique = [];
          for (const hash of hashes) {
            const idList = hashToBlankNodes.get(hash);
            if (idList.length > 1) {
              nonUnique.push(idList);
              continue;
            }
            const id = idList[0];
            this.canonicalIssuer.getId(id);
          }
          for (const idList of nonUnique) {
            const hashPathList = [];
            for (const id of idList) {
              if (this.canonicalIssuer.hasId(id)) {
                continue;
              }
              const issuer = new IdentifierIssuer("_:b");
              issuer.getId(id);
              const result = this.hashNDegreeQuads(id, issuer);
              hashPathList.push(result);
            }
            hashPathList.sort(_stringHashCompare);
            for (const result of hashPathList) {
              const oldIds = result.issuer.getOldIds();
              for (const id of oldIds) {
                this.canonicalIssuer.getId(id);
              }
            }
          }
          const normalized = [];
          for (const quad of this.quads) {
            const q = { ...quad };
            q.subject = this._useCanonicalId({ component: q.subject });
            q.object = this._useCanonicalId({ component: q.object });
            q.graph = this._useCanonicalId({ component: q.graph });
            normalized.push(NQuads.serializeQuad(q));
          }
          normalized.sort();
          return normalized.join("");
        }
        hashFirstDegreeQuads(id) {
          const nquads = [];
          const info = this.blankNodeInfo.get(id);
          const quads = info.quads;
          for (const quad of quads) {
            const copy = {
              subject: null,
              predicate: quad.predicate,
              object: null,
              graph: null
            };
            copy.subject = this.modifyFirstDegreeComponent(id, quad.subject, "subject");
            copy.object = this.modifyFirstDegreeComponent(id, quad.object, "object");
            copy.graph = this.modifyFirstDegreeComponent(id, quad.graph, "graph");
            nquads.push(NQuads.serializeQuad(copy));
          }
          nquads.sort();
          const md = new MessageDigest(this.hashAlgorithm);
          for (const nquad of nquads) {
            md.update(nquad);
          }
          info.hash = md.digest();
          return info.hash;
        }
        hashRelatedBlankNode(related, quad, issuer, position) {
          let id;
          if (this.canonicalIssuer.hasId(related)) {
            id = this.canonicalIssuer.getId(related);
          } else if (issuer.hasId(related)) {
            id = issuer.getId(related);
          } else {
            id = this.blankNodeInfo.get(related).hash;
          }
          const md = new MessageDigest(this.hashAlgorithm);
          md.update(position);
          if (position !== "g") {
            md.update(this.getRelatedPredicate(quad));
          }
          md.update(id);
          return md.digest();
        }
        hashNDegreeQuads(id, issuer) {
          const md = new MessageDigest(this.hashAlgorithm);
          const hashToRelated = this.createHashToRelated(id, issuer);
          const hashes = [...hashToRelated.keys()].sort();
          for (const hash of hashes) {
            md.update(hash);
            let chosenPath = "";
            let chosenIssuer;
            const permuter = new Permuter(hashToRelated.get(hash));
            while (permuter.hasNext()) {
              const permutation = permuter.next();
              let issuerCopy = issuer.clone();
              let path = "";
              const recursionList = [];
              let nextPermutation = false;
              for (const related of permutation) {
                if (this.canonicalIssuer.hasId(related)) {
                  path += this.canonicalIssuer.getId(related);
                } else {
                  if (!issuerCopy.hasId(related)) {
                    recursionList.push(related);
                  }
                  path += issuerCopy.getId(related);
                }
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              for (const related of recursionList) {
                const result = this.hashNDegreeQuads(related, issuerCopy);
                path += issuerCopy.getId(related);
                path += `<${result.hash}>`;
                issuerCopy = result.issuer;
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              if (chosenPath.length === 0 || path < chosenPath) {
                chosenPath = path;
                chosenIssuer = issuerCopy;
              }
            }
            md.update(chosenPath);
            issuer = chosenIssuer;
          }
          return { hash: md.digest(), issuer };
        }
        modifyFirstDegreeComponent(id, component) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          return {
            termType: "BlankNode",
            value: component.value === id ? "_:a" : "_:z"
          };
        }
        getRelatedPredicate(quad) {
          return `<${quad.predicate.value}>`;
        }
        createHashToRelated(id, issuer) {
          const hashToRelated = /* @__PURE__ */ new Map();
          const quads = this.blankNodeInfo.get(id).quads;
          for (const quad of quads) {
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.subject,
              position: "s",
              id,
              issuer,
              hashToRelated
            });
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.object,
              position: "o",
              id,
              issuer,
              hashToRelated
            });
            this._addRelatedBlankNodeHash({
              quad,
              component: quad.graph,
              position: "g",
              id,
              issuer,
              hashToRelated
            });
          }
          return hashToRelated;
        }
        _hashAndTrackBlankNode({ id, hashToBlankNodes }) {
          const hash = this.hashFirstDegreeQuads(id);
          const idList = hashToBlankNodes.get(hash);
          if (!idList) {
            hashToBlankNodes.set(hash, [id]);
          } else {
            idList.push(id);
          }
        }
        _addBlankNodeQuadInfo({ quad, component }) {
          if (component.termType !== "BlankNode") {
            return;
          }
          const id = component.value;
          const info = this.blankNodeInfo.get(id);
          if (info) {
            info.quads.add(quad);
          } else {
            this.blankNodeInfo.set(id, { quads: /* @__PURE__ */ new Set([quad]), hash: null });
          }
        }
        _addRelatedBlankNodeHash({ quad, component, position, id, issuer, hashToRelated }) {
          if (!(component.termType === "BlankNode" && component.value !== id)) {
            return;
          }
          const related = component.value;
          const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
          const entries = hashToRelated.get(hash);
          if (entries) {
            entries.push(related);
          } else {
            hashToRelated.set(hash, [related]);
          }
        }
        _useCanonicalId({ component }) {
          if (component.termType === "BlankNode" && !component.value.startsWith(this.canonicalIssuer.prefix)) {
            return {
              termType: "BlankNode",
              value: this.canonicalIssuer.getId(component.value)
            };
          }
          return component;
        }
      };
      function _stringHashCompare(a, b) {
        return a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URGNA2012Sync.js
  var require_URGNA2012Sync = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/URGNA2012Sync.js"(exports, module) {
      "use strict";
      var URDNA2015Sync = require_URDNA2015Sync();
      module.exports = class URDNA2012Sync extends URDNA2015Sync {
        constructor() {
          super();
          this.name = "URGNA2012";
          this.hashAlgorithm = "sha1";
        }
        modifyFirstDegreeComponent(id, component, key) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          if (key === "graph") {
            return {
              termType: "BlankNode",
              value: "_:g"
            };
          }
          return {
            termType: "BlankNode",
            value: component.value === id ? "_:a" : "_:z"
          };
        }
        getRelatedPredicate(quad) {
          return quad.predicate.value;
        }
        createHashToRelated(id, issuer) {
          const hashToRelated = /* @__PURE__ */ new Map();
          const quads = this.blankNodeInfo.get(id).quads;
          for (const quad of quads) {
            let position;
            let related;
            if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
              related = quad.subject.value;
              position = "p";
            } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
              related = quad.object.value;
              position = "r";
            } else {
              continue;
            }
            const hash = this.hashRelatedBlankNode(related, quad, issuer, position);
            const entries = hashToRelated.get(hash);
            if (entries) {
              entries.push(related);
            } else {
              hashToRelated.set(hash, [related]);
            }
          }
          return hashToRelated;
        }
      };
    }
  });

  // (disabled):rdf-canonize-native
  var require_rdf_canonize_native = __commonJS({
    "(disabled):rdf-canonize-native"() {
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/index.js
  var require_lib = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/lib/index.js"(exports, module) {
      "use strict";
      var URDNA2015 = require_URDNA2015();
      var URGNA2012 = require_URGNA2012();
      var URDNA2015Sync = require_URDNA2015Sync();
      var URGNA2012Sync = require_URGNA2012Sync();
      var rdfCanonizeNative;
      try {
        rdfCanonizeNative = require_rdf_canonize_native();
      } catch (e) {
      }
      var api = {};
      module.exports = api;
      api.NQuads = require_NQuads();
      api.IdentifierIssuer = require_IdentifierIssuer();
      api._rdfCanonizeNative = function(api2) {
        if (api2) {
          rdfCanonizeNative = api2;
        }
        return rdfCanonizeNative;
      };
      api.canonize = async function(dataset, options) {
        if (!Array.isArray(dataset)) {
          dataset = api.NQuads.legacyDatasetToQuads(dataset);
        }
        if (options.useNative) {
          if (!rdfCanonizeNative) {
            throw new Error("rdf-canonize-native not available");
          }
          return new Promise((resolve, reject) => rdfCanonizeNative.canonize(dataset, options, (err, canonical) => err ? reject(err) : resolve(canonical)));
        }
        if (options.algorithm === "URDNA2015") {
          return new URDNA2015(options).main(dataset);
        }
        if (options.algorithm === "URGNA2012") {
          return new URGNA2012(options).main(dataset);
        }
        if (!("algorithm" in options)) {
          throw new Error("No RDF Dataset Canonicalization algorithm specified.");
        }
        throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm);
      };
      api._canonizeSync = function(dataset, options) {
        if (!Array.isArray(dataset)) {
          dataset = api.NQuads.legacyDatasetToQuads(dataset);
        }
        if (options.useNative) {
          if (rdfCanonizeNative) {
            return rdfCanonizeNative.canonizeSync(dataset, options);
          }
          throw new Error("rdf-canonize-native not available");
        }
        if (options.algorithm === "URDNA2015") {
          return new URDNA2015Sync(options).main(dataset);
        }
        if (options.algorithm === "URGNA2012") {
          return new URGNA2012Sync(options).main(dataset);
        }
        if (!("algorithm" in options)) {
          throw new Error("No RDF Dataset Canonicalization algorithm specified.");
        }
        throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm);
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/rdf-canonize/index.js
  var require_rdf_canonize = __commonJS({
    "node_modules/jsonld-signatures/node_modules/rdf-canonize/index.js"(exports, module) {
      module.exports = require_lib();
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/types.js
  var require_types = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/types.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.isArray = Array.isArray;
      api.isBoolean = (v) => typeof v === "boolean" || Object.prototype.toString.call(v) === "[object Boolean]";
      api.isDouble = (v) => api.isNumber(v) && (String(v).indexOf(".") !== -1 || Math.abs(v) >= 1e21);
      api.isEmptyObject = (v) => api.isObject(v) && Object.keys(v).length === 0;
      api.isNumber = (v) => typeof v === "number" || Object.prototype.toString.call(v) === "[object Number]";
      api.isNumeric = (v) => !isNaN(parseFloat(v)) && isFinite(v);
      api.isObject = (v) => Object.prototype.toString.call(v) === "[object Object]";
      api.isString = (v) => typeof v === "string" || Object.prototype.toString.call(v) === "[object String]";
      api.isUndefined = (v) => typeof v === "undefined";
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/graphTypes.js
  var require_graphTypes = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/graphTypes.js"(exports, module) {
      "use strict";
      var types = require_types();
      var api = {};
      module.exports = api;
      api.isSubject = (v) => {
        if (types.isObject(v) && !("@value" in v || "@set" in v || "@list" in v)) {
          const keyCount = Object.keys(v).length;
          return keyCount > 1 || !("@id" in v);
        }
        return false;
      };
      api.isSubjectReference = (v) => types.isObject(v) && Object.keys(v).length === 1 && "@id" in v;
      api.isValue = (v) => types.isObject(v) && "@value" in v;
      api.isList = (v) => types.isObject(v) && "@list" in v;
      api.isGraph = (v) => {
        return types.isObject(v) && "@graph" in v && Object.keys(v).filter((key) => key !== "@id" && key !== "@index").length === 1;
      };
      api.isSimpleGraph = (v) => {
        return api.isGraph(v) && !("@id" in v);
      };
      api.isBlankNode = (v) => {
        if (types.isObject(v)) {
          if ("@id" in v) {
            return v["@id"].indexOf("_:") === 0;
          }
          return Object.keys(v).length === 0 || !("@value" in v || "@set" in v || "@list" in v);
        }
        return false;
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/JsonLdError.js
  var require_JsonLdError = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/JsonLdError.js"(exports, module) {
      "use strict";
      module.exports = class JsonLdError extends Error {
        constructor(message = "An unspecified JSON-LD error occurred.", name = "jsonld.Error", details = {}) {
          super(message);
          this.name = name;
          this.message = message;
          this.details = details;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/util.js
  var require_util2 = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/util.js"(exports, module) {
      "use strict";
      var graphTypes = require_graphTypes();
      var types = require_types();
      var IdentifierIssuer = require_rdf_canonize().IdentifierIssuer;
      var JsonLdError = require_JsonLdError();
      var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
      var REGEX_LINK_HEADER = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
      var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
      var DEFAULTS = {
        headers: {
          accept: "application/ld+json, application/json"
        }
      };
      var api = {};
      module.exports = api;
      api.IdentifierIssuer = IdentifierIssuer;
      api.clone = function(value) {
        if (value && typeof value === "object") {
          let rval;
          if (types.isArray(value)) {
            rval = [];
            for (let i = 0; i < value.length; ++i) {
              rval[i] = api.clone(value[i]);
            }
          } else if (value instanceof Map) {
            rval = /* @__PURE__ */ new Map();
            for (const [k, v] of value) {
              rval.set(k, api.clone(v));
            }
          } else if (value instanceof Set) {
            rval = /* @__PURE__ */ new Set();
            for (const v of value) {
              rval.add(api.clone(v));
            }
          } else if (types.isObject(value)) {
            rval = {};
            for (const key in value) {
              rval[key] = api.clone(value[key]);
            }
          } else {
            rval = value.toString();
          }
          return rval;
        }
        return value;
      };
      api.asArray = function(value) {
        return Array.isArray(value) ? value : [value];
      };
      api.buildHeaders = (headers = {}) => {
        const hasAccept = Object.keys(headers).some((h) => h.toLowerCase() === "accept");
        if (hasAccept) {
          throw new RangeError('Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.');
        }
        return Object.assign({ Accept: DEFAULTS.headers.accept }, headers);
      };
      api.parseLinkHeader = (header) => {
        const rval = {};
        const entries = header.match(REGEX_LINK_HEADERS);
        for (let i = 0; i < entries.length; ++i) {
          let match = entries[i].match(REGEX_LINK_HEADER);
          if (!match) {
            continue;
          }
          const result = { target: match[1] };
          const params = match[2];
          while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
            result[match[1]] = match[2] === void 0 ? match[3] : match[2];
          }
          const rel = result.rel || "";
          if (Array.isArray(rval[rel])) {
            rval[rel].push(result);
          } else if (rval.hasOwnProperty(rel)) {
            rval[rel] = [rval[rel], result];
          } else {
            rval[rel] = result;
          }
        }
        return rval;
      };
      api.validateTypeValue = (v, isFrame) => {
        if (types.isString(v)) {
          return;
        }
        if (types.isArray(v) && v.every((vv) => types.isString(vv))) {
          return;
        }
        if (isFrame && types.isObject(v)) {
          switch (Object.keys(v).length) {
            case 0:
              return;
            case 1:
              if ("@default" in v && api.asArray(v["@default"]).every((vv) => types.isString(vv))) {
                return;
              }
          }
        }
        throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, an empty object, or a default object.', "jsonld.SyntaxError", { code: "invalid type value", value: v });
      };
      api.hasProperty = (subject, property) => {
        if (subject.hasOwnProperty(property)) {
          const value = subject[property];
          return !types.isArray(value) || value.length > 0;
        }
        return false;
      };
      api.hasValue = (subject, property, value) => {
        if (api.hasProperty(subject, property)) {
          let val = subject[property];
          const isList = graphTypes.isList(val);
          if (types.isArray(val) || isList) {
            if (isList) {
              val = val["@list"];
            }
            for (let i = 0; i < val.length; ++i) {
              if (api.compareValues(value, val[i])) {
                return true;
              }
            }
          } else if (!types.isArray(value)) {
            return api.compareValues(value, val);
          }
        }
        return false;
      };
      api.addValue = (subject, property, value, options) => {
        options = options || {};
        if (!("propertyIsArray" in options)) {
          options.propertyIsArray = false;
        }
        if (!("valueIsArray" in options)) {
          options.valueIsArray = false;
        }
        if (!("allowDuplicate" in options)) {
          options.allowDuplicate = true;
        }
        if (!("prependValue" in options)) {
          options.prependValue = false;
        }
        if (options.valueIsArray) {
          subject[property] = value;
        } else if (types.isArray(value)) {
          if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
            subject[property] = [];
          }
          if (options.prependValue) {
            value = value.concat(subject[property]);
            subject[property] = [];
          }
          for (let i = 0; i < value.length; ++i) {
            api.addValue(subject, property, value[i], options);
          }
        } else if (subject.hasOwnProperty(property)) {
          const hasValue = !options.allowDuplicate && api.hasValue(subject, property, value);
          if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
            subject[property] = [subject[property]];
          }
          if (!hasValue) {
            if (options.prependValue) {
              subject[property].unshift(value);
            } else {
              subject[property].push(value);
            }
          }
        } else {
          subject[property] = options.propertyIsArray ? [value] : value;
        }
      };
      api.getValues = (subject, property) => [].concat(subject[property] || []);
      api.removeProperty = (subject, property) => {
        delete subject[property];
      };
      api.removeValue = (subject, property, value, options) => {
        options = options || {};
        if (!("propertyIsArray" in options)) {
          options.propertyIsArray = false;
        }
        const values = api.getValues(subject, property).filter((e) => !api.compareValues(e, value));
        if (values.length === 0) {
          api.removeProperty(subject, property);
        } else if (values.length === 1 && !options.propertyIsArray) {
          subject[property] = values[0];
        } else {
          subject[property] = values;
        }
      };
      api.relabelBlankNodes = (input, options) => {
        options = options || {};
        const issuer = options.issuer || new IdentifierIssuer("_:b");
        return _labelBlankNodes(issuer, input);
      };
      api.compareValues = (v1, v2) => {
        if (v1 === v2) {
          return true;
        }
        if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1["@value"] === v2["@value"] && v1["@type"] === v2["@type"] && v1["@language"] === v2["@language"] && v1["@index"] === v2["@index"]) {
          return true;
        }
        if (types.isObject(v1) && "@id" in v1 && types.isObject(v2) && "@id" in v2) {
          return v1["@id"] === v2["@id"];
        }
        return false;
      };
      api.compareShortestLeast = (a, b) => {
        if (a.length < b.length) {
          return -1;
        }
        if (b.length < a.length) {
          return 1;
        }
        if (a === b) {
          return 0;
        }
        return a < b ? -1 : 1;
      };
      function _labelBlankNodes(issuer, element) {
        if (types.isArray(element)) {
          for (let i = 0; i < element.length; ++i) {
            element[i] = _labelBlankNodes(issuer, element[i]);
          }
        } else if (graphTypes.isList(element)) {
          element["@list"] = _labelBlankNodes(issuer, element["@list"]);
        } else if (types.isObject(element)) {
          if (graphTypes.isBlankNode(element)) {
            element["@id"] = issuer.getId(element["@id"]);
          }
          const keys = Object.keys(element).sort();
          for (let ki = 0; ki < keys.length; ++ki) {
            const key = keys[ki];
            if (key !== "@id") {
              element[key] = _labelBlankNodes(issuer, element[key]);
            }
          }
        }
        return element;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/constants.js
  var require_constants3 = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/constants.js"(exports, module) {
      "use strict";
      var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      var XSD = "http://www.w3.org/2001/XMLSchema#";
      module.exports = {
        LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context",
        LINK_HEADER_CONTEXT: "http://www.w3.org/ns/json-ld#context",
        RDF,
        RDF_LIST: RDF + "List",
        RDF_FIRST: RDF + "first",
        RDF_REST: RDF + "rest",
        RDF_NIL: RDF + "nil",
        RDF_TYPE: RDF + "type",
        RDF_PLAIN_LITERAL: RDF + "PlainLiteral",
        RDF_XML_LITERAL: RDF + "XMLLiteral",
        RDF_JSON_LITERAL: RDF + "JSON",
        RDF_OBJECT: RDF + "object",
        RDF_LANGSTRING: RDF + "langString",
        XSD,
        XSD_BOOLEAN: XSD + "boolean",
        XSD_DOUBLE: XSD + "double",
        XSD_INTEGER: XSD + "integer",
        XSD_STRING: XSD + "string"
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/RequestQueue.js
  var require_RequestQueue = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/RequestQueue.js"(exports, module) {
      "use strict";
      module.exports = class RequestQueue {
        constructor() {
          this._requests = {};
        }
        wrapLoader(loader) {
          const self2 = this;
          self2._loader = loader;
          return function() {
            return self2.add.apply(self2, arguments);
          };
        }
        async add(url) {
          let promise = this._requests[url];
          if (promise) {
            return Promise.resolve(promise);
          }
          promise = this._requests[url] = this._loader(url);
          try {
            return await promise;
          } finally {
            delete this._requests[url];
          }
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/url.js
  var require_url = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/url.js"(exports, module) {
      "use strict";
      var types = require_types();
      var api = {};
      module.exports = api;
      api.parsers = {
        simple: {
          keys: [
            "href",
            "scheme",
            "authority",
            "path",
            "query",
            "fragment"
          ],
          regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
        },
        full: {
          keys: [
            "href",
            "protocol",
            "scheme",
            "authority",
            "auth",
            "user",
            "password",
            "hostname",
            "port",
            "path",
            "directory",
            "file",
            "query",
            "fragment"
          ],
          regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };
      api.parse = (str, parser) => {
        const parsed = {};
        const o = api.parsers[parser || "full"];
        const m = o.regex.exec(str);
        let i = o.keys.length;
        while (i--) {
          parsed[o.keys[i]] = m[i] === void 0 ? null : m[i];
        }
        if (parsed.scheme === "https" && parsed.port === "443" || parsed.scheme === "http" && parsed.port === "80") {
          parsed.href = parsed.href.replace(":" + parsed.port, "");
          parsed.authority = parsed.authority.replace(":" + parsed.port, "");
          parsed.port = null;
        }
        parsed.normalizedPath = api.removeDotSegments(parsed.path);
        return parsed;
      };
      api.prependBase = (base, iri) => {
        if (base === null) {
          return iri;
        }
        if (api.isAbsolute(iri)) {
          return iri;
        }
        if (!base || types.isString(base)) {
          base = api.parse(base || "");
        }
        const rel = api.parse(iri);
        const transform = {
          protocol: base.protocol || ""
        };
        if (rel.authority !== null) {
          transform.authority = rel.authority;
          transform.path = rel.path;
          transform.query = rel.query;
        } else {
          transform.authority = base.authority;
          if (rel.path === "") {
            transform.path = base.path;
            if (rel.query !== null) {
              transform.query = rel.query;
            } else {
              transform.query = base.query;
            }
          } else {
            if (rel.path.indexOf("/") === 0) {
              transform.path = rel.path;
            } else {
              let path = base.path;
              path = path.substr(0, path.lastIndexOf("/") + 1);
              if ((path.length > 0 || base.authority) && path.substr(-1) !== "/") {
                path += "/";
              }
              path += rel.path;
              transform.path = path;
            }
            transform.query = rel.query;
          }
        }
        if (rel.path !== "") {
          transform.path = api.removeDotSegments(transform.path);
        }
        let rval = transform.protocol;
        if (transform.authority !== null) {
          rval += "//" + transform.authority;
        }
        rval += transform.path;
        if (transform.query !== null) {
          rval += "?" + transform.query;
        }
        if (rel.fragment !== null) {
          rval += "#" + rel.fragment;
        }
        if (rval === "") {
          rval = "./";
        }
        return rval;
      };
      api.removeBase = (base, iri) => {
        if (base === null) {
          return iri;
        }
        if (!base || types.isString(base)) {
          base = api.parse(base || "");
        }
        let root = "";
        if (base.href !== "") {
          root += (base.protocol || "") + "//" + (base.authority || "");
        } else if (iri.indexOf("//")) {
          root += "//";
        }
        if (iri.indexOf(root) !== 0) {
          return iri;
        }
        const rel = api.parse(iri.substr(root.length));
        const baseSegments = base.normalizedPath.split("/");
        const iriSegments = rel.normalizedPath.split("/");
        const last = rel.fragment || rel.query ? 0 : 1;
        while (baseSegments.length > 0 && iriSegments.length > last) {
          if (baseSegments[0] !== iriSegments[0]) {
            break;
          }
          baseSegments.shift();
          iriSegments.shift();
        }
        let rval = "";
        if (baseSegments.length > 0) {
          baseSegments.pop();
          for (let i = 0; i < baseSegments.length; ++i) {
            rval += "../";
          }
        }
        rval += iriSegments.join("/");
        if (rel.query !== null) {
          rval += "?" + rel.query;
        }
        if (rel.fragment !== null) {
          rval += "#" + rel.fragment;
        }
        if (rval === "") {
          rval = "./";
        }
        return rval;
      };
      api.removeDotSegments = (path) => {
        if (path.length === 0) {
          return "";
        }
        const input = path.split("/");
        const output = [];
        while (input.length > 0) {
          const next = input.shift();
          const done = input.length === 0;
          if (next === ".") {
            if (done) {
              output.push("");
            }
            continue;
          }
          if (next === "..") {
            output.pop();
            if (done) {
              output.push("");
            }
            continue;
          }
          output.push(next);
        }
        if (path[0] === "/" && output.length > 0 && output[0] !== "") {
          output.unshift("");
        }
        if (output.length === 1 && output[0] === "") {
          return "/";
        }
        return output.join("/");
      };
      var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\s]*$/;
      api.isAbsolute = (v) => types.isString(v) && isAbsoluteRegex.test(v);
      api.isRelative = (v) => types.isString(v);
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/documentLoaders/xhr.js
  var require_xhr = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/documentLoaders/xhr.js"(exports, module) {
      "use strict";
      var { parseLinkHeader, buildHeaders } = require_util2();
      var { LINK_HEADER_CONTEXT } = require_constants3();
      var JsonLdError = require_JsonLdError();
      var RequestQueue = require_RequestQueue();
      var { prependBase } = require_url();
      var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
      module.exports = ({
        secure,
        headers = {},
        xhr
      } = { headers: {} }) => {
        headers = buildHeaders(headers);
        const queue = new RequestQueue();
        return queue.wrapLoader(loader);
        async function loader(url) {
          if (url.indexOf("http:") !== 0 && url.indexOf("https:") !== 0) {
            throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are supported.', "jsonld.InvalidUrl", { code: "loading document failed", url });
          }
          if (secure && url.indexOf("https") !== 0) {
            throw new JsonLdError(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`, "jsonld.InvalidUrl", { code: "loading document failed", url });
          }
          let req;
          try {
            req = await _get(xhr, url, headers);
          } catch (e) {
            throw new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", { code: "loading document failed", url, cause: e });
          }
          if (req.status >= 400) {
            throw new JsonLdError("URL could not be dereferenced: " + req.statusText, "jsonld.LoadDocumentError", {
              code: "loading document failed",
              url,
              httpStatusCode: req.status
            });
          }
          let doc = { contextUrl: null, documentUrl: url, document: req.response };
          let alternate = null;
          const contentType = req.getResponseHeader("Content-Type");
          let linkHeader;
          if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
            linkHeader = req.getResponseHeader("Link");
          }
          if (linkHeader && contentType !== "application/ld+json") {
            const linkHeaders = parseLinkHeader(linkHeader);
            const linkedContext = linkHeaders[LINK_HEADER_CONTEXT];
            if (Array.isArray(linkedContext)) {
              throw new JsonLdError("URL could not be dereferenced, it has more than one associated HTTP Link Header.", "jsonld.InvalidUrl", { code: "multiple context link headers", url });
            }
            if (linkedContext) {
              doc.contextUrl = linkedContext.target;
            }
            alternate = linkHeaders.alternate;
            if (alternate && alternate.type == "application/ld+json" && !(contentType || "").match(/^application\/(\w*\+)?json$/)) {
              doc = await loader(prependBase(url, alternate.target));
            }
          }
          return doc;
        }
      };
      function _get(xhr, url, headers) {
        xhr = xhr || XMLHttpRequest;
        const req = new xhr();
        return new Promise((resolve, reject) => {
          req.onload = () => resolve(req);
          req.onerror = (err) => reject(err);
          req.open("GET", url, true);
          for (const k in headers) {
            req.setRequestHeader(k, headers[k]);
          }
          req.send();
        });
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/platform-browser.js
  var require_platform_browser = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/platform-browser.js"(exports, module) {
      "use strict";
      var xhrLoader = require_xhr();
      var api = {};
      module.exports = api;
      api.setupDocumentLoaders = function(jsonld) {
        if (typeof XMLHttpRequest !== "undefined") {
          jsonld.documentLoaders.xhr = xhrLoader;
          jsonld.useDocumentLoader("xhr");
        }
      };
      api.setupGlobals = function(jsonld) {
        if (typeof globalThis.JsonLdProcessor === "undefined") {
          Object.defineProperty(globalThis, "JsonLdProcessor", {
            writable: true,
            enumerable: false,
            configurable: true,
            value: jsonld.JsonLdProcessor
          });
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/yallist/iterator.js
  var require_iterator = __commonJS({
    "node_modules/jsonld-signatures/node_modules/yallist/iterator.js"(exports, module) {
      "use strict";
      module.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/yallist/yallist.js
  var require_yallist = __commonJS({
    "node_modules/jsonld-signatures/node_modules/yallist/yallist.js"(exports, module) {
      "use strict";
      module.exports = Yallist;
      Yallist.Node = Node2;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self2.push(arguments[i]);
          }
        }
        return self2;
      }
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.sliceReverse = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 0; i < nodes.length; i++) {
          walker = insert(this, walker, nodes[i]);
        }
        return ret;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node2(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node2(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node2(value, prev, next, list) {
        if (!(this instanceof Node2)) {
          return new Node2(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        require_iterator()(Yallist);
      } catch (er) {
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/lru-cache/index.js
  var require_lru_cache = __commonJS({
    "node_modules/jsonld-signatures/node_modules/lru-cache/index.js"(exports, module) {
      "use strict";
      var Yallist = require_yallist();
      var MAX = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = () => 1;
      var LRUCache = class {
        constructor(options) {
          if (typeof options === "number")
            options = { max: options };
          if (!options)
            options = {};
          if (options.max && (typeof options.max !== "number" || options.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max = this[MAX] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      };
      var get = (self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      var isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      var trim = (self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      var del = (self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      };
      var Entry = class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      };
      var forEachStep = (self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      module.exports = LRUCache;
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/ResolvedContext.js
  var require_ResolvedContext = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/ResolvedContext.js"(exports, module) {
      "use strict";
      var LRU = require_lru_cache();
      var MAX_ACTIVE_CONTEXTS = 10;
      module.exports = class ResolvedContext {
        constructor({ document: document2 }) {
          this.document = document2;
          this.cache = new LRU({ max: MAX_ACTIVE_CONTEXTS });
        }
        getProcessed(activeCtx) {
          return this.cache.get(activeCtx);
        }
        setProcessed(activeCtx, processedCtx) {
          this.cache.set(activeCtx, processedCtx);
        }
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/ContextResolver.js
  var require_ContextResolver = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/ContextResolver.js"(exports, module) {
      "use strict";
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString
      } = require_types();
      var {
        asArray: _asArray
      } = require_util2();
      var { prependBase } = require_url();
      var JsonLdError = require_JsonLdError();
      var ResolvedContext = require_ResolvedContext();
      var MAX_CONTEXT_URLS = 10;
      module.exports = class ContextResolver {
        constructor({ sharedCache }) {
          this.perOpCache = /* @__PURE__ */ new Map();
          this.sharedCache = sharedCache;
        }
        async resolve({
          activeCtx,
          context,
          documentLoader,
          base,
          cycles = /* @__PURE__ */ new Set()
        }) {
          if (context && _isObject(context) && context["@context"]) {
            context = context["@context"];
          }
          context = _asArray(context);
          const allResolved = [];
          for (const ctx of context) {
            if (_isString(ctx)) {
              let resolved2 = this._get(ctx);
              if (!resolved2) {
                resolved2 = await this._resolveRemoteContext({ activeCtx, url: ctx, documentLoader, base, cycles });
              }
              if (_isArray(resolved2)) {
                allResolved.push(...resolved2);
              } else {
                allResolved.push(resolved2);
              }
              continue;
            }
            if (ctx === null) {
              allResolved.push(new ResolvedContext({ document: null }));
              continue;
            }
            if (!_isObject(ctx)) {
              _throwInvalidLocalContext(context);
            }
            const key = JSON.stringify(ctx);
            let resolved = this._get(key);
            if (!resolved) {
              resolved = new ResolvedContext({ document: ctx });
              this._cacheResolvedContext({ key, resolved, tag: "static" });
            }
            allResolved.push(resolved);
          }
          return allResolved;
        }
        _get(key) {
          let resolved = this.perOpCache.get(key);
          if (!resolved) {
            const tagMap = this.sharedCache.get(key);
            if (tagMap) {
              resolved = tagMap.get("static");
              if (resolved) {
                this.perOpCache.set(key, resolved);
              }
            }
          }
          return resolved;
        }
        _cacheResolvedContext({ key, resolved, tag }) {
          this.perOpCache.set(key, resolved);
          if (tag !== void 0) {
            let tagMap = this.sharedCache.get(key);
            if (!tagMap) {
              tagMap = /* @__PURE__ */ new Map();
              this.sharedCache.set(key, tagMap);
            }
            tagMap.set(tag, resolved);
          }
          return resolved;
        }
        async _resolveRemoteContext({ activeCtx, url, documentLoader, base, cycles }) {
          url = prependBase(base, url);
          const { context, remoteDoc } = await this._fetchContext({ activeCtx, url, documentLoader, cycles });
          base = remoteDoc.documentUrl || url;
          _resolveContextUrls({ context, base });
          const resolved = await this.resolve({ activeCtx, context, documentLoader, base, cycles });
          this._cacheResolvedContext({ key: url, resolved, tag: remoteDoc.tag });
          return resolved;
        }
        async _fetchContext({ activeCtx, url, documentLoader, cycles }) {
          if (cycles.size > MAX_CONTEXT_URLS) {
            throw new JsonLdError("Maximum number of @context URLs exceeded.", "jsonld.ContextUrlError", {
              code: activeCtx.processingMode === "json-ld-1.0" ? "loading remote context failed" : "context overflow",
              max: MAX_CONTEXT_URLS
            });
          }
          if (cycles.has(url)) {
            throw new JsonLdError("Cyclical @context URLs detected.", "jsonld.ContextUrlError", {
              code: activeCtx.processingMode === "json-ld-1.0" ? "recursive context inclusion" : "context overflow",
              url
            });
          }
          cycles.add(url);
          let context;
          let remoteDoc;
          try {
            remoteDoc = await documentLoader(url);
            context = remoteDoc.document || null;
            if (_isString(context)) {
              context = JSON.parse(context);
            }
          } catch (e) {
            throw new JsonLdError("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.", "jsonld.InvalidUrl", { code: "loading remote context failed", url, cause: e });
          }
          if (!_isObject(context)) {
            throw new JsonLdError("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.", "jsonld.InvalidUrl", { code: "invalid remote context", url });
          }
          if (!("@context" in context)) {
            context = { "@context": {} };
          } else {
            context = { "@context": context["@context"] };
          }
          if (remoteDoc.contextUrl) {
            if (!_isArray(context["@context"])) {
              context["@context"] = [context["@context"]];
            }
            context["@context"].push(remoteDoc.contextUrl);
          }
          return { context, remoteDoc };
        }
      };
      function _throwInvalidLocalContext(ctx) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", {
          code: "invalid local context",
          context: ctx
        });
      }
      function _resolveContextUrls({ context, base }) {
        if (!context) {
          return;
        }
        const ctx = context["@context"];
        if (_isString(ctx)) {
          context["@context"] = prependBase(base, ctx);
          return;
        }
        if (_isArray(ctx)) {
          for (let i = 0; i < ctx.length; ++i) {
            const element = ctx[i];
            if (_isString(element)) {
              ctx[i] = prependBase(base, element);
              continue;
            }
            if (_isObject(element)) {
              _resolveContextUrls({ context: { "@context": element }, base });
            }
          }
          return;
        }
        if (!_isObject(ctx)) {
          return;
        }
        for (const term in ctx) {
          _resolveContextUrls({ context: ctx[term], base });
        }
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/NQuads.js
  var require_NQuads2 = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/NQuads.js"(exports, module) {
      "use strict";
      module.exports = require_rdf_canonize().NQuads;
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/context.js
  var require_context = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/context.js"(exports, module) {
      "use strict";
      var util = require_util2();
      var JsonLdError = require_JsonLdError();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString,
        isUndefined: _isUndefined
      } = require_types();
      var {
        isAbsolute: _isAbsoluteIri,
        isRelative: _isRelativeIri,
        prependBase
      } = require_url();
      var {
        asArray: _asArray,
        compareShortestLeast: _compareShortestLeast
      } = require_util2();
      var INITIAL_CONTEXT_CACHE = /* @__PURE__ */ new Map();
      var INITIAL_CONTEXT_CACHE_MAX_SIZE = 1e4;
      var KEYWORD_PATTERN = /^@[a-zA-Z]+$/;
      var api = {};
      module.exports = api;
      api.process = async ({
        activeCtx,
        localCtx,
        options,
        propagate = true,
        overrideProtected = false,
        cycles = /* @__PURE__ */ new Set()
      }) => {
        if (_isObject(localCtx) && "@context" in localCtx && _isArray(localCtx["@context"])) {
          localCtx = localCtx["@context"];
        }
        const ctxs = _asArray(localCtx);
        if (ctxs.length === 0) {
          return activeCtx;
        }
        const resolved = await options.contextResolver.resolve({
          activeCtx,
          context: localCtx,
          documentLoader: options.documentLoader,
          base: options.base
        });
        if (_isObject(resolved[0].document) && typeof resolved[0].document["@propagate"] === "boolean") {
          propagate = resolved[0].document["@propagate"];
        }
        let rval = activeCtx;
        if (!propagate && !rval.previousContext) {
          rval = rval.clone();
          rval.previousContext = activeCtx;
        }
        for (const resolvedContext of resolved) {
          let { document: ctx } = resolvedContext;
          activeCtx = rval;
          if (ctx === null) {
            if (!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {
              const protectedMode = options && options.protectedMode || "error";
              if (protectedMode === "error") {
                throw new JsonLdError("Tried to nullify a context with protected terms outside of a term definition.", "jsonld.SyntaxError", { code: "invalid context nullification" });
              } else if (protectedMode === "warn") {
                console.warn("WARNING: invalid context nullification");
                const processed2 = resolvedContext.getProcessed(activeCtx);
                if (processed2) {
                  rval = activeCtx = processed2;
                  continue;
                }
                const oldActiveCtx = activeCtx;
                rval = activeCtx = api.getInitialContext(options).clone();
                for (const [term, _protected] of Object.entries(oldActiveCtx.protected)) {
                  if (_protected) {
                    activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);
                  }
                }
                activeCtx.protected = util.clone(oldActiveCtx.protected);
                resolvedContext.setProcessed(oldActiveCtx, rval);
                continue;
              }
              throw new JsonLdError("Invalid protectedMode.", "jsonld.SyntaxError", { code: "invalid protected mode", context: localCtx, protectedMode });
            }
            rval = activeCtx = api.getInitialContext(options).clone();
            continue;
          }
          const processed = resolvedContext.getProcessed(activeCtx);
          if (processed) {
            rval = activeCtx = processed;
            continue;
          }
          if (_isObject(ctx) && "@context" in ctx) {
            ctx = ctx["@context"];
          }
          if (!_isObject(ctx)) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", { code: "invalid local context", context: ctx });
          }
          rval = rval.clone();
          const defined = /* @__PURE__ */ new Map();
          if ("@version" in ctx) {
            if (ctx["@version"] !== 1.1) {
              throw new JsonLdError("Unsupported JSON-LD version: " + ctx["@version"], "jsonld.UnsupportedVersion", { code: "invalid @version value", context: ctx });
            }
            if (activeCtx.processingMode && activeCtx.processingMode === "json-ld-1.0") {
              throw new JsonLdError("@version: " + ctx["@version"] + " not compatible with " + activeCtx.processingMode, "jsonld.ProcessingModeConflict", { code: "processing mode conflict", context: ctx });
            }
            rval.processingMode = "json-ld-1.1";
            rval["@version"] = ctx["@version"];
            defined.set("@version", true);
          }
          rval.processingMode = rval.processingMode || activeCtx.processingMode;
          if ("@base" in ctx) {
            let base = ctx["@base"];
            if (base === null || _isAbsoluteIri(base)) {
            } else if (_isRelativeIri(base)) {
              base = prependBase(rval["@base"], base);
            } else {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.', "jsonld.SyntaxError", { code: "invalid base IRI", context: ctx });
            }
            rval["@base"] = base;
            defined.set("@base", true);
          }
          if ("@vocab" in ctx) {
            const value = ctx["@vocab"];
            if (value === null) {
              delete rval["@vocab"];
            } else if (!_isString(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.', "jsonld.SyntaxError", { code: "invalid vocab mapping", context: ctx });
            } else if (!_isAbsoluteIri(value) && api.processingMode(rval, 1)) {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.', "jsonld.SyntaxError", { code: "invalid vocab mapping", context: ctx });
            } else {
              rval["@vocab"] = _expandIri(rval, value, { vocab: true, base: true }, void 0, void 0, options);
            }
            defined.set("@vocab", true);
          }
          if ("@language" in ctx) {
            const value = ctx["@language"];
            if (value === null) {
              delete rval["@language"];
            } else if (!_isString(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.', "jsonld.SyntaxError", { code: "invalid default language", context: ctx });
            } else {
              rval["@language"] = value.toLowerCase();
            }
            defined.set("@language", true);
          }
          if ("@direction" in ctx) {
            const value = ctx["@direction"];
            if (activeCtx.processingMode === "json-ld-1.0") {
              throw new JsonLdError("Invalid JSON-LD syntax; @direction not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context member", context: ctx });
            }
            if (value === null) {
              delete rval["@direction"];
            } else if (value !== "ltr" && value !== "rtl") {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@direction" in a @context must be null, "ltr", or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", context: ctx });
            } else {
              rval["@direction"] = value;
            }
            defined.set("@direction", true);
          }
          if ("@propagate" in ctx) {
            const value = ctx["@propagate"];
            if (activeCtx.processingMode === "json-ld-1.0") {
              throw new JsonLdError("Invalid JSON-LD syntax; @propagate not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context entry", context: ctx });
            }
            if (typeof value !== "boolean") {
              throw new JsonLdError("Invalid JSON-LD syntax; @propagate value must be a boolean.", "jsonld.SyntaxError", { code: "invalid @propagate value", context: localCtx });
            }
            defined.set("@propagate", true);
          }
          if ("@import" in ctx) {
            const value = ctx["@import"];
            if (activeCtx.processingMode === "json-ld-1.0") {
              throw new JsonLdError("Invalid JSON-LD syntax; @import not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context entry", context: ctx });
            }
            if (!_isString(value)) {
              throw new JsonLdError("Invalid JSON-LD syntax; @import must be a string.", "jsonld.SyntaxError", { code: "invalid @import value", context: localCtx });
            }
            const resolvedImport = await options.contextResolver.resolve({
              activeCtx,
              context: value,
              documentLoader: options.documentLoader,
              base: options.base
            });
            if (resolvedImport.length !== 1) {
              throw new JsonLdError("Invalid JSON-LD syntax; @import must reference a single context.", "jsonld.SyntaxError", { code: "invalid remote context", context: localCtx });
            }
            const processedImport = resolvedImport[0].getProcessed(activeCtx);
            if (processedImport) {
              ctx = processedImport;
            } else {
              const importCtx = resolvedImport[0].document;
              if ("@import" in importCtx) {
                throw new JsonLdError("Invalid JSON-LD syntax: imported context must not include @import.", "jsonld.SyntaxError", { code: "invalid context entry", context: localCtx });
              }
              for (const key in importCtx) {
                if (!ctx.hasOwnProperty(key)) {
                  ctx[key] = importCtx[key];
                }
              }
              resolvedImport[0].setProcessed(activeCtx, ctx);
            }
            defined.set("@import", true);
          }
          defined.set("@protected", ctx["@protected"] || false);
          for (const key in ctx) {
            api.createTermDefinition({
              activeCtx: rval,
              localCtx: ctx,
              term: key,
              defined,
              options,
              overrideProtected
            });
            if (_isObject(ctx[key]) && "@context" in ctx[key]) {
              const keyCtx = ctx[key]["@context"];
              let process2 = true;
              if (_isString(keyCtx)) {
                const url = prependBase(options.base, keyCtx);
                if (cycles.has(url)) {
                  process2 = false;
                } else {
                  cycles.add(url);
                }
              }
              if (process2) {
                try {
                  await api.process({
                    activeCtx: rval.clone(),
                    localCtx: ctx[key]["@context"],
                    overrideProtected: true,
                    options,
                    cycles
                  });
                } catch (e) {
                  throw new JsonLdError("Invalid JSON-LD syntax; invalid scoped context.", "jsonld.SyntaxError", {
                    code: "invalid scoped context",
                    context: ctx[key]["@context"],
                    term: key
                  });
                }
              }
            }
          }
          resolvedContext.setProcessed(activeCtx, rval);
        }
        return rval;
      };
      api.createTermDefinition = ({
        activeCtx,
        localCtx,
        term,
        defined,
        options,
        overrideProtected = false
      }) => {
        if (defined.has(term)) {
          if (defined.get(term)) {
            return;
          }
          throw new JsonLdError("Cyclical context definition detected.", "jsonld.CyclicalContext", { code: "cyclic IRI mapping", context: localCtx, term });
        }
        defined.set(term, false);
        let value;
        if (localCtx.hasOwnProperty(term)) {
          value = localCtx[term];
        }
        if (term === "@type" && _isObject(value) && (value["@container"] || "@set") === "@set" && api.processingMode(activeCtx, 1.1)) {
          const validKeys2 = ["@container", "@id", "@protected"];
          const keys = Object.keys(value);
          if (keys.length === 0 || keys.some((k) => !validKeys2.includes(k))) {
            throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: localCtx, term });
          }
        } else if (api.isKeyword(term)) {
          throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: localCtx, term });
        } else if (term.match(KEYWORD_PATTERN)) {
          console.warn('WARNING: terms beginning with "@" are reserved for future use and ignored', { term });
          return;
        } else if (term === "") {
          throw new JsonLdError("Invalid JSON-LD syntax; a term cannot be an empty string.", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
        }
        const previousMapping = activeCtx.mappings.get(term);
        if (activeCtx.mappings.has(term)) {
          activeCtx.mappings.delete(term);
        }
        let simpleTerm = false;
        if (_isString(value) || value === null) {
          simpleTerm = true;
          value = { "@id": value };
        }
        if (!_isObject(value)) {
          throw new JsonLdError("Invalid JSON-LD syntax; @context term values must be strings or objects.", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
        }
        const mapping = {};
        activeCtx.mappings.set(term, mapping);
        mapping.reverse = false;
        const validKeys = ["@container", "@id", "@language", "@reverse", "@type"];
        if (api.processingMode(activeCtx, 1.1)) {
          validKeys.push("@context", "@direction", "@index", "@nest", "@prefix", "@protected");
        }
        for (const kw in value) {
          if (!validKeys.includes(kw)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a term definition must not contain " + kw, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
        }
        const colon = term.indexOf(":");
        mapping._termHasColon = colon > 0;
        if ("@reverse" in value) {
          if ("@id" in value) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
          }
          if ("@nest" in value) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
          }
          const reverse = value["@reverse"];
          if (!_isString(reverse)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
          if (!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {
            console.warn('WARNING: values beginning with "@" are reserved for future use and ignored', { reverse });
            if (previousMapping) {
              activeCtx.mappings.set(term, previousMapping);
            } else {
              activeCtx.mappings.delete(term);
            }
            return;
          }
          const id2 = _expandIri(activeCtx, reverse, { vocab: true, base: false }, localCtx, defined, options);
          if (!_isAbsoluteIri(id2)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
          mapping["@id"] = id2;
          mapping.reverse = true;
        } else if ("@id" in value) {
          let id2 = value["@id"];
          if (id2 && !_isString(id2)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
          if (id2 === null) {
            mapping["@id"] = null;
          } else if (!api.isKeyword(id2) && id2.match(KEYWORD_PATTERN)) {
            console.warn('WARNING: values beginning with "@" are reserved for future use and ignored', { id: id2 });
            if (previousMapping) {
              activeCtx.mappings.set(term, previousMapping);
            } else {
              activeCtx.mappings.delete(term);
            }
            return;
          } else if (id2 !== term) {
            id2 = _expandIri(activeCtx, id2, { vocab: true, base: false }, localCtx, defined, options);
            if (!_isAbsoluteIri(id2) && !api.isKeyword(id2)) {
              throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
            }
            if (term.match(/(?::[^:])|\//)) {
              const termDefined = new Map(defined).set(term, true);
              const termIri = _expandIri(activeCtx, term, { vocab: true, base: false }, localCtx, termDefined, options);
              if (termIri !== id2) {
                throw new JsonLdError("Invalid JSON-LD syntax; term in form of IRI must expand to definition.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
              }
            }
            mapping["@id"] = id2;
            mapping._prefix = simpleTerm && !mapping._termHasColon && id2.match(/[:\/\?#\[\]@]$/);
          }
        }
        if (!("@id" in mapping)) {
          if (mapping._termHasColon) {
            const prefix = term.substr(0, colon);
            if (localCtx.hasOwnProperty(prefix)) {
              api.createTermDefinition({
                activeCtx,
                localCtx,
                term: prefix,
                defined,
                options
              });
            }
            if (activeCtx.mappings.has(prefix)) {
              const suffix = term.substr(colon + 1);
              mapping["@id"] = activeCtx.mappings.get(prefix)["@id"] + suffix;
            } else {
              mapping["@id"] = term;
            }
          } else if (term === "@type") {
            mapping["@id"] = term;
          } else {
            if (!("@vocab" in activeCtx)) {
              throw new JsonLdError("Invalid JSON-LD syntax; @context terms must define an @id.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx, term });
            }
            mapping["@id"] = activeCtx["@vocab"] + term;
          }
        }
        if (value["@protected"] === true || defined.get("@protected") === true && value["@protected"] !== false) {
          activeCtx.protected[term] = true;
          mapping.protected = true;
        }
        defined.set(term, true);
        if ("@type" in value) {
          let type = value["@type"];
          if (!_isString(type)) {
            throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be a string.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
          }
          if (type === "@json" || type === "@none") {
            if (api.processingMode(activeCtx, 1)) {
              throw new JsonLdError(`Invalid JSON-LD syntax; an @context @type value must not be "${type}" in JSON-LD 1.0 mode.`, "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
            }
          } else if (type !== "@id" && type !== "@vocab") {
            type = _expandIri(activeCtx, type, { vocab: true, base: false }, localCtx, defined, options);
            if (!_isAbsoluteIri(type)) {
              throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
            }
            if (type.indexOf("_:") === 0) {
              throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
            }
          }
          mapping["@type"] = type;
        }
        if ("@container" in value) {
          const container = _isString(value["@container"]) ? [value["@container"]] : value["@container"] || [];
          const validContainers = ["@list", "@set", "@index", "@language"];
          let isValid = true;
          const hasSet = container.includes("@set");
          if (api.processingMode(activeCtx, 1.1)) {
            validContainers.push("@graph", "@id", "@type");
            if (container.includes("@list")) {
              if (container.length !== 1) {
                throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @list must have no other values", "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
              }
            } else if (container.includes("@graph")) {
              if (container.some((key) => key !== "@graph" && key !== "@id" && key !== "@index" && key !== "@set")) {
                throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set", "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
              }
            } else {
              isValid &= container.length <= (hasSet ? 2 : 1);
            }
            if (container.includes("@type")) {
              mapping["@type"] = mapping["@type"] || "@id";
              if (!["@id", "@vocab"].includes(mapping["@type"])) {
                throw new JsonLdError("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
              }
            }
          } else {
            isValid &= !_isArray(value["@container"]);
            isValid &= container.length <= 1;
          }
          isValid &= container.every((c) => validContainers.includes(c));
          isValid &= !(hasSet && container.includes("@list"));
          if (!isValid) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @container value must be one of the following: " + validContainers.join(", "), "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
          }
          if (mapping.reverse && !container.every((c) => ["@index", "@set"].includes(c))) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
          }
          mapping["@container"] = container;
        }
        if ("@index" in value) {
          if (!("@container" in value) || !mapping["@container"].includes("@index")) {
            throw new JsonLdError(`Invalid JSON-LD syntax; @index without @index in @container: "${value["@index"]}" on term "${term}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          if (!_isString(value["@index"]) || value["@index"].indexOf("@") === 0) {
            throw new JsonLdError(`Invalid JSON-LD syntax; @index must expand to an IRI: "${value["@index"]}" on term "${term}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          mapping["@index"] = value["@index"];
        }
        if ("@context" in value) {
          mapping["@context"] = value["@context"];
        }
        if ("@language" in value && !("@type" in value)) {
          let language = value["@language"];
          if (language !== null && !_isString(language)) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @language value must be a string or null.", "jsonld.SyntaxError", { code: "invalid language mapping", context: localCtx });
          }
          if (language !== null) {
            language = language.toLowerCase();
          }
          mapping["@language"] = language;
        }
        if ("@prefix" in value) {
          if (term.match(/:|\//)) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          if (api.isKeyword(mapping["@id"])) {
            throw new JsonLdError("Invalid JSON-LD syntax; keywords may not be used as prefixes", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          if (typeof value["@prefix"] === "boolean") {
            mapping._prefix = value["@prefix"] === true;
          } else {
            throw new JsonLdError("Invalid JSON-LD syntax; @context value for @prefix must be boolean", "jsonld.SyntaxError", { code: "invalid @prefix value", context: localCtx });
          }
        }
        if ("@direction" in value) {
          const direction = value["@direction"];
          if (direction !== null && direction !== "ltr" && direction !== "rtl") {
            throw new JsonLdError('Invalid JSON-LD syntax; @direction value must be null, "ltr", or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", context: localCtx });
          }
          mapping["@direction"] = direction;
        }
        if ("@nest" in value) {
          const nest = value["@nest"];
          if (!_isString(nest) || nest !== "@nest" && nest.indexOf("@") === 0) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.", "jsonld.SyntaxError", { code: "invalid @nest value", context: localCtx });
          }
          mapping["@nest"] = nest;
        }
        const id = mapping["@id"];
        if (id === "@context" || id === "@preserve") {
          throw new JsonLdError("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.", "jsonld.SyntaxError", { code: "invalid keyword alias", context: localCtx });
        }
        if (previousMapping && previousMapping.protected && !overrideProtected) {
          activeCtx.protected[term] = true;
          mapping.protected = true;
          if (!_deepCompare(previousMapping, mapping)) {
            const protectedMode = options && options.protectedMode || "error";
            if (protectedMode === "error") {
              throw new JsonLdError(`Invalid JSON-LD syntax; tried to redefine "${term}" which is a protected term.`, "jsonld.SyntaxError", { code: "protected term redefinition", context: localCtx, term });
            } else if (protectedMode === "warn") {
              console.warn("WARNING: protected term redefinition", { term });
              return;
            }
            throw new JsonLdError("Invalid protectedMode.", "jsonld.SyntaxError", {
              code: "invalid protected mode",
              context: localCtx,
              term,
              protectedMode
            });
          }
        }
      };
      api.expandIri = (activeCtx, value, relativeTo, options) => {
        return _expandIri(activeCtx, value, relativeTo, void 0, void 0, options);
      };
      function _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {
        if (value === null || !_isString(value) || api.isKeyword(value)) {
          return value;
        }
        if (value.match(KEYWORD_PATTERN)) {
          return null;
        }
        if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
          api.createTermDefinition({
            activeCtx,
            localCtx,
            term: value,
            defined,
            options
          });
        }
        relativeTo = relativeTo || {};
        if (relativeTo.vocab) {
          const mapping = activeCtx.mappings.get(value);
          if (mapping === null) {
            return null;
          }
          if (_isObject(mapping) && "@id" in mapping) {
            return mapping["@id"];
          }
        }
        const colon = value.indexOf(":");
        if (colon > 0) {
          const prefix = value.substr(0, colon);
          const suffix = value.substr(colon + 1);
          if (prefix === "_" || suffix.indexOf("//") === 0) {
            return value;
          }
          if (localCtx && localCtx.hasOwnProperty(prefix)) {
            api.createTermDefinition({
              activeCtx,
              localCtx,
              term: prefix,
              defined,
              options
            });
          }
          const mapping = activeCtx.mappings.get(prefix);
          if (mapping && mapping._prefix) {
            return mapping["@id"] + suffix;
          }
          if (_isAbsoluteIri(value)) {
            return value;
          }
        }
        if (relativeTo.vocab && "@vocab" in activeCtx) {
          return activeCtx["@vocab"] + value;
        }
        if (relativeTo.base && "@base" in activeCtx) {
          if (activeCtx["@base"]) {
            return prependBase(prependBase(options.base, activeCtx["@base"]), value);
          }
        } else if (relativeTo.base) {
          return prependBase(options.base, value);
        }
        return value;
      }
      api.getInitialContext = (options) => {
        const key = JSON.stringify({ processingMode: options.processingMode });
        const cached = INITIAL_CONTEXT_CACHE.get(key);
        if (cached) {
          return cached;
        }
        const initialContext = {
          processingMode: options.processingMode,
          mappings: /* @__PURE__ */ new Map(),
          inverse: null,
          getInverse: _createInverseContext,
          clone: _cloneActiveContext,
          revertToPreviousContext: _revertToPreviousContext,
          protected: {}
        };
        if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
          INITIAL_CONTEXT_CACHE.clear();
        }
        INITIAL_CONTEXT_CACHE.set(key, initialContext);
        return initialContext;
        function _createInverseContext() {
          const activeCtx = this;
          if (activeCtx.inverse) {
            return activeCtx.inverse;
          }
          const inverse = activeCtx.inverse = {};
          const fastCurieMap = activeCtx.fastCurieMap = {};
          const irisToTerms = {};
          const defaultLanguage = (activeCtx["@language"] || "@none").toLowerCase();
          const defaultDirection = activeCtx["@direction"];
          const mappings = activeCtx.mappings;
          const terms = [...mappings.keys()].sort(_compareShortestLeast);
          for (const term of terms) {
            const mapping = mappings.get(term);
            if (mapping === null) {
              continue;
            }
            let container = mapping["@container"] || "@none";
            container = [].concat(container).sort().join("");
            if (mapping["@id"] === null) {
              continue;
            }
            const ids = _asArray(mapping["@id"]);
            for (const iri of ids) {
              let entry = inverse[iri];
              const isKeyword = api.isKeyword(iri);
              if (!entry) {
                inverse[iri] = entry = {};
                if (!isKeyword && !mapping._termHasColon) {
                  irisToTerms[iri] = [term];
                  const fastCurieEntry = { iri, terms: irisToTerms[iri] };
                  if (iri[0] in fastCurieMap) {
                    fastCurieMap[iri[0]].push(fastCurieEntry);
                  } else {
                    fastCurieMap[iri[0]] = [fastCurieEntry];
                  }
                }
              } else if (!isKeyword && !mapping._termHasColon) {
                irisToTerms[iri].push(term);
              }
              if (!entry[container]) {
                entry[container] = {
                  "@language": {},
                  "@type": {},
                  "@any": {}
                };
              }
              entry = entry[container];
              _addPreferredTerm(term, entry["@any"], "@none");
              if (mapping.reverse) {
                _addPreferredTerm(term, entry["@type"], "@reverse");
              } else if (mapping["@type"] === "@none") {
                _addPreferredTerm(term, entry["@any"], "@none");
                _addPreferredTerm(term, entry["@language"], "@none");
                _addPreferredTerm(term, entry["@type"], "@none");
              } else if ("@type" in mapping) {
                _addPreferredTerm(term, entry["@type"], mapping["@type"]);
              } else if ("@language" in mapping && "@direction" in mapping) {
                const language = mapping["@language"];
                const direction = mapping["@direction"];
                if (language && direction) {
                  _addPreferredTerm(term, entry["@language"], `${language}_${direction}`.toLowerCase());
                } else if (language) {
                  _addPreferredTerm(term, entry["@language"], language.toLowerCase());
                } else if (direction) {
                  _addPreferredTerm(term, entry["@language"], `_${direction}`);
                } else {
                  _addPreferredTerm(term, entry["@language"], "@null");
                }
              } else if ("@language" in mapping) {
                _addPreferredTerm(term, entry["@language"], (mapping["@language"] || "@null").toLowerCase());
              } else if ("@direction" in mapping) {
                if (mapping["@direction"]) {
                  _addPreferredTerm(term, entry["@language"], `_${mapping["@direction"]}`);
                } else {
                  _addPreferredTerm(term, entry["@language"], "@none");
                }
              } else if (defaultDirection) {
                _addPreferredTerm(term, entry["@language"], `_${defaultDirection}`);
                _addPreferredTerm(term, entry["@language"], "@none");
                _addPreferredTerm(term, entry["@type"], "@none");
              } else {
                _addPreferredTerm(term, entry["@language"], defaultLanguage);
                _addPreferredTerm(term, entry["@language"], "@none");
                _addPreferredTerm(term, entry["@type"], "@none");
              }
            }
          }
          for (const key2 in fastCurieMap) {
            _buildIriMap(fastCurieMap, key2, 1);
          }
          return inverse;
        }
        function _buildIriMap(iriMap, key2, idx) {
          const entries = iriMap[key2];
          const next = iriMap[key2] = {};
          let iri;
          let letter;
          for (const entry of entries) {
            iri = entry.iri;
            if (idx >= iri.length) {
              letter = "";
            } else {
              letter = iri[idx];
            }
            if (letter in next) {
              next[letter].push(entry);
            } else {
              next[letter] = [entry];
            }
          }
          for (const key3 in next) {
            if (key3 === "") {
              continue;
            }
            _buildIriMap(next, key3, idx + 1);
          }
        }
        function _addPreferredTerm(term, entry, typeOrLanguageValue) {
          if (!entry.hasOwnProperty(typeOrLanguageValue)) {
            entry[typeOrLanguageValue] = term;
          }
        }
        function _cloneActiveContext() {
          const child = {};
          child.mappings = util.clone(this.mappings);
          child.clone = this.clone;
          child.inverse = null;
          child.getInverse = this.getInverse;
          child.protected = util.clone(this.protected);
          if (this.previousContext) {
            child.previousContext = this.previousContext.clone();
          }
          child.revertToPreviousContext = this.revertToPreviousContext;
          if ("@base" in this) {
            child["@base"] = this["@base"];
          }
          if ("@language" in this) {
            child["@language"] = this["@language"];
          }
          if ("@vocab" in this) {
            child["@vocab"] = this["@vocab"];
          }
          return child;
        }
        function _revertToPreviousContext() {
          if (!this.previousContext) {
            return this;
          }
          return this.previousContext.clone();
        }
      };
      api.getContextValue = (ctx, key, type) => {
        if (key === null) {
          if (type === "@context") {
            return void 0;
          }
          return null;
        }
        if (ctx.mappings.has(key)) {
          const entry = ctx.mappings.get(key);
          if (_isUndefined(type)) {
            return entry;
          }
          if (entry.hasOwnProperty(type)) {
            return entry[type];
          }
        }
        if (type === "@language" && type in ctx) {
          return ctx[type];
        }
        if (type === "@direction" && type in ctx) {
          return ctx[type];
        }
        if (type === "@context") {
          return void 0;
        }
        return null;
      };
      api.processingMode = (activeCtx, version) => {
        if (version.toString() >= "1.1") {
          return !activeCtx.processingMode || activeCtx.processingMode >= "json-ld-" + version.toString();
        } else {
          return activeCtx.processingMode === "json-ld-1.0";
        }
      };
      api.isKeyword = (v) => {
        if (!_isString(v) || v[0] !== "@") {
          return false;
        }
        switch (v) {
          case "@base":
          case "@container":
          case "@context":
          case "@default":
          case "@direction":
          case "@embed":
          case "@explicit":
          case "@graph":
          case "@id":
          case "@included":
          case "@index":
          case "@json":
          case "@language":
          case "@list":
          case "@nest":
          case "@none":
          case "@omitDefault":
          case "@prefix":
          case "@preserve":
          case "@protected":
          case "@requireAll":
          case "@reverse":
          case "@set":
          case "@type":
          case "@value":
          case "@version":
          case "@vocab":
            return true;
        }
        return false;
      };
      function _deepCompare(x1, x2) {
        if (!(x1 && typeof x1 === "object") || !(x2 && typeof x2 === "object")) {
          return x1 === x2;
        }
        const x1Array = Array.isArray(x1);
        if (x1Array !== Array.isArray(x2)) {
          return false;
        }
        if (x1Array) {
          if (x1.length !== x2.length) {
            return false;
          }
          for (let i = 0; i < x1.length; ++i) {
            if (!_deepCompare(x1[i], x2[i])) {
              return false;
            }
          }
          return true;
        }
        const k1s = Object.keys(x1);
        const k2s = Object.keys(x2);
        if (k1s.length !== k2s.length) {
          return false;
        }
        for (const k1 in x1) {
          let v1 = x1[k1];
          let v2 = x2[k1];
          if (k1 === "@container") {
            if (Array.isArray(v1) && Array.isArray(v2)) {
              v1 = v1.slice().sort();
              v2 = v2.slice().sort();
            }
          }
          if (!_deepCompare(v1, v2)) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/expand.js
  var require_expand = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/expand.js"(exports, module) {
      "use strict";
      var JsonLdError = require_JsonLdError();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isEmptyObject: _isEmptyObject,
        isString: _isString,
        isUndefined: _isUndefined
      } = require_types();
      var {
        isList: _isList,
        isValue: _isValue,
        isGraph: _isGraph,
        isSubject: _isSubject
      } = require_graphTypes();
      var {
        expandIri: _expandIri,
        getContextValue: _getContextValue,
        isKeyword: _isKeyword,
        process: _processContext,
        processingMode: _processingMode
      } = require_context();
      var {
        isAbsolute: _isAbsoluteIri
      } = require_url();
      var {
        addValue: _addValue,
        asArray: _asArray,
        getValues: _getValues,
        validateTypeValue: _validateTypeValue
      } = require_util2();
      var api = {};
      module.exports = api;
      var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
      api.expand = async ({
        activeCtx,
        activeProperty = null,
        element,
        options = {},
        insideList = false,
        insideIndex = false,
        typeScopedContext = null,
        expansionMap = () => void 0
      }) => {
        if (element === null || element === void 0) {
          return null;
        }
        if (activeProperty === "@default") {
          options = Object.assign({}, options, { isFrame: false });
        }
        if (!_isArray(element) && !_isObject(element)) {
          if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, { vocab: true }, options) === "@graph")) {
            const mapped = await expansionMap({
              unmappedValue: element,
              activeCtx,
              activeProperty,
              options,
              insideList
            });
            if (mapped === void 0) {
              return null;
            }
            return mapped;
          }
          return _expandValue({ activeCtx, activeProperty, value: element, options });
        }
        if (_isArray(element)) {
          let rval2 = [];
          const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
          insideList = insideList || container.includes("@list");
          for (let i = 0; i < element.length; ++i) {
            let e = await api.expand({
              activeCtx,
              activeProperty,
              element: element[i],
              options,
              expansionMap,
              insideIndex,
              typeScopedContext
            });
            if (insideList && _isArray(e)) {
              e = { "@list": e };
            }
            if (e === null) {
              e = await expansionMap({
                unmappedValue: element[i],
                activeCtx,
                activeProperty,
                parent: element,
                index: i,
                options,
                expandedParent: rval2,
                insideList
              });
              if (e === void 0) {
                continue;
              }
            }
            if (_isArray(e)) {
              rval2 = rval2.concat(e);
            } else {
              rval2.push(e);
            }
          }
          return rval2;
        }
        const expandedActiveProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
        const propertyScopedCtx = _getContextValue(activeCtx, activeProperty, "@context");
        typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
        let keys = Object.keys(element).sort();
        let mustRevert = !insideIndex;
        if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes("@context")) {
          for (const key of keys) {
            const expandedProperty = _expandIri(typeScopedContext, key, { vocab: true }, options);
            if (expandedProperty === "@value") {
              mustRevert = false;
              activeCtx = typeScopedContext;
              break;
            }
            if (expandedProperty === "@id" && keys.length === 1) {
              mustRevert = false;
              break;
            }
          }
        }
        if (mustRevert) {
          activeCtx = activeCtx.revertToPreviousContext();
        }
        if (!_isUndefined(propertyScopedCtx)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: propertyScopedCtx,
            propagate: true,
            overrideProtected: true,
            options
          });
        }
        if ("@context" in element) {
          activeCtx = await _processContext({ activeCtx, localCtx: element["@context"], options });
        }
        typeScopedContext = activeCtx;
        let typeKey = null;
        for (const key of keys) {
          const expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
          if (expandedProperty === "@type") {
            typeKey = typeKey || key;
            const value = element[key];
            const types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
            for (const type of types) {
              const ctx = _getContextValue(typeScopedContext, type, "@context");
              if (!_isUndefined(ctx)) {
                activeCtx = await _processContext({
                  activeCtx,
                  localCtx: ctx,
                  options,
                  propagate: false
                });
              }
            }
          }
        }
        let rval = {};
        await _expandObject({
          activeCtx,
          activeProperty,
          expandedActiveProperty,
          element,
          expandedParent: rval,
          options,
          insideList,
          typeKey,
          typeScopedContext,
          expansionMap
        });
        keys = Object.keys(rval);
        let count = keys.length;
        if ("@value" in rval) {
          if ("@type" in rval && ("@language" in rval || "@direction" in rval)) {
            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and either "@language" or "@direction".', "jsonld.SyntaxError", { code: "invalid value object", element: rval });
          }
          let validCount = count - 1;
          if ("@type" in rval) {
            validCount -= 1;
          }
          if ("@index" in rval) {
            validCount -= 1;
          }
          if ("@language" in rval) {
            validCount -= 1;
          }
          if ("@direction" in rval) {
            validCount -= 1;
          }
          if (validCount !== 0) {
            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and either "@type" or either or both "@language" or "@direction".', "jsonld.SyntaxError", { code: "invalid value object", element: rval });
          }
          const values = rval["@value"] === null ? [] : _asArray(rval["@value"]);
          const types = _getValues(rval, "@type");
          if (_processingMode(activeCtx, 1.1) && types.includes("@json") && types.length === 1) {
          } else if (values.length === 0) {
            const mapped = await expansionMap({
              unmappedValue: rval,
              activeCtx,
              activeProperty,
              element,
              options,
              insideList
            });
            if (mapped !== void 0) {
              rval = mapped;
            } else {
              rval = null;
            }
          } else if (!values.every((v) => _isString(v) || _isEmptyObject(v)) && "@language" in rval) {
            throw new JsonLdError("Invalid JSON-LD syntax; only strings may be language-tagged.", "jsonld.SyntaxError", { code: "invalid language-tagged value", element: rval });
          } else if (!types.every((t) => _isAbsoluteIri(t) && !(_isString(t) && t.indexOf("_:") === 0) || _isEmptyObject(t))) {
            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".', "jsonld.SyntaxError", { code: "invalid typed value", element: rval });
          }
        } else if ("@type" in rval && !_isArray(rval["@type"])) {
          rval["@type"] = [rval["@type"]];
        } else if ("@set" in rval || "@list" in rval) {
          if (count > 1 && !(count === 2 && "@index" in rval)) {
            throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".', "jsonld.SyntaxError", { code: "invalid set or list object", element: rval });
          }
          if ("@set" in rval) {
            rval = rval["@set"];
            keys = Object.keys(rval);
            count = keys.length;
          }
        } else if (count === 1 && "@language" in rval) {
          const mapped = await expansionMap(rval, {
            unmappedValue: rval,
            activeCtx,
            activeProperty,
            element,
            options,
            insideList
          });
          if (mapped !== void 0) {
            rval = mapped;
          } else {
            rval = null;
          }
        }
        if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === "@graph")) {
          if (count === 0 || "@value" in rval || "@list" in rval || count === 1 && "@id" in rval) {
            const mapped = await expansionMap({
              unmappedValue: rval,
              activeCtx,
              activeProperty,
              element,
              options,
              insideList
            });
            if (mapped !== void 0) {
              rval = mapped;
            } else {
              rval = null;
            }
          }
        }
        return rval;
      };
      async function _expandObject({
        activeCtx,
        activeProperty,
        expandedActiveProperty,
        element,
        expandedParent,
        options = {},
        insideList,
        typeKey,
        typeScopedContext,
        expansionMap
      }) {
        const keys = Object.keys(element).sort();
        const nests = [];
        let unexpandedValue;
        const isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], { vocab: true }, options) === "@json";
        for (const key of keys) {
          let value = element[key];
          let expandedValue;
          if (key === "@context") {
            continue;
          }
          let expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
          if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {
            expandedProperty = expansionMap({
              unmappedProperty: key,
              activeCtx,
              activeProperty,
              parent: element,
              options,
              insideList,
              value,
              expandedParent
            });
            if (expandedProperty === void 0) {
              continue;
            }
          }
          if (_isKeyword(expandedProperty)) {
            if (expandedActiveProperty === "@reverse") {
              throw new JsonLdError("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.", "jsonld.SyntaxError", { code: "invalid reverse property map", value });
            }
            if (expandedProperty in expandedParent && expandedProperty !== "@included" && expandedProperty !== "@type") {
              throw new JsonLdError("Invalid JSON-LD syntax; colliding keywords detected.", "jsonld.SyntaxError", { code: "colliding keywords", keyword: expandedProperty });
            }
          }
          if (expandedProperty === "@id") {
            if (!_isString(value)) {
              if (!options.isFrame) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.', "jsonld.SyntaxError", { code: "invalid @id value", value });
              }
              if (_isObject(value)) {
                if (!_isEmptyObject(value)) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value });
                }
              } else if (_isArray(value)) {
                if (!value.every((v) => _isString(v))) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value });
                }
              } else {
                throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value });
              }
            }
            _addValue(expandedParent, "@id", _asArray(value).map((v) => _isString(v) ? _expandIri(activeCtx, v, { base: true }, options) : v), { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@type") {
            if (_isObject(value)) {
              value = Object.fromEntries(Object.entries(value).map(([k, v]) => [
                _expandIri(typeScopedContext, k, { vocab: true }),
                _asArray(v).map((vv) => _expandIri(typeScopedContext, vv, { base: true, vocab: true }))
              ]));
            }
            _validateTypeValue(value, options.isFrame);
            _addValue(expandedParent, "@type", _asArray(value).map((v) => _isString(v) ? _expandIri(typeScopedContext, v, { base: true, vocab: true }, options) : v), { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@included" && _processingMode(activeCtx, 1.1)) {
            const includedResult = _asArray(await api.expand({
              activeCtx,
              activeProperty,
              element: value,
              options,
              expansionMap
            }));
            if (!includedResult.every((v) => _isSubject(v))) {
              throw new JsonLdError("Invalid JSON-LD syntax; values of @included must expand to node objects.", "jsonld.SyntaxError", { code: "invalid @included value", value });
            }
            _addValue(expandedParent, "@included", includedResult, { propertyIsArray: true });
            continue;
          }
          if (expandedProperty === "@graph" && !(_isObject(value) || _isArray(value))) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.', "jsonld.SyntaxError", { code: "invalid @graph value", value });
          }
          if (expandedProperty === "@value") {
            unexpandedValue = value;
            if (isJsonType && _processingMode(activeCtx, 1.1)) {
              expandedParent["@value"] = value;
            } else {
              _addValue(expandedParent, "@value", value, { propertyIsArray: options.isFrame });
            }
            continue;
          }
          if (expandedProperty === "@language") {
            if (value === null) {
              continue;
            }
            if (!_isString(value) && !options.isFrame) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.', "jsonld.SyntaxError", { code: "invalid language-tagged string", value });
            }
            value = _asArray(value).map((v) => _isString(v) ? v.toLowerCase() : v);
            for (const lang of value) {
              if (_isString(lang) && !lang.match(REGEX_BCP47)) {
                console.warn(`@language must be valid BCP47: ${lang}`);
              }
            }
            _addValue(expandedParent, "@language", value, { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@direction") {
            if (!_isString(value) && !options.isFrame) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@direction" value must be a string.', "jsonld.SyntaxError", { code: "invalid base direction", value });
            }
            value = _asArray(value);
            for (const dir of value) {
              if (_isString(dir) && dir !== "ltr" && dir !== "rtl") {
                throw new JsonLdError('Invalid JSON-LD syntax; "@direction" must be "ltr" or "rtl".', "jsonld.SyntaxError", { code: "invalid base direction", value });
              }
            }
            _addValue(expandedParent, "@direction", value, { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@index") {
            if (!_isString(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.', "jsonld.SyntaxError", { code: "invalid @index value", value });
            }
            _addValue(expandedParent, "@index", value);
            continue;
          }
          if (expandedProperty === "@reverse") {
            if (!_isObject(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.', "jsonld.SyntaxError", { code: "invalid @reverse value", value });
            }
            expandedValue = await api.expand({
              activeCtx,
              activeProperty: "@reverse",
              element: value,
              options,
              expansionMap
            });
            if ("@reverse" in expandedValue) {
              for (const property in expandedValue["@reverse"]) {
                _addValue(expandedParent, property, expandedValue["@reverse"][property], { propertyIsArray: true });
              }
            }
            let reverseMap = expandedParent["@reverse"] || null;
            for (const property in expandedValue) {
              if (property === "@reverse") {
                continue;
              }
              if (reverseMap === null) {
                reverseMap = expandedParent["@reverse"] = {};
              }
              _addValue(reverseMap, property, [], { propertyIsArray: true });
              const items = expandedValue[property];
              for (let ii = 0; ii < items.length; ++ii) {
                const item = items[ii];
                if (_isValue(item) || _isList(item)) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.', "jsonld.SyntaxError", { code: "invalid reverse property value", value: expandedValue });
                }
                _addValue(reverseMap, property, item, { propertyIsArray: true });
              }
            }
            continue;
          }
          if (expandedProperty === "@nest") {
            nests.push(key);
            continue;
          }
          let termCtx = activeCtx;
          const ctx = _getContextValue(activeCtx, key, "@context");
          if (!_isUndefined(ctx)) {
            termCtx = await _processContext({
              activeCtx,
              localCtx: ctx,
              propagate: true,
              overrideProtected: true,
              options
            });
          }
          const container = _getContextValue(termCtx, key, "@container") || [];
          if (container.includes("@language") && _isObject(value)) {
            const direction = _getContextValue(termCtx, key, "@direction");
            expandedValue = _expandLanguageMap(termCtx, value, direction, options);
          } else if (container.includes("@index") && _isObject(value)) {
            const asGraph = container.includes("@graph");
            const indexKey = _getContextValue(termCtx, key, "@index") || "@index";
            const propertyIndex = indexKey !== "@index" && _expandIri(activeCtx, indexKey, { vocab: true }, options);
            expandedValue = await _expandIndexMap({
              activeCtx: termCtx,
              options,
              activeProperty: key,
              value,
              expansionMap,
              asGraph,
              indexKey,
              propertyIndex
            });
          } else if (container.includes("@id") && _isObject(value)) {
            const asGraph = container.includes("@graph");
            expandedValue = await _expandIndexMap({
              activeCtx: termCtx,
              options,
              activeProperty: key,
              value,
              expansionMap,
              asGraph,
              indexKey: "@id"
            });
          } else if (container.includes("@type") && _isObject(value)) {
            expandedValue = await _expandIndexMap({
              activeCtx: termCtx.revertToPreviousContext(),
              options,
              activeProperty: key,
              value,
              expansionMap,
              asGraph: false,
              indexKey: "@type"
            });
          } else {
            const isList = expandedProperty === "@list";
            if (isList || expandedProperty === "@set") {
              let nextActiveProperty = activeProperty;
              if (isList && expandedActiveProperty === "@graph") {
                nextActiveProperty = null;
              }
              expandedValue = await api.expand({
                activeCtx: termCtx,
                activeProperty: nextActiveProperty,
                element: value,
                options,
                insideList: isList,
                expansionMap
              });
            } else if (_getContextValue(activeCtx, key, "@type") === "@json") {
              expandedValue = {
                "@type": "@json",
                "@value": value
              };
            } else {
              expandedValue = await api.expand({
                activeCtx: termCtx,
                activeProperty: key,
                element: value,
                options,
                insideList: false,
                expansionMap
              });
            }
          }
          if (expandedValue === null && expandedProperty !== "@value") {
            expandedValue = expansionMap({
              unmappedValue: value,
              expandedProperty,
              activeCtx: termCtx,
              activeProperty,
              parent: element,
              options,
              insideList,
              key,
              expandedParent
            });
            if (expandedValue === void 0) {
              continue;
            }
          }
          if (expandedProperty !== "@list" && !_isList(expandedValue) && container.includes("@list")) {
            expandedValue = { "@list": _asArray(expandedValue) };
          }
          if (container.includes("@graph") && !container.some((key2) => key2 === "@id" || key2 === "@index")) {
            expandedValue = _asArray(expandedValue).map((v) => ({ "@graph": _asArray(v) }));
          }
          if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {
            const reverseMap = expandedParent["@reverse"] = expandedParent["@reverse"] || {};
            expandedValue = _asArray(expandedValue);
            for (let ii = 0; ii < expandedValue.length; ++ii) {
              const item = expandedValue[ii];
              if (_isValue(item) || _isList(item)) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.', "jsonld.SyntaxError", { code: "invalid reverse property value", value: expandedValue });
              }
              _addValue(reverseMap, expandedProperty, item, { propertyIsArray: true });
            }
            continue;
          }
          _addValue(expandedParent, expandedProperty, expandedValue, {
            propertyIsArray: true
          });
        }
        if ("@value" in expandedParent) {
          if (expandedParent["@type"] === "@json" && _processingMode(activeCtx, 1.1)) {
          } else if ((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an object or an array.', "jsonld.SyntaxError", { code: "invalid value object value", value: unexpandedValue });
          }
        }
        for (const key of nests) {
          const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];
          for (const nv of nestedValues) {
            if (!_isObject(nv) || Object.keys(nv).some((k) => _expandIri(activeCtx, k, { vocab: true }, options) === "@value")) {
              throw new JsonLdError("Invalid JSON-LD syntax; nested value must be a node object.", "jsonld.SyntaxError", { code: "invalid @nest value", value: nv });
            }
            await _expandObject({
              activeCtx,
              activeProperty,
              expandedActiveProperty,
              element: nv,
              expandedParent,
              options,
              insideList,
              typeScopedContext,
              typeKey,
              expansionMap
            });
          }
        }
      }
      function _expandValue({ activeCtx, activeProperty, value, options }) {
        if (value === null || value === void 0) {
          return null;
        }
        const expandedProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
        if (expandedProperty === "@id") {
          return _expandIri(activeCtx, value, { base: true }, options);
        } else if (expandedProperty === "@type") {
          return _expandIri(activeCtx, value, { vocab: true, base: true }, options);
        }
        const type = _getContextValue(activeCtx, activeProperty, "@type");
        if ((type === "@id" || expandedProperty === "@graph") && _isString(value)) {
          return { "@id": _expandIri(activeCtx, value, { base: true }, options) };
        }
        if (type === "@vocab" && _isString(value)) {
          return {
            "@id": _expandIri(activeCtx, value, { vocab: true, base: true }, options)
          };
        }
        if (_isKeyword(expandedProperty)) {
          return value;
        }
        const rval = {};
        if (type && !["@id", "@vocab", "@none"].includes(type)) {
          rval["@type"] = type;
        } else if (_isString(value)) {
          const language = _getContextValue(activeCtx, activeProperty, "@language");
          if (language !== null) {
            rval["@language"] = language;
          }
          const direction = _getContextValue(activeCtx, activeProperty, "@direction");
          if (direction !== null) {
            rval["@direction"] = direction;
          }
        }
        if (!["boolean", "number", "string"].includes(typeof value)) {
          value = value.toString();
        }
        rval["@value"] = value;
        return rval;
      }
      function _expandLanguageMap(activeCtx, languageMap, direction, options) {
        const rval = [];
        const keys = Object.keys(languageMap).sort();
        for (const key of keys) {
          const expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
          let val = languageMap[key];
          if (!_isArray(val)) {
            val = [val];
          }
          for (const item of val) {
            if (item === null) {
              continue;
            }
            if (!_isString(item)) {
              throw new JsonLdError("Invalid JSON-LD syntax; language map values must be strings.", "jsonld.SyntaxError", { code: "invalid language map value", languageMap });
            }
            const val2 = { "@value": item };
            if (expandedKey !== "@none") {
              val2["@language"] = key.toLowerCase();
            }
            if (direction) {
              val2["@direction"] = direction;
            }
            rval.push(val2);
          }
        }
        return rval;
      }
      async function _expandIndexMap({
        activeCtx,
        options,
        activeProperty,
        value,
        expansionMap,
        asGraph,
        indexKey,
        propertyIndex
      }) {
        const rval = [];
        const keys = Object.keys(value).sort();
        const isTypeIndex = indexKey === "@type";
        for (let key of keys) {
          if (isTypeIndex) {
            const ctx = _getContextValue(activeCtx, key, "@context");
            if (!_isUndefined(ctx)) {
              activeCtx = await _processContext({
                activeCtx,
                localCtx: ctx,
                propagate: false,
                options
              });
            }
          }
          let val = value[key];
          if (!_isArray(val)) {
            val = [val];
          }
          val = await api.expand({
            activeCtx,
            activeProperty,
            element: val,
            options,
            insideList: false,
            insideIndex: true,
            expansionMap
          });
          let expandedKey;
          if (propertyIndex) {
            if (key === "@none") {
              expandedKey = "@none";
            } else {
              expandedKey = _expandValue({ activeCtx, activeProperty: indexKey, value: key, options });
            }
          } else {
            expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
          }
          if (indexKey === "@id") {
            key = _expandIri(activeCtx, key, { base: true }, options);
          } else if (isTypeIndex) {
            key = expandedKey;
          }
          for (let item of val) {
            if (asGraph && !_isGraph(item)) {
              item = { "@graph": [item] };
            }
            if (indexKey === "@type") {
              if (expandedKey === "@none") {
              } else if (item["@type"]) {
                item["@type"] = [key].concat(item["@type"]);
              } else {
                item["@type"] = [key];
              }
            } else if (_isValue(item) && !["@language", "@type", "@index"].includes(indexKey)) {
              throw new JsonLdError(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${indexKey}".`, "jsonld.SyntaxError", { code: "invalid value object", value: item });
            } else if (propertyIndex) {
              if (expandedKey !== "@none") {
                _addValue(item, propertyIndex, expandedKey, {
                  propertyIsArray: true,
                  prependValue: true
                });
              }
            } else if (expandedKey !== "@none" && !(indexKey in item)) {
              item[indexKey] = key;
            }
            rval.push(item);
          }
        }
        return rval;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/nodeMap.js
  var require_nodeMap = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/nodeMap.js"(exports, module) {
      "use strict";
      var { isKeyword } = require_context();
      var graphTypes = require_graphTypes();
      var types = require_types();
      var util = require_util2();
      var JsonLdError = require_JsonLdError();
      var api = {};
      module.exports = api;
      api.createMergedNodeMap = (input, options) => {
        options = options || {};
        const issuer = options.issuer || new util.IdentifierIssuer("_:b");
        const graphs = { "@default": {} };
        api.createNodeMap(input, graphs, "@default", issuer);
        return api.mergeNodeMaps(graphs);
      };
      api.createNodeMap = (input, graphs, graph, issuer, name, list) => {
        if (types.isArray(input)) {
          for (const node of input) {
            api.createNodeMap(node, graphs, graph, issuer, void 0, list);
          }
          return;
        }
        if (!types.isObject(input)) {
          if (list) {
            list.push(input);
          }
          return;
        }
        if (graphTypes.isValue(input)) {
          if ("@type" in input) {
            let type = input["@type"];
            if (type.indexOf("_:") === 0) {
              input["@type"] = type = issuer.getId(type);
            }
          }
          if (list) {
            list.push(input);
          }
          return;
        } else if (list && graphTypes.isList(input)) {
          const _list = [];
          api.createNodeMap(input["@list"], graphs, graph, issuer, name, _list);
          list.push({ "@list": _list });
          return;
        }
        if ("@type" in input) {
          const types2 = input["@type"];
          for (const type of types2) {
            if (type.indexOf("_:") === 0) {
              issuer.getId(type);
            }
          }
        }
        if (types.isUndefined(name)) {
          name = graphTypes.isBlankNode(input) ? issuer.getId(input["@id"]) : input["@id"];
        }
        if (list) {
          list.push({ "@id": name });
        }
        const subjects = graphs[graph];
        const subject = subjects[name] = subjects[name] || {};
        subject["@id"] = name;
        const properties = Object.keys(input).sort();
        for (let property of properties) {
          if (property === "@id") {
            continue;
          }
          if (property === "@reverse") {
            const referencedNode = { "@id": name };
            const reverseMap = input["@reverse"];
            for (const reverseProperty in reverseMap) {
              const items = reverseMap[reverseProperty];
              for (const item of items) {
                let itemName = item["@id"];
                if (graphTypes.isBlankNode(item)) {
                  itemName = issuer.getId(itemName);
                }
                api.createNodeMap(item, graphs, graph, issuer, itemName);
                util.addValue(subjects[itemName], reverseProperty, referencedNode, { propertyIsArray: true, allowDuplicate: false });
              }
            }
            continue;
          }
          if (property === "@graph") {
            if (!(name in graphs)) {
              graphs[name] = {};
            }
            api.createNodeMap(input[property], graphs, name, issuer);
            continue;
          }
          if (property === "@included") {
            api.createNodeMap(input[property], graphs, graph, issuer);
            continue;
          }
          if (property !== "@type" && isKeyword(property)) {
            if (property === "@index" && property in subject && (input[property] !== subject[property] || input[property]["@id"] !== subject[property]["@id"])) {
              throw new JsonLdError("Invalid JSON-LD syntax; conflicting @index property detected.", "jsonld.SyntaxError", { code: "conflicting indexes", subject });
            }
            subject[property] = input[property];
            continue;
          }
          const objects = input[property];
          if (property.indexOf("_:") === 0) {
            property = issuer.getId(property);
          }
          if (objects.length === 0) {
            util.addValue(subject, property, [], { propertyIsArray: true });
            continue;
          }
          for (let o of objects) {
            if (property === "@type") {
              o = o.indexOf("_:") === 0 ? issuer.getId(o) : o;
            }
            if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {
              if ("@id" in o && !o["@id"]) {
                continue;
              }
              const id = graphTypes.isBlankNode(o) ? issuer.getId(o["@id"]) : o["@id"];
              util.addValue(subject, property, { "@id": id }, { propertyIsArray: true, allowDuplicate: false });
              api.createNodeMap(o, graphs, graph, issuer, id);
            } else if (graphTypes.isValue(o)) {
              util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
            } else if (graphTypes.isList(o)) {
              const _list = [];
              api.createNodeMap(o["@list"], graphs, graph, issuer, name, _list);
              o = { "@list": _list };
              util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
            } else {
              api.createNodeMap(o, graphs, graph, issuer, name);
              util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
            }
          }
        }
      };
      api.mergeNodeMapGraphs = (graphs) => {
        const merged = {};
        for (const name of Object.keys(graphs).sort()) {
          for (const id of Object.keys(graphs[name]).sort()) {
            const node = graphs[name][id];
            if (!(id in merged)) {
              merged[id] = { "@id": id };
            }
            const mergedNode = merged[id];
            for (const property of Object.keys(node).sort()) {
              if (isKeyword(property) && property !== "@type") {
                mergedNode[property] = util.clone(node[property]);
              } else {
                for (const value of node[property]) {
                  util.addValue(mergedNode, property, util.clone(value), { propertyIsArray: true, allowDuplicate: false });
                }
              }
            }
          }
        }
        return merged;
      };
      api.mergeNodeMaps = (graphs) => {
        const defaultGraph = graphs["@default"];
        const graphNames = Object.keys(graphs).sort();
        for (const graphName of graphNames) {
          if (graphName === "@default") {
            continue;
          }
          const nodeMap = graphs[graphName];
          let subject = defaultGraph[graphName];
          if (!subject) {
            defaultGraph[graphName] = subject = {
              "@id": graphName,
              "@graph": []
            };
          } else if (!("@graph" in subject)) {
            subject["@graph"] = [];
          }
          const graph = subject["@graph"];
          for (const id of Object.keys(nodeMap).sort()) {
            const node = nodeMap[id];
            if (!graphTypes.isSubjectReference(node)) {
              graph.push(node);
            }
          }
        }
        return defaultGraph;
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/flatten.js
  var require_flatten = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/flatten.js"(exports, module) {
      "use strict";
      var {
        isSubjectReference: _isSubjectReference
      } = require_graphTypes();
      var {
        createMergedNodeMap: _createMergedNodeMap
      } = require_nodeMap();
      var api = {};
      module.exports = api;
      api.flatten = (input) => {
        const defaultGraph = _createMergedNodeMap(input);
        const flattened = [];
        const keys = Object.keys(defaultGraph).sort();
        for (let ki = 0; ki < keys.length; ++ki) {
          const node = defaultGraph[keys[ki]];
          if (!_isSubjectReference(node)) {
            flattened.push(node);
          }
        }
        return flattened;
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/fromRdf.js
  var require_fromRdf = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/fromRdf.js"(exports, module) {
      "use strict";
      var JsonLdError = require_JsonLdError();
      var graphTypes = require_graphTypes();
      var types = require_types();
      var util = require_util2();
      var {
        RDF_LIST,
        RDF_FIRST,
        RDF_REST,
        RDF_NIL,
        RDF_TYPE,
        RDF_JSON_LITERAL,
        XSD_BOOLEAN,
        XSD_DOUBLE,
        XSD_INTEGER,
        XSD_STRING
      } = require_constants3();
      var REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;
      var api = {};
      module.exports = api;
      api.fromRDF = async (dataset, {
        useRdfType = false,
        useNativeTypes = false,
        rdfDirection = null
      }) => {
        const defaultGraph = {};
        const graphMap = { "@default": defaultGraph };
        const referencedOnce = {};
        for (const quad of dataset) {
          const name = quad.graph.termType === "DefaultGraph" ? "@default" : quad.graph.value;
          if (!(name in graphMap)) {
            graphMap[name] = {};
          }
          if (name !== "@default" && !(name in defaultGraph)) {
            defaultGraph[name] = { "@id": name };
          }
          const nodeMap = graphMap[name];
          const s = quad.subject.value;
          const p = quad.predicate.value;
          const o = quad.object;
          if (!(s in nodeMap)) {
            nodeMap[s] = { "@id": s };
          }
          const node = nodeMap[s];
          const objectIsNode = o.termType.endsWith("Node");
          if (objectIsNode && !(o.value in nodeMap)) {
            nodeMap[o.value] = { "@id": o.value };
          }
          if (p === RDF_TYPE && !useRdfType && objectIsNode) {
            util.addValue(node, "@type", o.value, { propertyIsArray: true });
            continue;
          }
          const value = _RDFToObject(o, useNativeTypes, rdfDirection);
          util.addValue(node, p, value, { propertyIsArray: true });
          if (objectIsNode) {
            if (o.value === RDF_NIL) {
              const object = nodeMap[o.value];
              if (!("usages" in object)) {
                object.usages = [];
              }
              object.usages.push({
                node,
                property: p,
                value
              });
            } else if (o.value in referencedOnce) {
              referencedOnce[o.value] = false;
            } else {
              referencedOnce[o.value] = {
                node,
                property: p,
                value
              };
            }
          }
        }
        for (const name in graphMap) {
          const graphObject = graphMap[name];
          if (!(RDF_NIL in graphObject)) {
            continue;
          }
          const nil = graphObject[RDF_NIL];
          if (!nil.usages) {
            continue;
          }
          for (let usage of nil.usages) {
            let node = usage.node;
            let property = usage.property;
            let head = usage.value;
            const list = [];
            const listNodes = [];
            let nodeKeyCount = Object.keys(node).length;
            while (property === RDF_REST && types.isObject(referencedOnce[node["@id"]]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node["@type"]) && node["@type"].length === 1 && node["@type"][0] === RDF_LIST)) {
              list.push(node[RDF_FIRST][0]);
              listNodes.push(node["@id"]);
              usage = referencedOnce[node["@id"]];
              node = usage.node;
              property = usage.property;
              head = usage.value;
              nodeKeyCount = Object.keys(node).length;
              if (!graphTypes.isBlankNode(node)) {
                break;
              }
            }
            delete head["@id"];
            head["@list"] = list.reverse();
            for (const listNode of listNodes) {
              delete graphObject[listNode];
            }
          }
          delete nil.usages;
        }
        const result = [];
        const subjects = Object.keys(defaultGraph).sort();
        for (const subject of subjects) {
          const node = defaultGraph[subject];
          if (subject in graphMap) {
            const graph = node["@graph"] = [];
            const graphObject = graphMap[subject];
            const graphSubjects = Object.keys(graphObject).sort();
            for (const graphSubject of graphSubjects) {
              const node2 = graphObject[graphSubject];
              if (!graphTypes.isSubjectReference(node2)) {
                graph.push(node2);
              }
            }
          }
          if (!graphTypes.isSubjectReference(node)) {
            result.push(node);
          }
        }
        return result;
      };
      function _RDFToObject(o, useNativeTypes, rdfDirection) {
        if (o.termType.endsWith("Node")) {
          return { "@id": o.value };
        }
        const rval = { "@value": o.value };
        if (o.language) {
          rval["@language"] = o.language;
        } else {
          let type = o.datatype.value;
          if (!type) {
            type = XSD_STRING;
          }
          if (type === RDF_JSON_LITERAL) {
            type = "@json";
            try {
              rval["@value"] = JSON.parse(rval["@value"]);
            } catch (e) {
              throw new JsonLdError("JSON literal could not be parsed.", "jsonld.InvalidJsonLiteral", { code: "invalid JSON literal", value: rval["@value"], cause: e });
            }
          }
          if (useNativeTypes) {
            if (type === XSD_BOOLEAN) {
              if (rval["@value"] === "true") {
                rval["@value"] = true;
              } else if (rval["@value"] === "false") {
                rval["@value"] = false;
              }
            } else if (types.isNumeric(rval["@value"])) {
              if (type === XSD_INTEGER) {
                const i = parseInt(rval["@value"], 10);
                if (i.toFixed(0) === rval["@value"]) {
                  rval["@value"] = i;
                }
              } else if (type === XSD_DOUBLE) {
                rval["@value"] = parseFloat(rval["@value"]);
              }
            }
            if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {
              rval["@type"] = type;
            }
          } else if (rdfDirection === "i18n-datatype" && type.startsWith("https://www.w3.org/ns/i18n#")) {
            const [, language, direction] = type.split(/[#_]/);
            if (language.length > 0) {
              rval["@language"] = language;
              if (!language.match(REGEX_BCP47)) {
                console.warn(`@language must be valid BCP47: ${language}`);
              }
            }
            rval["@direction"] = direction;
          } else if (type !== XSD_STRING) {
            rval["@type"] = type;
          }
        }
        return rval;
      }
    }
  });

  // node_modules/canonicalize/lib/canonicalize.js
  var require_canonicalize = __commonJS({
    "node_modules/canonicalize/lib/canonicalize.js"(exports, module) {
      "use strict";
      module.exports = function serialize(object) {
        if (object === null || typeof object !== "object" || object.toJSON != null) {
          return JSON.stringify(object);
        }
        if (Array.isArray(object)) {
          return "[" + object.reduce((t, cv, ci) => {
            const comma = ci === 0 ? "" : ",";
            const value = cv === void 0 || typeof cv === "symbol" ? null : cv;
            return t + comma + serialize(value);
          }, "") + "]";
        }
        return "{" + Object.keys(object).sort().reduce((t, cv, ci) => {
          if (object[cv] === void 0 || typeof object[cv] === "symbol") {
            return t;
          }
          const comma = t.length === 0 ? "" : ",";
          return t + comma + serialize(cv) + ":" + serialize(object[cv]);
        }, "") + "}";
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/toRdf.js
  var require_toRdf = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/toRdf.js"(exports, module) {
      "use strict";
      var { createNodeMap } = require_nodeMap();
      var { isKeyword } = require_context();
      var graphTypes = require_graphTypes();
      var jsonCanonicalize = require_canonicalize();
      var types = require_types();
      var util = require_util2();
      var {
        RDF_FIRST,
        RDF_REST,
        RDF_NIL,
        RDF_TYPE,
        RDF_JSON_LITERAL,
        RDF_LANGSTRING,
        XSD_BOOLEAN,
        XSD_DOUBLE,
        XSD_INTEGER,
        XSD_STRING
      } = require_constants3();
      var {
        isAbsolute: _isAbsoluteIri
      } = require_url();
      var api = {};
      module.exports = api;
      api.toRDF = (input, options) => {
        const issuer = new util.IdentifierIssuer("_:b");
        const nodeMap = { "@default": {} };
        createNodeMap(input, nodeMap, "@default", issuer);
        const dataset = [];
        const graphNames = Object.keys(nodeMap).sort();
        for (const graphName of graphNames) {
          let graphTerm;
          if (graphName === "@default") {
            graphTerm = { termType: "DefaultGraph", value: "" };
          } else if (_isAbsoluteIri(graphName)) {
            if (graphName.startsWith("_:")) {
              graphTerm = { termType: "BlankNode" };
            } else {
              graphTerm = { termType: "NamedNode" };
            }
            graphTerm.value = graphName;
          } else {
            continue;
          }
          _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);
        }
        return dataset;
      };
      function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
        const ids = Object.keys(graph).sort();
        for (const id of ids) {
          const node = graph[id];
          const properties = Object.keys(node).sort();
          for (let property of properties) {
            const items = node[property];
            if (property === "@type") {
              property = RDF_TYPE;
            } else if (isKeyword(property)) {
              continue;
            }
            for (const item of items) {
              const subject = {
                termType: id.startsWith("_:") ? "BlankNode" : "NamedNode",
                value: id
              };
              if (!_isAbsoluteIri(id)) {
                continue;
              }
              const predicate = {
                termType: property.startsWith("_:") ? "BlankNode" : "NamedNode",
                value: property
              };
              if (!_isAbsoluteIri(property)) {
                continue;
              }
              if (predicate.termType === "BlankNode" && !options.produceGeneralizedRdf) {
                continue;
              }
              const object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);
              if (object) {
                dataset.push({
                  subject,
                  predicate,
                  object,
                  graph: graphTerm
                });
              }
            }
          }
        }
      }
      function _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {
        const first = { termType: "NamedNode", value: RDF_FIRST };
        const rest = { termType: "NamedNode", value: RDF_REST };
        const nil = { termType: "NamedNode", value: RDF_NIL };
        const last = list.pop();
        const result = last ? { termType: "BlankNode", value: issuer.getId() } : nil;
        let subject = result;
        for (const item of list) {
          const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);
          const next = { termType: "BlankNode", value: issuer.getId() };
          dataset.push({
            subject,
            predicate: first,
            object,
            graph: graphTerm
          });
          dataset.push({
            subject,
            predicate: rest,
            object: next,
            graph: graphTerm
          });
          subject = next;
        }
        if (last) {
          const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);
          dataset.push({
            subject,
            predicate: first,
            object,
            graph: graphTerm
          });
          dataset.push({
            subject,
            predicate: rest,
            object: nil,
            graph: graphTerm
          });
        }
        return result;
      }
      function _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {
        const object = {};
        if (graphTypes.isValue(item)) {
          object.termType = "Literal";
          object.value = void 0;
          object.datatype = {
            termType: "NamedNode"
          };
          let value = item["@value"];
          const datatype = item["@type"] || null;
          if (datatype === "@json") {
            object.value = jsonCanonicalize(value);
            object.datatype.value = RDF_JSON_LITERAL;
          } else if (types.isBoolean(value)) {
            object.value = value.toString();
            object.datatype.value = datatype || XSD_BOOLEAN;
          } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {
            if (!types.isDouble(value)) {
              value = parseFloat(value);
            }
            object.value = value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
            object.datatype.value = datatype || XSD_DOUBLE;
          } else if (types.isNumber(value)) {
            object.value = value.toFixed(0);
            object.datatype.value = datatype || XSD_INTEGER;
          } else if (rdfDirection === "i18n-datatype" && "@direction" in item) {
            const datatype2 = "https://www.w3.org/ns/i18n#" + (item["@language"] || "") + `_${item["@direction"]}`;
            object.datatype.value = datatype2;
            object.value = value;
          } else if ("@language" in item) {
            object.value = value;
            object.datatype.value = datatype || RDF_LANGSTRING;
            object.language = item["@language"];
          } else {
            object.value = value;
            object.datatype.value = datatype || XSD_STRING;
          }
        } else if (graphTypes.isList(item)) {
          const _list = _listToRDF(item["@list"], issuer, dataset, graphTerm, rdfDirection);
          object.termType = _list.termType;
          object.value = _list.value;
        } else {
          const id = types.isObject(item) ? item["@id"] : item;
          object.termType = id.startsWith("_:") ? "BlankNode" : "NamedNode";
          object.value = id;
        }
        if (object.termType === "NamedNode" && !_isAbsoluteIri(object.value)) {
          return null;
        }
        return object;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/frame.js
  var require_frame = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/frame.js"(exports, module) {
      "use strict";
      var { isKeyword } = require_context();
      var graphTypes = require_graphTypes();
      var types = require_types();
      var util = require_util2();
      var url = require_url();
      var JsonLdError = require_JsonLdError();
      var {
        createNodeMap: _createNodeMap,
        mergeNodeMapGraphs: _mergeNodeMapGraphs
      } = require_nodeMap();
      var api = {};
      module.exports = api;
      api.frameMergedOrDefault = (input, frame, options) => {
        const state = {
          options,
          embedded: false,
          graph: "@default",
          graphMap: { "@default": {} },
          subjectStack: [],
          link: {},
          bnodeMap: {}
        };
        const issuer = new util.IdentifierIssuer("_:b");
        _createNodeMap(input, state.graphMap, "@default", issuer);
        if (options.merged) {
          state.graphMap["@merged"] = _mergeNodeMapGraphs(state.graphMap);
          state.graph = "@merged";
        }
        state.subjects = state.graphMap[state.graph];
        const framed = [];
        api.frame(state, Object.keys(state.subjects).sort(), frame, framed);
        if (options.pruneBlankNodeIdentifiers) {
          options.bnodesToClear = Object.keys(state.bnodeMap).filter((id) => state.bnodeMap[id].length === 1);
        }
        options.link = {};
        return _cleanupPreserve(framed, options);
      };
      api.frame = (state, subjects, frame, parent, property = null) => {
        _validateFrame(frame);
        frame = frame[0];
        const options = state.options;
        const flags = {
          embed: _getFrameFlag(frame, options, "embed"),
          explicit: _getFrameFlag(frame, options, "explicit"),
          requireAll: _getFrameFlag(frame, options, "requireAll")
        };
        if (!state.link.hasOwnProperty(state.graph)) {
          state.link[state.graph] = {};
        }
        const link = state.link[state.graph];
        const matches = _filterSubjects(state, subjects, frame, flags);
        const ids = Object.keys(matches).sort();
        for (const id of ids) {
          const subject = matches[id];
          if (property === null) {
            state.uniqueEmbeds = { [state.graph]: {} };
          } else {
            state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
          }
          if (flags.embed === "@link" && id in link) {
            _addFrameOutput(parent, property, link[id]);
            continue;
          }
          const output = { "@id": id };
          if (id.indexOf("_:") === 0) {
            util.addValue(state.bnodeMap, id, output, { propertyIsArray: true });
          }
          link[id] = output;
          if ((flags.embed === "@first" || flags.embed === "@last") && state.is11) {
            throw new JsonLdError("Invalid JSON-LD syntax; invalid value of @embed.", "jsonld.SyntaxError", { code: "invalid @embed value", frame });
          }
          if (!state.embedded && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
            continue;
          }
          if (state.embedded && (flags.embed === "@never" || _createsCircularReference(subject, state.graph, state.subjectStack))) {
            _addFrameOutput(parent, property, output);
            continue;
          }
          if (state.embedded && (flags.embed == "@first" || flags.embed == "@once") && state.uniqueEmbeds[state.graph].hasOwnProperty(id)) {
            _addFrameOutput(parent, property, output);
            continue;
          }
          if (flags.embed === "@last") {
            if (id in state.uniqueEmbeds[state.graph]) {
              _removeEmbed(state, id);
            }
          }
          state.uniqueEmbeds[state.graph][id] = { parent, property };
          state.subjectStack.push({ subject, graph: state.graph });
          if (id in state.graphMap) {
            let recurse = false;
            let subframe = null;
            if (!("@graph" in frame)) {
              recurse = state.graph !== "@merged";
              subframe = {};
            } else {
              subframe = frame["@graph"][0];
              recurse = !(id === "@merged" || id === "@default");
              if (!types.isObject(subframe)) {
                subframe = {};
              }
            }
            if (recurse) {
              api.frame({ ...state, graph: id, embedded: false }, Object.keys(state.graphMap[id]).sort(), [subframe], output, "@graph");
            }
          }
          if ("@included" in frame) {
            api.frame({ ...state, embedded: false }, subjects, frame["@included"], output, "@included");
          }
          for (const prop of Object.keys(subject).sort()) {
            if (isKeyword(prop)) {
              output[prop] = util.clone(subject[prop]);
              if (prop === "@type") {
                for (const type of subject["@type"]) {
                  if (type.indexOf("_:") === 0) {
                    util.addValue(state.bnodeMap, type, output, { propertyIsArray: true });
                  }
                }
              }
              continue;
            }
            if (flags.explicit && !(prop in frame)) {
              continue;
            }
            for (const o of subject[prop]) {
              const subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags);
              if (graphTypes.isList(o)) {
                const subframe2 = frame[prop] && frame[prop][0] && frame[prop][0]["@list"] ? frame[prop][0]["@list"] : _createImplicitFrame(flags);
                const list = { "@list": [] };
                _addFrameOutput(output, prop, list);
                const src = o["@list"];
                for (const oo of src) {
                  if (graphTypes.isSubjectReference(oo)) {
                    api.frame({ ...state, embedded: true }, [oo["@id"]], subframe2, list, "@list");
                  } else {
                    _addFrameOutput(list, "@list", util.clone(oo));
                  }
                }
              } else if (graphTypes.isSubjectReference(o)) {
                api.frame({ ...state, embedded: true }, [o["@id"]], subframe, output, prop);
              } else if (_valueMatch(subframe[0], o)) {
                _addFrameOutput(output, prop, util.clone(o));
              }
            }
          }
          for (const prop of Object.keys(frame).sort()) {
            if (prop === "@type") {
              if (!types.isObject(frame[prop][0]) || !("@default" in frame[prop][0])) {
                continue;
              }
            } else if (isKeyword(prop)) {
              continue;
            }
            const next = frame[prop][0] || {};
            const omitDefaultOn = _getFrameFlag(next, options, "omitDefault");
            if (!omitDefaultOn && !(prop in output)) {
              let preserve = "@null";
              if ("@default" in next) {
                preserve = util.clone(next["@default"]);
              }
              if (!types.isArray(preserve)) {
                preserve = [preserve];
              }
              output[prop] = [{ "@preserve": preserve }];
            }
          }
          for (const reverseProp of Object.keys(frame["@reverse"] || {}).sort()) {
            const subframe = frame["@reverse"][reverseProp];
            for (const subject2 of Object.keys(state.subjects)) {
              const nodeValues = util.getValues(state.subjects[subject2], reverseProp);
              if (nodeValues.some((v) => v["@id"] === id)) {
                output["@reverse"] = output["@reverse"] || {};
                util.addValue(output["@reverse"], reverseProp, [], { propertyIsArray: true });
                api.frame({ ...state, embedded: true }, [subject2], subframe, output["@reverse"][reverseProp], property);
              }
            }
          }
          _addFrameOutput(parent, property, output);
          state.subjectStack.pop();
        }
      };
      api.cleanupNull = (input, options) => {
        if (types.isArray(input)) {
          const noNulls = input.map((v) => api.cleanupNull(v, options));
          return noNulls.filter((v) => v);
        }
        if (input === "@null") {
          return null;
        }
        if (types.isObject(input)) {
          if ("@id" in input) {
            const id = input["@id"];
            if (options.link.hasOwnProperty(id)) {
              const idx = options.link[id].indexOf(input);
              if (idx !== -1) {
                return options.link[id][idx];
              }
              options.link[id].push(input);
            } else {
              options.link[id] = [input];
            }
          }
          for (const key in input) {
            input[key] = api.cleanupNull(input[key], options);
          }
        }
        return input;
      };
      function _createImplicitFrame(flags) {
        const frame = {};
        for (const key in flags) {
          if (flags[key] !== void 0) {
            frame["@" + key] = [flags[key]];
          }
        }
        return [frame];
      }
      function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
        for (let i = subjectStack.length - 1; i >= 0; --i) {
          const subject = subjectStack[i];
          if (subject.graph === graph && subject.subject["@id"] === subjectToEmbed["@id"]) {
            return true;
          }
        }
        return false;
      }
      function _getFrameFlag(frame, options, name) {
        const flag = "@" + name;
        let rval = flag in frame ? frame[flag][0] : options[name];
        if (name === "embed") {
          if (rval === true) {
            rval = "@once";
          } else if (rval === false) {
            rval = "@never";
          } else if (rval !== "@always" && rval !== "@never" && rval !== "@link" && rval !== "@first" && rval !== "@last" && rval !== "@once") {
            throw new JsonLdError("Invalid JSON-LD syntax; invalid value of @embed.", "jsonld.SyntaxError", { code: "invalid @embed value", frame });
          }
        }
        return rval;
      }
      function _validateFrame(frame) {
        if (!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {
          throw new JsonLdError("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.", "jsonld.SyntaxError", { frame });
        }
        if ("@id" in frame[0]) {
          for (const id of util.asArray(frame[0]["@id"])) {
            if (!(types.isObject(id) || url.isAbsolute(id)) || types.isString(id) && id.indexOf("_:") === 0) {
              throw new JsonLdError("Invalid JSON-LD syntax; invalid @id in frame.", "jsonld.SyntaxError", { code: "invalid frame", frame });
            }
          }
        }
        if ("@type" in frame[0]) {
          for (const type of util.asArray(frame[0]["@type"])) {
            if (!(types.isObject(type) || url.isAbsolute(type)) || types.isString(type) && type.indexOf("_:") === 0) {
              throw new JsonLdError("Invalid JSON-LD syntax; invalid @type in frame.", "jsonld.SyntaxError", { code: "invalid frame", frame });
            }
          }
        }
      }
      function _filterSubjects(state, subjects, frame, flags) {
        const rval = {};
        for (const id of subjects) {
          const subject = state.graphMap[state.graph][id];
          if (_filterSubject(state, subject, frame, flags)) {
            rval[id] = subject;
          }
        }
        return rval;
      }
      function _filterSubject(state, subject, frame, flags) {
        let wildcard = true;
        let matchesSome = false;
        for (const key in frame) {
          let matchThis = false;
          const nodeValues = util.getValues(subject, key);
          const isEmpty = util.getValues(frame, key).length === 0;
          if (key === "@id") {
            if (types.isEmptyObject(frame["@id"][0] || {})) {
              matchThis = true;
            } else if (frame["@id"].length >= 0) {
              matchThis = frame["@id"].includes(nodeValues[0]);
            }
            if (!flags.requireAll) {
              return matchThis;
            }
          } else if (key === "@type") {
            wildcard = false;
            if (isEmpty) {
              if (nodeValues.length > 0) {
                return false;
              }
              matchThis = true;
            } else if (frame["@type"].length === 1 && types.isEmptyObject(frame["@type"][0])) {
              matchThis = nodeValues.length > 0;
            } else {
              for (const type of frame["@type"]) {
                if (types.isObject(type) && "@default" in type) {
                  matchThis = true;
                } else {
                  matchThis = matchThis || nodeValues.some((tt) => tt === type);
                }
              }
            }
            if (!flags.requireAll) {
              return matchThis;
            }
          } else if (isKeyword(key)) {
            continue;
          } else {
            const thisFrame = util.getValues(frame, key)[0];
            let hasDefault = false;
            if (thisFrame) {
              _validateFrame([thisFrame]);
              hasDefault = "@default" in thisFrame;
            }
            wildcard = false;
            if (nodeValues.length === 0 && hasDefault) {
              continue;
            }
            if (nodeValues.length > 0 && isEmpty) {
              return false;
            }
            if (thisFrame === void 0) {
              if (nodeValues.length > 0) {
                return false;
              }
              matchThis = true;
            } else {
              if (graphTypes.isList(thisFrame)) {
                const listValue = thisFrame["@list"][0];
                if (graphTypes.isList(nodeValues[0])) {
                  const nodeListValues = nodeValues[0]["@list"];
                  if (graphTypes.isValue(listValue)) {
                    matchThis = nodeListValues.some((lv) => _valueMatch(listValue, lv));
                  } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                    matchThis = nodeListValues.some((lv) => _nodeMatch(state, listValue, lv, flags));
                  }
                }
              } else if (graphTypes.isValue(thisFrame)) {
                matchThis = nodeValues.some((nv) => _valueMatch(thisFrame, nv));
              } else if (graphTypes.isSubjectReference(thisFrame)) {
                matchThis = nodeValues.some((nv) => _nodeMatch(state, thisFrame, nv, flags));
              } else if (types.isObject(thisFrame)) {
                matchThis = nodeValues.length > 0;
              } else {
                matchThis = false;
              }
            }
          }
          if (!matchThis && flags.requireAll) {
            return false;
          }
          matchesSome = matchesSome || matchThis;
        }
        return wildcard || matchesSome;
      }
      function _removeEmbed(state, id) {
        const embeds = state.uniqueEmbeds[state.graph];
        const embed = embeds[id];
        const parent = embed.parent;
        const property = embed.property;
        const subject = { "@id": id };
        if (types.isArray(parent)) {
          for (let i = 0; i < parent.length; ++i) {
            if (util.compareValues(parent[i], subject)) {
              parent[i] = subject;
              break;
            }
          }
        } else {
          const useArray = types.isArray(parent[property]);
          util.removeValue(parent, property, subject, { propertyIsArray: useArray });
          util.addValue(parent, property, subject, { propertyIsArray: useArray });
        }
        const removeDependents = (id2) => {
          const ids = Object.keys(embeds);
          for (const next of ids) {
            if (next in embeds && types.isObject(embeds[next].parent) && embeds[next].parent["@id"] === id2) {
              delete embeds[next];
              removeDependents(next);
            }
          }
        };
        removeDependents(id);
      }
      function _cleanupPreserve(input, options) {
        if (types.isArray(input)) {
          return input.map((value) => _cleanupPreserve(value, options));
        }
        if (types.isObject(input)) {
          if ("@preserve" in input) {
            return input["@preserve"][0];
          }
          if (graphTypes.isValue(input)) {
            return input;
          }
          if (graphTypes.isList(input)) {
            input["@list"] = _cleanupPreserve(input["@list"], options);
            return input;
          }
          if ("@id" in input) {
            const id = input["@id"];
            if (options.link.hasOwnProperty(id)) {
              const idx = options.link[id].indexOf(input);
              if (idx !== -1) {
                return options.link[id][idx];
              }
              options.link[id].push(input);
            } else {
              options.link[id] = [input];
            }
          }
          for (const prop in input) {
            if (prop === "@id" && options.bnodesToClear.includes(input[prop])) {
              delete input["@id"];
              continue;
            }
            input[prop] = _cleanupPreserve(input[prop], options);
          }
        }
        return input;
      }
      function _addFrameOutput(parent, property, output) {
        if (types.isObject(parent)) {
          util.addValue(parent, property, output, { propertyIsArray: true });
        } else {
          parent.push(output);
        }
      }
      function _nodeMatch(state, pattern, value, flags) {
        if (!("@id" in value)) {
          return false;
        }
        const nodeObject = state.subjects[value["@id"]];
        return nodeObject && _filterSubject(state, nodeObject, pattern, flags);
      }
      function _valueMatch(pattern, value) {
        const v1 = value["@value"];
        const t1 = value["@type"];
        const l1 = value["@language"];
        const v2 = pattern["@value"] ? types.isArray(pattern["@value"]) ? pattern["@value"] : [pattern["@value"]] : [];
        const t2 = pattern["@type"] ? types.isArray(pattern["@type"]) ? pattern["@type"] : [pattern["@type"]] : [];
        const l2 = pattern["@language"] ? types.isArray(pattern["@language"]) ? pattern["@language"] : [pattern["@language"]] : [];
        if (v2.length === 0 && t2.length === 0 && l2.length === 0) {
          return true;
        }
        if (!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {
          return false;
        }
        if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types.isEmptyObject(t2[0]))) {
          return false;
        }
        if (!(!l1 && l2.length === 0 || l2.includes(l1) || l1 && types.isEmptyObject(l2[0]))) {
          return false;
        }
        return true;
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/compact.js
  var require_compact = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/compact.js"(exports, module) {
      "use strict";
      var JsonLdError = require_JsonLdError();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString,
        isUndefined: _isUndefined
      } = require_types();
      var {
        isList: _isList,
        isValue: _isValue,
        isGraph: _isGraph,
        isSimpleGraph: _isSimpleGraph,
        isSubjectReference: _isSubjectReference
      } = require_graphTypes();
      var {
        expandIri: _expandIri,
        getContextValue: _getContextValue,
        isKeyword: _isKeyword,
        process: _processContext,
        processingMode: _processingMode
      } = require_context();
      var {
        removeBase: _removeBase,
        prependBase: _prependBase
      } = require_url();
      var {
        addValue: _addValue,
        asArray: _asArray,
        compareShortestLeast: _compareShortestLeast
      } = require_util2();
      var api = {};
      module.exports = api;
      api.compact = async ({
        activeCtx,
        activeProperty = null,
        element,
        options = {},
        compactionMap = () => void 0
      }) => {
        if (_isArray(element)) {
          let rval = [];
          for (let i = 0; i < element.length; ++i) {
            let compacted = await api.compact({
              activeCtx,
              activeProperty,
              element: element[i],
              options,
              compactionMap
            });
            if (compacted === null) {
              compacted = await compactionMap({
                unmappedValue: element[i],
                activeCtx,
                activeProperty,
                parent: element,
                index: i,
                options
              });
              if (compacted === void 0) {
                continue;
              }
            }
            rval.push(compacted);
          }
          if (options.compactArrays && rval.length === 1) {
            const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
            if (container.length === 0) {
              rval = rval[0];
            }
          }
          return rval;
        }
        const ctx = _getContextValue(activeCtx, activeProperty, "@context");
        if (!_isUndefined(ctx)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: ctx,
            propagate: true,
            overrideProtected: true,
            options
          });
        }
        if (_isObject(element)) {
          if (options.link && "@id" in element && options.link.hasOwnProperty(element["@id"])) {
            const linked = options.link[element["@id"]];
            for (let i = 0; i < linked.length; ++i) {
              if (linked[i].expanded === element) {
                return linked[i].compacted;
              }
            }
          }
          if (_isValue(element) || _isSubjectReference(element)) {
            const rval2 = api.compactValue({ activeCtx, activeProperty, value: element, options });
            if (options.link && _isSubjectReference(element)) {
              if (!options.link.hasOwnProperty(element["@id"])) {
                options.link[element["@id"]] = [];
              }
              options.link[element["@id"]].push({ expanded: element, compacted: rval2 });
            }
            return rval2;
          }
          if (_isList(element)) {
            const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
            if (container.includes("@list")) {
              return api.compact({
                activeCtx,
                activeProperty,
                element: element["@list"],
                options,
                compactionMap
              });
            }
          }
          const insideReverse = activeProperty === "@reverse";
          const rval = {};
          const inputCtx = activeCtx;
          if (!_isValue(element) && !_isSubjectReference(element)) {
            activeCtx = activeCtx.revertToPreviousContext();
          }
          const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, "@context");
          if (!_isUndefined(propertyScopedCtx)) {
            activeCtx = await _processContext({
              activeCtx,
              localCtx: propertyScopedCtx,
              propagate: true,
              overrideProtected: true,
              options
            });
          }
          if (options.link && "@id" in element) {
            if (!options.link.hasOwnProperty(element["@id"])) {
              options.link[element["@id"]] = [];
            }
            options.link[element["@id"]].push({ expanded: element, compacted: rval });
          }
          let types = element["@type"] || [];
          if (types.length > 1) {
            types = Array.from(types).sort();
          }
          const typeContext = activeCtx;
          for (const type of types) {
            const compactedType = api.compactIri({ activeCtx: typeContext, iri: type, relativeTo: { vocab: true } });
            const ctx2 = _getContextValue(inputCtx, compactedType, "@context");
            if (!_isUndefined(ctx2)) {
              activeCtx = await _processContext({
                activeCtx,
                localCtx: ctx2,
                options,
                propagate: false
              });
            }
          }
          const keys = Object.keys(element).sort();
          for (const expandedProperty of keys) {
            const expandedValue = element[expandedProperty];
            if (expandedProperty === "@id") {
              let compactedValue = _asArray(expandedValue).map((expandedIri) => api.compactIri({
                activeCtx,
                iri: expandedIri,
                relativeTo: { vocab: false },
                base: options.base
              }));
              if (compactedValue.length === 1) {
                compactedValue = compactedValue[0];
              }
              const alias = api.compactIri({ activeCtx, iri: "@id", relativeTo: { vocab: true } });
              rval[alias] = compactedValue;
              continue;
            }
            if (expandedProperty === "@type") {
              let compactedValue = _asArray(expandedValue).map((expandedIri) => api.compactIri({
                activeCtx: inputCtx,
                iri: expandedIri,
                relativeTo: { vocab: true }
              }));
              if (compactedValue.length === 1) {
                compactedValue = compactedValue[0];
              }
              const alias = api.compactIri({ activeCtx, iri: "@type", relativeTo: { vocab: true } });
              const container = _getContextValue(activeCtx, alias, "@container") || [];
              const typeAsSet = container.includes("@set") && _processingMode(activeCtx, 1.1);
              const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;
              _addValue(rval, alias, compactedValue, { propertyIsArray: isArray });
              continue;
            }
            if (expandedProperty === "@reverse") {
              const compactedValue = await api.compact({
                activeCtx,
                activeProperty: "@reverse",
                element: expandedValue,
                options,
                compactionMap
              });
              for (const compactedProperty in compactedValue) {
                if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
                  const value = compactedValue[compactedProperty];
                  const container = _getContextValue(activeCtx, compactedProperty, "@container") || [];
                  const useArray = container.includes("@set") || !options.compactArrays;
                  _addValue(rval, compactedProperty, value, { propertyIsArray: useArray });
                  delete compactedValue[compactedProperty];
                }
              }
              if (Object.keys(compactedValue).length > 0) {
                const alias = api.compactIri({
                  activeCtx,
                  iri: expandedProperty,
                  relativeTo: { vocab: true }
                });
                _addValue(rval, alias, compactedValue);
              }
              continue;
            }
            if (expandedProperty === "@preserve") {
              const compactedValue = await api.compact({
                activeCtx,
                activeProperty,
                element: expandedValue,
                options,
                compactionMap
              });
              if (!(_isArray(compactedValue) && compactedValue.length === 0)) {
                _addValue(rval, expandedProperty, compactedValue);
              }
              continue;
            }
            if (expandedProperty === "@index") {
              const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
              if (container.includes("@index")) {
                continue;
              }
              const alias = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                relativeTo: { vocab: true }
              });
              _addValue(rval, alias, expandedValue);
              continue;
            }
            if (expandedProperty !== "@graph" && expandedProperty !== "@list" && expandedProperty !== "@included" && _isKeyword(expandedProperty)) {
              const alias = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                relativeTo: { vocab: true }
              });
              _addValue(rval, alias, expandedValue);
              continue;
            }
            if (!_isArray(expandedValue)) {
              throw new JsonLdError("JSON-LD expansion error; expanded value must be an array.", "jsonld.SyntaxError");
            }
            if (expandedValue.length === 0) {
              const itemActiveProperty = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                value: expandedValue,
                relativeTo: { vocab: true },
                reverse: insideReverse
              });
              const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
              let nestResult = rval;
              if (nestProperty) {
                _checkNestProperty(activeCtx, nestProperty, options);
                if (!_isObject(rval[nestProperty])) {
                  rval[nestProperty] = {};
                }
                nestResult = rval[nestProperty];
              }
              _addValue(nestResult, itemActiveProperty, expandedValue, {
                propertyIsArray: true
              });
            }
            for (const expandedItem of expandedValue) {
              const itemActiveProperty = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                value: expandedItem,
                relativeTo: { vocab: true },
                reverse: insideReverse
              });
              const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
              let nestResult = rval;
              if (nestProperty) {
                _checkNestProperty(activeCtx, nestProperty, options);
                if (!_isObject(rval[nestProperty])) {
                  rval[nestProperty] = {};
                }
                nestResult = rval[nestProperty];
              }
              const container = _getContextValue(activeCtx, itemActiveProperty, "@container") || [];
              const isGraph = _isGraph(expandedItem);
              const isList = _isList(expandedItem);
              let inner;
              if (isList) {
                inner = expandedItem["@list"];
              } else if (isGraph) {
                inner = expandedItem["@graph"];
              }
              let compactedItem = await api.compact({
                activeCtx,
                activeProperty: itemActiveProperty,
                element: isList || isGraph ? inner : expandedItem,
                options,
                compactionMap
              });
              if (isList) {
                if (!_isArray(compactedItem)) {
                  compactedItem = [compactedItem];
                }
                if (!container.includes("@list")) {
                  compactedItem = {
                    [api.compactIri({
                      activeCtx,
                      iri: "@list",
                      relativeTo: { vocab: true }
                    })]: compactedItem
                  };
                  if ("@index" in expandedItem) {
                    compactedItem[api.compactIri({
                      activeCtx,
                      iri: "@index",
                      relativeTo: { vocab: true }
                    })] = expandedItem["@index"];
                  }
                } else {
                  _addValue(nestResult, itemActiveProperty, compactedItem, {
                    valueIsArray: true,
                    allowDuplicate: true
                  });
                  continue;
                }
              }
              if (isGraph) {
                if (container.includes("@graph") && (container.includes("@id") || container.includes("@index") && _isSimpleGraph(expandedItem))) {
                  let mapObject;
                  if (nestResult.hasOwnProperty(itemActiveProperty)) {
                    mapObject = nestResult[itemActiveProperty];
                  } else {
                    nestResult[itemActiveProperty] = mapObject = {};
                  }
                  const key = (container.includes("@id") ? expandedItem["@id"] : expandedItem["@index"]) || api.compactIri({
                    activeCtx,
                    iri: "@none",
                    relativeTo: { vocab: true }
                  });
                  _addValue(mapObject, key, compactedItem, {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  });
                } else if (container.includes("@graph") && _isSimpleGraph(expandedItem)) {
                  if (_isArray(compactedItem) && compactedItem.length > 1) {
                    compactedItem = { "@included": compactedItem };
                  }
                  _addValue(nestResult, itemActiveProperty, compactedItem, {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  });
                } else {
                  if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                    compactedItem = compactedItem[0];
                  }
                  compactedItem = {
                    [api.compactIri({
                      activeCtx,
                      iri: "@graph",
                      relativeTo: { vocab: true }
                    })]: compactedItem
                  };
                  if ("@id" in expandedItem) {
                    compactedItem[api.compactIri({
                      activeCtx,
                      iri: "@id",
                      relativeTo: { vocab: true }
                    })] = expandedItem["@id"];
                  }
                  if ("@index" in expandedItem) {
                    compactedItem[api.compactIri({
                      activeCtx,
                      iri: "@index",
                      relativeTo: { vocab: true }
                    })] = expandedItem["@index"];
                  }
                  _addValue(nestResult, itemActiveProperty, compactedItem, {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  });
                }
              } else if (container.includes("@language") || container.includes("@index") || container.includes("@id") || container.includes("@type")) {
                let mapObject;
                if (nestResult.hasOwnProperty(itemActiveProperty)) {
                  mapObject = nestResult[itemActiveProperty];
                } else {
                  nestResult[itemActiveProperty] = mapObject = {};
                }
                let key;
                if (container.includes("@language")) {
                  if (_isValue(compactedItem)) {
                    compactedItem = compactedItem["@value"];
                  }
                  key = expandedItem["@language"];
                } else if (container.includes("@index")) {
                  const indexKey = _getContextValue(activeCtx, itemActiveProperty, "@index") || "@index";
                  const containerKey = api.compactIri({ activeCtx, iri: indexKey, relativeTo: { vocab: true } });
                  if (indexKey === "@index") {
                    key = expandedItem["@index"];
                    delete compactedItem[containerKey];
                  } else {
                    let others;
                    [key, ...others] = _asArray(compactedItem[indexKey] || []);
                    if (!_isString(key)) {
                      key = null;
                    } else {
                      switch (others.length) {
                        case 0:
                          delete compactedItem[indexKey];
                          break;
                        case 1:
                          compactedItem[indexKey] = others[0];
                          break;
                        default:
                          compactedItem[indexKey] = others;
                          break;
                      }
                    }
                  }
                } else if (container.includes("@id")) {
                  const idKey = api.compactIri({
                    activeCtx,
                    iri: "@id",
                    relativeTo: { vocab: true }
                  });
                  key = compactedItem[idKey];
                  delete compactedItem[idKey];
                } else if (container.includes("@type")) {
                  const typeKey = api.compactIri({
                    activeCtx,
                    iri: "@type",
                    relativeTo: { vocab: true }
                  });
                  let types2;
                  [key, ...types2] = _asArray(compactedItem[typeKey] || []);
                  switch (types2.length) {
                    case 0:
                      delete compactedItem[typeKey];
                      break;
                    case 1:
                      compactedItem[typeKey] = types2[0];
                      break;
                    default:
                      compactedItem[typeKey] = types2;
                      break;
                  }
                  if (Object.keys(compactedItem).length === 1 && "@id" in expandedItem) {
                    compactedItem = await api.compact({
                      activeCtx,
                      activeProperty: itemActiveProperty,
                      element: { "@id": expandedItem["@id"] },
                      options,
                      compactionMap
                    });
                  }
                }
                if (!key) {
                  key = api.compactIri({
                    activeCtx,
                    iri: "@none",
                    relativeTo: { vocab: true }
                  });
                }
                _addValue(mapObject, key, compactedItem, {
                  propertyIsArray: container.includes("@set")
                });
              } else {
                const isArray = !options.compactArrays || container.includes("@set") || container.includes("@list") || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === "@list" || expandedProperty === "@graph";
                _addValue(nestResult, itemActiveProperty, compactedItem, { propertyIsArray: isArray });
              }
            }
          }
          return rval;
        }
        return element;
      };
      api.compactIri = ({
        activeCtx,
        iri,
        value = null,
        relativeTo = { vocab: false },
        reverse = false,
        base = null
      }) => {
        if (iri === null) {
          return iri;
        }
        if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
          activeCtx = activeCtx.previousContext;
        }
        const inverseCtx = activeCtx.getInverse();
        if (_isKeyword(iri) && iri in inverseCtx && "@none" in inverseCtx[iri] && "@type" in inverseCtx[iri]["@none"] && "@none" in inverseCtx[iri]["@none"]["@type"]) {
          return inverseCtx[iri]["@none"]["@type"]["@none"];
        }
        if (relativeTo.vocab && iri in inverseCtx) {
          const defaultLanguage = activeCtx["@language"] || "@none";
          const containers = [];
          if (_isObject(value) && "@index" in value && !("@graph" in value)) {
            containers.push("@index", "@index@set");
          }
          if (_isObject(value) && "@preserve" in value) {
            value = value["@preserve"][0];
          }
          if (_isGraph(value)) {
            if ("@index" in value) {
              containers.push("@graph@index", "@graph@index@set", "@index", "@index@set");
            }
            if ("@id" in value) {
              containers.push("@graph@id", "@graph@id@set");
            }
            containers.push("@graph", "@graph@set", "@set");
            if (!("@index" in value)) {
              containers.push("@graph@index", "@graph@index@set", "@index", "@index@set");
            }
            if (!("@id" in value)) {
              containers.push("@graph@id", "@graph@id@set");
            }
          } else if (_isObject(value) && !_isValue(value)) {
            containers.push("@id", "@id@set", "@type", "@set@type");
          }
          let typeOrLanguage = "@language";
          let typeOrLanguageValue = "@null";
          if (reverse) {
            typeOrLanguage = "@type";
            typeOrLanguageValue = "@reverse";
            containers.push("@set");
          } else if (_isList(value)) {
            if (!("@index" in value)) {
              containers.push("@list");
            }
            const list = value["@list"];
            if (list.length === 0) {
              typeOrLanguage = "@any";
              typeOrLanguageValue = "@none";
            } else {
              let commonLanguage = list.length === 0 ? defaultLanguage : null;
              let commonType = null;
              for (let i = 0; i < list.length; ++i) {
                const item = list[i];
                let itemLanguage = "@none";
                let itemType = "@none";
                if (_isValue(item)) {
                  if ("@direction" in item) {
                    const lang = (item["@language"] || "").toLowerCase();
                    const dir = item["@direction"];
                    itemLanguage = `${lang}_${dir}`;
                  } else if ("@language" in item) {
                    itemLanguage = item["@language"].toLowerCase();
                  } else if ("@type" in item) {
                    itemType = item["@type"];
                  } else {
                    itemLanguage = "@null";
                  }
                } else {
                  itemType = "@id";
                }
                if (commonLanguage === null) {
                  commonLanguage = itemLanguage;
                } else if (itemLanguage !== commonLanguage && _isValue(item)) {
                  commonLanguage = "@none";
                }
                if (commonType === null) {
                  commonType = itemType;
                } else if (itemType !== commonType) {
                  commonType = "@none";
                }
                if (commonLanguage === "@none" && commonType === "@none") {
                  break;
                }
              }
              commonLanguage = commonLanguage || "@none";
              commonType = commonType || "@none";
              if (commonType !== "@none") {
                typeOrLanguage = "@type";
                typeOrLanguageValue = commonType;
              } else {
                typeOrLanguageValue = commonLanguage;
              }
            }
          } else {
            if (_isValue(value)) {
              if ("@language" in value && !("@index" in value)) {
                containers.push("@language", "@language@set");
                typeOrLanguageValue = value["@language"];
                const dir = value["@direction"];
                if (dir) {
                  typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;
                }
              } else if ("@direction" in value && !("@index" in value)) {
                typeOrLanguageValue = `_${value["@direction"]}`;
              } else if ("@type" in value) {
                typeOrLanguage = "@type";
                typeOrLanguageValue = value["@type"];
              }
            } else {
              typeOrLanguage = "@type";
              typeOrLanguageValue = "@id";
            }
            containers.push("@set");
          }
          containers.push("@none");
          if (_isObject(value) && !("@index" in value)) {
            containers.push("@index", "@index@set");
          }
          if (_isValue(value) && Object.keys(value).length === 1) {
            containers.push("@language", "@language@set");
          }
          const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);
          if (term !== null) {
            return term;
          }
        }
        if (relativeTo.vocab) {
          if ("@vocab" in activeCtx) {
            const vocab = activeCtx["@vocab"];
            if (iri.indexOf(vocab) === 0 && iri !== vocab) {
              const suffix = iri.substr(vocab.length);
              if (!activeCtx.mappings.has(suffix)) {
                return suffix;
              }
            }
          }
        }
        let choice = null;
        const partialMatches = [];
        let iriMap = activeCtx.fastCurieMap;
        const maxPartialLength = iri.length - 1;
        for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {
          iriMap = iriMap[iri[i]];
          if ("" in iriMap) {
            partialMatches.push(iriMap[""][0]);
          }
        }
        for (let i = partialMatches.length - 1; i >= 0; --i) {
          const entry = partialMatches[i];
          const terms = entry.terms;
          for (const term of terms) {
            const curie = term + ":" + iri.substr(entry.iri.length);
            const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)["@id"] === iri);
            if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
              choice = curie;
            }
          }
        }
        if (choice !== null) {
          return choice;
        }
        for (const [term, td] of activeCtx.mappings) {
          if (td && td._prefix && iri.startsWith(term + ":")) {
            throw new JsonLdError(`Absolute IRI "${iri}" confused with prefix "${term}".`, "jsonld.SyntaxError", { code: "IRI confused with prefix", context: activeCtx });
          }
        }
        if (!relativeTo.vocab) {
          if ("@base" in activeCtx) {
            if (!activeCtx["@base"]) {
              return iri;
            } else {
              return _removeBase(_prependBase(base, activeCtx["@base"]), iri);
            }
          } else {
            return _removeBase(base, iri);
          }
        }
        return iri;
      };
      api.compactValue = ({ activeCtx, activeProperty, value, options }) => {
        if (_isValue(value)) {
          const type2 = _getContextValue(activeCtx, activeProperty, "@type");
          const language = _getContextValue(activeCtx, activeProperty, "@language");
          const direction = _getContextValue(activeCtx, activeProperty, "@direction");
          const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
          const preserveIndex = "@index" in value && !container.includes("@index");
          if (!preserveIndex && type2 !== "@none") {
            if (value["@type"] === type2) {
              return value["@value"];
            }
            if ("@language" in value && value["@language"] === language && "@direction" in value && value["@direction"] === direction) {
              return value["@value"];
            }
            if ("@language" in value && value["@language"] === language) {
              return value["@value"];
            }
            if ("@direction" in value && value["@direction"] === direction) {
              return value["@value"];
            }
          }
          const keyCount = Object.keys(value).length;
          const isValueOnlyKey = keyCount === 1 || keyCount === 2 && "@index" in value && !preserveIndex;
          const hasDefaultLanguage = "@language" in activeCtx;
          const isValueString = _isString(value["@value"]);
          const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)["@language"] === null;
          if (isValueOnlyKey && type2 !== "@none" && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
            return value["@value"];
          }
          const rval = {};
          if (preserveIndex) {
            rval[api.compactIri({
              activeCtx,
              iri: "@index",
              relativeTo: { vocab: true }
            })] = value["@index"];
          }
          if ("@type" in value) {
            rval[api.compactIri({
              activeCtx,
              iri: "@type",
              relativeTo: { vocab: true }
            })] = api.compactIri({ activeCtx, iri: value["@type"], relativeTo: { vocab: true } });
          } else if ("@language" in value) {
            rval[api.compactIri({
              activeCtx,
              iri: "@language",
              relativeTo: { vocab: true }
            })] = value["@language"];
          }
          if ("@direction" in value) {
            rval[api.compactIri({
              activeCtx,
              iri: "@direction",
              relativeTo: { vocab: true }
            })] = value["@direction"];
          }
          rval[api.compactIri({
            activeCtx,
            iri: "@value",
            relativeTo: { vocab: true }
          })] = value["@value"];
          return rval;
        }
        const expandedProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
        const type = _getContextValue(activeCtx, activeProperty, "@type");
        const compacted = api.compactIri({
          activeCtx,
          iri: value["@id"],
          relativeTo: { vocab: type === "@vocab" },
          base: options.base
        });
        if (type === "@id" || type === "@vocab" || expandedProperty === "@graph") {
          return compacted;
        }
        return {
          [api.compactIri({
            activeCtx,
            iri: "@id",
            relativeTo: { vocab: true }
          })]: compacted
        };
      };
      function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
        if (typeOrLanguageValue === null) {
          typeOrLanguageValue = "@null";
        }
        const prefs = [];
        if ((typeOrLanguageValue === "@id" || typeOrLanguageValue === "@reverse") && _isObject(value) && "@id" in value) {
          if (typeOrLanguageValue === "@reverse") {
            prefs.push("@reverse");
          }
          const term = api.compactIri({ activeCtx, iri: value["@id"], relativeTo: { vocab: true } });
          if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)["@id"] === value["@id"]) {
            prefs.push.apply(prefs, ["@vocab", "@id"]);
          } else {
            prefs.push.apply(prefs, ["@id", "@vocab"]);
          }
        } else {
          prefs.push(typeOrLanguageValue);
          const langDir = prefs.find((el) => el.includes("_"));
          if (langDir) {
            prefs.push(langDir.replace(/^[^_]+_/, "_"));
          }
        }
        prefs.push("@none");
        const containerMap = activeCtx.inverse[iri];
        for (const container of containers) {
          if (!(container in containerMap)) {
            continue;
          }
          const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
          for (const pref of prefs) {
            if (!(pref in typeOrLanguageValueMap)) {
              continue;
            }
            return typeOrLanguageValueMap[pref];
          }
        }
        return null;
      }
      function _checkNestProperty(activeCtx, nestProperty, options) {
        if (_expandIri(activeCtx, nestProperty, { vocab: true }, options) !== "@nest") {
          throw new JsonLdError("JSON-LD compact error; nested property must have an @nest value resolving to @nest.", "jsonld.SyntaxError", { code: "invalid @nest value" });
        }
      }
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/JsonLdProcessor.js
  var require_JsonLdProcessor = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/JsonLdProcessor.js"(exports, module) {
      "use strict";
      module.exports = (jsonld) => {
        class JsonLdProcessor {
          toString() {
            return "[object JsonLdProcessor]";
          }
        }
        Object.defineProperty(JsonLdProcessor, "prototype", {
          writable: false,
          enumerable: false
        });
        Object.defineProperty(JsonLdProcessor.prototype, "constructor", {
          writable: true,
          enumerable: false,
          configurable: true,
          value: JsonLdProcessor
        });
        JsonLdProcessor.compact = function(input, ctx) {
          if (arguments.length < 2) {
            return Promise.reject(new TypeError("Could not compact, too few arguments."));
          }
          return jsonld.compact(input, ctx);
        };
        JsonLdProcessor.expand = function(input) {
          if (arguments.length < 1) {
            return Promise.reject(new TypeError("Could not expand, too few arguments."));
          }
          return jsonld.expand(input);
        };
        JsonLdProcessor.flatten = function(input) {
          if (arguments.length < 1) {
            return Promise.reject(new TypeError("Could not flatten, too few arguments."));
          }
          return jsonld.flatten(input);
        };
        return JsonLdProcessor;
      };
    }
  });

  // node_modules/jsonld-signatures/node_modules/jsonld/lib/jsonld.js
  var require_jsonld = __commonJS({
    "node_modules/jsonld-signatures/node_modules/jsonld/lib/jsonld.js"(exports, module) {
      var canonize = require_rdf_canonize();
      var platform = require_platform_browser();
      var util = require_util2();
      var ContextResolver = require_ContextResolver();
      var IdentifierIssuer = util.IdentifierIssuer;
      var JsonLdError = require_JsonLdError();
      var LRU = require_lru_cache();
      var NQuads = require_NQuads2();
      var { expand: _expand } = require_expand();
      var { flatten: _flatten } = require_flatten();
      var { fromRDF: _fromRDF } = require_fromRdf();
      var { toRDF: _toRDF } = require_toRdf();
      var {
        frameMergedOrDefault: _frameMergedOrDefault,
        cleanupNull: _cleanupNull
      } = require_frame();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString
      } = require_types();
      var {
        isSubjectReference: _isSubjectReference
      } = require_graphTypes();
      var {
        expandIri: _expandIri,
        getInitialContext: _getInitialContext,
        process: _processContext,
        processingMode: _processingMode
      } = require_context();
      var {
        compact: _compact,
        compactIri: _compactIri
      } = require_compact();
      var {
        createNodeMap: _createNodeMap,
        createMergedNodeMap: _createMergedNodeMap,
        mergeNodeMaps: _mergeNodeMaps
      } = require_nodeMap();
      var wrapper = function(jsonld) {
        const _rdfParsers = {};
        const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;
        const _resolvedContextCache = new LRU({ max: RESOLVED_CONTEXT_CACHE_MAX_SIZE });
        jsonld.compact = async function(input, ctx, options) {
          if (arguments.length < 2) {
            throw new TypeError("Could not compact, too few arguments.");
          }
          if (ctx === null) {
            throw new JsonLdError("The compaction context must not be null.", "jsonld.CompactError", { code: "invalid local context" });
          }
          if (input === null) {
            return null;
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            compactArrays: true,
            compactToRelative: true,
            graph: false,
            skipExpansion: false,
            link: false,
            issuer: new IdentifierIssuer("_:b"),
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (options.link) {
            options.skipExpansion = true;
          }
          if (!options.compactToRelative) {
            delete options.base;
          }
          let expanded;
          if (options.skipExpansion) {
            expanded = input;
          } else {
            expanded = await jsonld.expand(input, options);
          }
          const activeCtx = await jsonld.processContext(_getInitialContext(options), ctx, options);
          let compacted = await _compact({
            activeCtx,
            element: expanded,
            options,
            compactionMap: options.compactionMap
          });
          if (options.compactArrays && !options.graph && _isArray(compacted)) {
            if (compacted.length === 1) {
              compacted = compacted[0];
            } else if (compacted.length === 0) {
              compacted = {};
            }
          } else if (options.graph && _isObject(compacted)) {
            compacted = [compacted];
          }
          if (_isObject(ctx) && "@context" in ctx) {
            ctx = ctx["@context"];
          }
          ctx = util.clone(ctx);
          if (!_isArray(ctx)) {
            ctx = [ctx];
          }
          const tmp = ctx;
          ctx = [];
          for (let i = 0; i < tmp.length; ++i) {
            if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {
              ctx.push(tmp[i]);
            }
          }
          const hasContext = ctx.length > 0;
          if (ctx.length === 1) {
            ctx = ctx[0];
          }
          if (_isArray(compacted)) {
            const graphAlias = _compactIri({
              activeCtx,
              iri: "@graph",
              relativeTo: { vocab: true }
            });
            const graph = compacted;
            compacted = {};
            if (hasContext) {
              compacted["@context"] = ctx;
            }
            compacted[graphAlias] = graph;
          } else if (_isObject(compacted) && hasContext) {
            const graph = compacted;
            compacted = { "@context": ctx };
            for (const key in graph) {
              compacted[key] = graph[key];
            }
          }
          return compacted;
        };
        jsonld.expand = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not expand, too few arguments.");
          }
          options = _setDefaults(options, {
            keepFreeFloatingNodes: false,
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (options.expansionMap === false) {
            options.expansionMap = void 0;
          }
          const toResolve = {};
          const contextsToProcess = [];
          if ("expandContext" in options) {
            const expandContext = util.clone(options.expandContext);
            if (_isObject(expandContext) && "@context" in expandContext) {
              toResolve.expandContext = expandContext;
            } else {
              toResolve.expandContext = { "@context": expandContext };
            }
            contextsToProcess.push(toResolve.expandContext);
          }
          let defaultBase;
          if (!_isString(input)) {
            toResolve.input = util.clone(input);
          } else {
            const remoteDoc = await jsonld.get(input, options);
            defaultBase = remoteDoc.documentUrl;
            toResolve.input = remoteDoc.document;
            if (remoteDoc.contextUrl) {
              toResolve.remoteContext = { "@context": remoteDoc.contextUrl };
              contextsToProcess.push(toResolve.remoteContext);
            }
          }
          if (!("base" in options)) {
            options.base = defaultBase || "";
          }
          let activeCtx = _getInitialContext(options);
          for (const localCtx of contextsToProcess) {
            activeCtx = await _processContext({ activeCtx, localCtx, options });
          }
          let expanded = await _expand({
            activeCtx,
            element: toResolve.input,
            options,
            expansionMap: options.expansionMap
          });
          if (_isObject(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
            expanded = expanded["@graph"];
          } else if (expanded === null) {
            expanded = [];
          }
          if (!_isArray(expanded)) {
            expanded = [expanded];
          }
          return expanded;
        };
        jsonld.flatten = async function(input, ctx, options) {
          if (arguments.length < 1) {
            return new TypeError("Could not flatten, too few arguments.");
          }
          if (typeof ctx === "function") {
            ctx = null;
          } else {
            ctx = ctx || null;
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          const expanded = await jsonld.expand(input, options);
          const flattened = _flatten(expanded);
          if (ctx === null) {
            return flattened;
          }
          options.graph = true;
          options.skipExpansion = true;
          const compacted = await jsonld.compact(flattened, ctx, options);
          return compacted;
        };
        jsonld.frame = async function(input, frame, options) {
          if (arguments.length < 2) {
            throw new TypeError("Could not frame, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            embed: "@once",
            explicit: false,
            requireAll: false,
            omitDefault: false,
            bnodesToClear: [],
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (_isString(frame)) {
            const remoteDoc = await jsonld.get(frame, options);
            frame = remoteDoc.document;
            if (remoteDoc.contextUrl) {
              let ctx = frame["@context"];
              if (!ctx) {
                ctx = remoteDoc.contextUrl;
              } else if (_isArray(ctx)) {
                ctx.push(remoteDoc.contextUrl);
              } else {
                ctx = [ctx, remoteDoc.contextUrl];
              }
              frame["@context"] = ctx;
            }
          }
          const frameContext = frame ? frame["@context"] || {} : {};
          const activeCtx = await jsonld.processContext(_getInitialContext(options), frameContext, options);
          if (!options.hasOwnProperty("omitGraph")) {
            options.omitGraph = _processingMode(activeCtx, 1.1);
          }
          if (!options.hasOwnProperty("pruneBlankNodeIdentifiers")) {
            options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);
          }
          const expanded = await jsonld.expand(input, options);
          const opts = { ...options };
          opts.isFrame = true;
          opts.keepFreeFloatingNodes = true;
          const expandedFrame = await jsonld.expand(frame, opts);
          const frameKeys = Object.keys(frame).map((key) => _expandIri(activeCtx, key, { vocab: true }));
          opts.merged = !frameKeys.includes("@graph");
          opts.is11 = _processingMode(activeCtx, 1.1);
          const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
          opts.graph = !options.omitGraph;
          opts.skipExpansion = true;
          opts.link = {};
          opts.framing = true;
          let compacted = await jsonld.compact(framed, frameContext, opts);
          opts.link = {};
          compacted = _cleanupNull(compacted, opts);
          return compacted;
        };
        jsonld.link = async function(input, ctx, options) {
          const frame = {};
          if (ctx) {
            frame["@context"] = ctx;
          }
          frame["@embed"] = "@link";
          return jsonld.frame(input, frame, options);
        };
        jsonld.normalize = jsonld.canonize = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not canonize, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            algorithm: "URDNA2015",
            skipExpansion: false,
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if ("inputFormat" in options) {
            if (options.inputFormat !== "application/n-quads" && options.inputFormat !== "application/nquads") {
              throw new JsonLdError("Unknown canonicalization input format.", "jsonld.CanonizeError");
            }
            const parsedInput = NQuads.parse(input);
            return canonize.canonize(parsedInput, options);
          }
          const opts = { ...options };
          delete opts.format;
          opts.produceGeneralizedRdf = false;
          const dataset = await jsonld.toRDF(input, opts);
          return canonize.canonize(dataset, options);
        };
        jsonld.fromRDF = async function(dataset, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not convert from RDF, too few arguments.");
          }
          options = _setDefaults(options, {
            format: _isString(dataset) ? "application/n-quads" : void 0
          });
          const { format } = options;
          let { rdfParser } = options;
          if (format) {
            rdfParser = rdfParser || _rdfParsers[format];
            if (!rdfParser) {
              throw new JsonLdError("Unknown input format.", "jsonld.UnknownFormat", { format });
            }
          } else {
            rdfParser = () => dataset;
          }
          const parsedDataset = await rdfParser(dataset);
          return _fromRDF(parsedDataset, options);
        };
        jsonld.toRDF = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not convert to RDF, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            skipExpansion: false,
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          let expanded;
          if (options.skipExpansion) {
            expanded = input;
          } else {
            expanded = await jsonld.expand(input, options);
          }
          const dataset = _toRDF(expanded, options);
          if (options.format) {
            if (options.format === "application/n-quads" || options.format === "application/nquads") {
              return NQuads.serialize(dataset);
            }
            throw new JsonLdError("Unknown output format.", "jsonld.UnknownFormat", { format: options.format });
          }
          return dataset;
        };
        jsonld.createNodeMap = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not create node map, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          const expanded = await jsonld.expand(input, options);
          return _createMergedNodeMap(expanded, options);
        };
        jsonld.merge = async function(docs, ctx, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not merge, too few arguments.");
          }
          if (!_isArray(docs)) {
            throw new TypeError('Could not merge, "docs" must be an array.');
          }
          if (typeof ctx === "function") {
            ctx = null;
          } else {
            ctx = ctx || null;
          }
          options = _setDefaults(options, {
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          const expanded = await Promise.all(docs.map((doc) => {
            const opts = { ...options };
            return jsonld.expand(doc, opts);
          }));
          let mergeNodes = true;
          if ("mergeNodes" in options) {
            mergeNodes = options.mergeNodes;
          }
          const issuer = options.issuer || new IdentifierIssuer("_:b");
          const graphs = { "@default": {} };
          for (let i = 0; i < expanded.length; ++i) {
            const doc = util.relabelBlankNodes(expanded[i], {
              issuer: new IdentifierIssuer("_:b" + i + "-")
            });
            const _graphs = mergeNodes || i === 0 ? graphs : { "@default": {} };
            _createNodeMap(doc, _graphs, "@default", issuer);
            if (_graphs !== graphs) {
              for (const graphName in _graphs) {
                const _nodeMap = _graphs[graphName];
                if (!(graphName in graphs)) {
                  graphs[graphName] = _nodeMap;
                  continue;
                }
                const nodeMap = graphs[graphName];
                for (const key in _nodeMap) {
                  if (!(key in nodeMap)) {
                    nodeMap[key] = _nodeMap[key];
                  }
                }
              }
            }
          }
          const defaultGraph = _mergeNodeMaps(graphs);
          const flattened = [];
          const keys = Object.keys(defaultGraph).sort();
          for (let ki = 0; ki < keys.length; ++ki) {
            const node = defaultGraph[keys[ki]];
            if (!_isSubjectReference(node)) {
              flattened.push(node);
            }
          }
          if (ctx === null) {
            return flattened;
          }
          options.graph = true;
          options.skipExpansion = true;
          const compacted = await jsonld.compact(flattened, ctx, options);
          return compacted;
        };
        Object.defineProperty(jsonld, "documentLoader", {
          get: () => jsonld._documentLoader,
          set: (v) => jsonld._documentLoader = v
        });
        jsonld.documentLoader = async (url) => {
          throw new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.", "jsonld.LoadDocumentError", { code: "loading document failed", url });
        };
        jsonld.get = async function(url, options) {
          let load;
          if (typeof options.documentLoader === "function") {
            load = options.documentLoader;
          } else {
            load = jsonld.documentLoader;
          }
          const remoteDoc = await load(url);
          try {
            if (!remoteDoc.document) {
              throw new JsonLdError("No remote document found at the given URL.", "jsonld.NullRemoteDocument");
            }
            if (_isString(remoteDoc.document)) {
              remoteDoc.document = JSON.parse(remoteDoc.document);
            }
          } catch (e) {
            throw new JsonLdError("Could not retrieve a JSON-LD document from the URL.", "jsonld.LoadDocumentError", {
              code: "loading document failed",
              cause: e,
              remoteDoc
            });
          }
          return remoteDoc;
        };
        jsonld.processContext = async function(activeCtx, localCtx, options) {
          options = _setDefaults(options, {
            base: "",
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (localCtx === null) {
            return _getInitialContext(options);
          }
          localCtx = util.clone(localCtx);
          if (!(_isObject(localCtx) && "@context" in localCtx)) {
            localCtx = { "@context": localCtx };
          }
          return _processContext({ activeCtx, localCtx, options });
        };
        jsonld.getContextValue = require_context().getContextValue;
        jsonld.documentLoaders = {};
        jsonld.useDocumentLoader = function(type) {
          if (!(type in jsonld.documentLoaders)) {
            throw new JsonLdError('Unknown document loader type: "' + type + '"', "jsonld.UnknownDocumentLoader", { type });
          }
          jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));
        };
        jsonld.registerRDFParser = function(contentType, parser) {
          _rdfParsers[contentType] = parser;
        };
        jsonld.unregisterRDFParser = function(contentType) {
          delete _rdfParsers[contentType];
        };
        jsonld.registerRDFParser("application/n-quads", NQuads.parse);
        jsonld.registerRDFParser("application/nquads", NQuads.parse);
        jsonld.url = require_url();
        jsonld.util = util;
        Object.assign(jsonld, util);
        jsonld.promises = jsonld;
        jsonld.RequestQueue = require_RequestQueue();
        jsonld.JsonLdProcessor = require_JsonLdProcessor()(jsonld);
        platform.setupGlobals(jsonld);
        platform.setupDocumentLoaders(jsonld);
        function _setDefaults(options, {
          documentLoader = jsonld.documentLoader,
          ...defaults
        }) {
          return Object.assign({}, { documentLoader }, defaults, options);
        }
        return jsonld;
      };
      var factory = function() {
        return wrapper(function() {
          return factory();
        });
      };
      wrapper(factory);
      module.exports = factory;
    }
  });

  // node_modules/jsonld-signatures/lib/contexts.js
  var require_contexts = __commonJS({
    "node_modules/jsonld-signatures/lib/contexts.js"(exports, module) {
      "use strict";
      var constants = require_constants2();
      var { contexts: securityContexts } = require_js();
      module.exports = /* @__PURE__ */ new Map([
        [
          constants.SECURITY_CONTEXT_V1_URL,
          securityContexts.get(constants.SECURITY_CONTEXT_V1_URL)
        ],
        [
          constants.SECURITY_CONTEXT_V2_URL,
          securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)
        ]
      ]);
    }
  });

  // node_modules/jsonld-signatures/lib/documentLoader.js
  var require_documentLoader = __commonJS({
    "node_modules/jsonld-signatures/lib/documentLoader.js"(exports, module) {
      "use strict";
      var contexts = require_contexts();
      var api = {};
      module.exports = api;
      api.extendContextLoader = (documentLoader) => {
        return async (url) => {
          const context = contexts.get(url);
          if (context !== void 0) {
            return {
              contextUrl: null,
              documentUrl: url,
              document: context,
              tag: "static"
            };
          }
          return documentLoader(url);
        };
      };
      api.strictDocumentLoader = api.extendContextLoader((url) => {
        throw new Error(`${url} not found.`);
      });
    }
  });

  // node_modules/serialize-error/index.js
  var require_serialize_error = __commonJS({
    "node_modules/serialize-error/index.js"(exports, module) {
      "use strict";
      var NonError = class extends Error {
        constructor(message) {
          super(NonError._prepareSuperMessage(message));
          Object.defineProperty(this, "name", {
            value: "NonError",
            configurable: true,
            writable: true
          });
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, NonError);
          }
        }
        static _prepareSuperMessage(message) {
          try {
            return JSON.stringify(message);
          } catch {
            return String(message);
          }
        }
      };
      var commonProperties = [
        { property: "name", enumerable: false },
        { property: "message", enumerable: false },
        { property: "stack", enumerable: false },
        { property: "code", enumerable: true }
      ];
      var isCalled = Symbol(".toJSON called");
      var toJSON = (from) => {
        from[isCalled] = true;
        const json = from.toJSON();
        delete from[isCalled];
        return json;
      };
      var destroyCircular = ({
        from,
        seen,
        to_,
        forceEnumerable,
        maxDepth,
        depth
      }) => {
        const to = to_ || (Array.isArray(from) ? [] : {});
        seen.push(from);
        if (depth >= maxDepth) {
          return to;
        }
        if (typeof from.toJSON === "function" && from[isCalled] !== true) {
          return toJSON(from);
        }
        for (const [key, value] of Object.entries(from)) {
          if (typeof Buffer === "function" && Buffer.isBuffer(value)) {
            to[key] = "[object Buffer]";
            continue;
          }
          if (typeof value === "function") {
            continue;
          }
          if (!value || typeof value !== "object") {
            to[key] = value;
            continue;
          }
          if (!seen.includes(from[key])) {
            depth++;
            to[key] = destroyCircular({
              from: from[key],
              seen: seen.slice(),
              forceEnumerable,
              maxDepth,
              depth
            });
            continue;
          }
          to[key] = "[Circular]";
        }
        for (const { property, enumerable } of commonProperties) {
          if (typeof from[property] === "string") {
            Object.defineProperty(to, property, {
              value: from[property],
              enumerable: forceEnumerable ? true : enumerable,
              configurable: true,
              writable: true
            });
          }
        }
        return to;
      };
      var serializeError = (value, options = {}) => {
        const { maxDepth = Number.POSITIVE_INFINITY } = options;
        if (typeof value === "object" && value !== null) {
          return destroyCircular({
            from: value,
            seen: [],
            forceEnumerable: true,
            maxDepth,
            depth: 0
          });
        }
        if (typeof value === "function") {
          return `[Function: ${value.name || "anonymous"}]`;
        }
        return value;
      };
      var deserializeError = (value, options = {}) => {
        const { maxDepth = Number.POSITIVE_INFINITY } = options;
        if (value instanceof Error) {
          return value;
        }
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          const newError = new Error();
          destroyCircular({
            from: value,
            seen: [],
            to_: newError,
            maxDepth,
            depth: 0
          });
          return newError;
        }
        return new NonError(value);
      };
      module.exports = {
        serializeError,
        deserializeError
      };
    }
  });

  // node_modules/jsonld-signatures/lib/expansionMap.js
  var require_expansionMap = __commonJS({
    "node_modules/jsonld-signatures/lib/expansionMap.js"(exports, module) {
      "use strict";
      module.exports = (info) => {
        if (info.unmappedProperty) {
          throw new Error('The property "' + info.unmappedProperty + '" in the input was not defined in the context.');
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/ProofSet.js
  var require_ProofSet = __commonJS({
    "node_modules/jsonld-signatures/lib/ProofSet.js"(exports, module) {
      "use strict";
      var constants = require_constants2();
      var jsonld = require_jsonld();
      var { extendContextLoader, strictDocumentLoader } = require_documentLoader();
      var { serializeError } = require_serialize_error();
      var strictExpansionMap = require_expansionMap();
      module.exports = class ProofSet {
        async add(document2, { suite, purpose, documentLoader, expansionMap } = {}) {
          if (!suite) {
            throw new TypeError('"options.suite" is required.');
          }
          if (!purpose) {
            throw new TypeError('"options.purpose" is required.');
          }
          if (documentLoader) {
            documentLoader = extendContextLoader(documentLoader);
          } else {
            documentLoader = strictDocumentLoader;
          }
          if (expansionMap === void 0) {
            expansionMap = strictExpansionMap;
          } else if (expansionMap === false) {
            expansionMap = void 0;
          }
          const input = { ...document2 };
          delete input.proof;
          const proof = await suite.createProof({
            document: input,
            purpose,
            documentLoader,
            expansionMap
          });
          jsonld.addValue(document2, "proof", proof);
          return document2;
        }
        async verify(document2, { suite, purpose, documentLoader, expansionMap } = {}) {
          if (!suite) {
            throw new TypeError('"options.suite" is required.');
          }
          if (!purpose) {
            throw new TypeError('"options.purpose" is required.');
          }
          const suites = Array.isArray(suite) ? suite : [suite];
          if (suites.length === 0) {
            throw new TypeError("At least one suite is required.");
          }
          if (documentLoader) {
            documentLoader = extendContextLoader(documentLoader);
          } else {
            documentLoader = strictDocumentLoader;
          }
          if (expansionMap === void 0) {
            expansionMap = strictExpansionMap;
          } else if (expansionMap === false) {
            expansionMap = void 0;
          }
          try {
            document2 = { ...document2 };
            const { proofSet, document: doc } = await _getProofs({
              document: document2,
              documentLoader,
              expansionMap
            });
            document2 = doc;
            const results = await _verify({
              document: document2,
              suites,
              proofSet,
              purpose,
              documentLoader,
              expansionMap
            });
            if (results.length === 0) {
              const error = new Error("Did not verify any proofs; insufficient proofs matched the acceptable suite(s) and required purpose(s).");
              error.name = "NotFoundError";
              throw error;
            }
            const verified = results.some((r) => r.verified);
            if (!verified) {
              const errors = [].concat(...results.filter((r) => r.error).map((r) => r.error));
              const result = { verified, results };
              if (errors.length > 0) {
                result.error = errors;
              }
              return result;
            }
            return { verified, results };
          } catch (error) {
            _makeSerializable(error);
            return { verified: false, error };
          }
        }
      };
      async function _getProofs({ document: document2 }) {
        let proofSet;
        proofSet = jsonld.getValues(document2, "proof");
        delete document2.proof;
        if (proofSet.length === 0) {
          throw new Error("No matching proofs found in the given document.");
        }
        const context = document2["@context"] || constants.SECURITY_CONTEXT_URL;
        proofSet = proofSet.map((proof) => ({
          "@context": context,
          ...proof
        }));
        return { proofSet, document: document2 };
      }
      async function _verify({
        document: document2,
        suites,
        proofSet,
        purpose,
        documentLoader,
        expansionMap
      }) {
        const purposes = Array.isArray(purpose) ? purpose : [purpose];
        const purposeToProofs = /* @__PURE__ */ new Map();
        const proofToSuite = /* @__PURE__ */ new Map();
        const suiteMatchQueue = /* @__PURE__ */ new Map();
        await Promise.all(purposes.map((purpose2) => _matchProofSet({
          purposeToProofs,
          proofToSuite,
          purpose: purpose2,
          proofSet,
          suites,
          suiteMatchQueue,
          document: document2,
          documentLoader,
          expansionMap
        })));
        if (purposeToProofs.size < purposes.length) {
          return [];
        }
        const verifyResults = /* @__PURE__ */ new Map();
        await Promise.all([...proofToSuite.entries()].map(async ([proof, suite]) => {
          let result;
          try {
            let vm;
            const purpose2 = {
              async validate(proof2, { verificationMethod: verificationMethod2 }) {
                vm = verificationMethod2;
                return { valid: true };
              }
            };
            const { verified, verificationMethod, error } = await suite.verifyProof({
              proof,
              document: document2,
              purpose: purpose2,
              documentLoader,
              expansionMap
            });
            if (!vm) {
              vm = verificationMethod;
            }
            result = { proof, verified, verificationMethod: vm, error };
          } catch (error) {
            result = { proof, verified: false, error };
          }
          if (result.error) {
            _makeSerializable(result.error);
          }
          verifyResults.set(proof, result);
        }));
        await Promise.all([...purposeToProofs.entries()].map(async ([purpose2, proofs]) => {
          for (const proof of proofs) {
            const result = verifyResults.get(proof);
            if (!result.verified) {
              continue;
            }
            const { verificationMethod } = result;
            const suite = proofToSuite.get(proof);
            let purposeResult;
            try {
              purposeResult = await purpose2.validate(proof, {
                document: document2,
                suite,
                verificationMethod,
                documentLoader,
                expansionMap
              });
            } catch (error) {
              purposeResult = { valid: false, error };
            }
            if (result.purposeResult) {
              if (Array.isArray(result.purposeResult)) {
                result.purposeResult.push(purposeResult);
              } else {
                result.purposeResult = [result.purposeResult, purposeResult];
              }
            } else {
              result.purposeResult = purposeResult;
            }
            if (!purposeResult.valid) {
              _makeSerializable(purposeResult.error);
              if (!result.error) {
                result.verified = false;
                result.error = purposeResult.error;
              }
            }
          }
        }));
        return [...verifyResults.values()];
      }
      function _makeSerializable(error) {
        Object.defineProperty(error, "toJSON", {
          value: function() {
            return serializeError(this);
          },
          configurable: true,
          writable: true
        });
      }
      async function _matchProofSet({
        purposeToProofs,
        proofToSuite,
        purpose,
        proofSet,
        suites,
        suiteMatchQueue,
        document: document2,
        documentLoader,
        expansionMap
      }) {
        for (const proof of proofSet) {
          if (!await purpose.match(proof, { document: document2, documentLoader, expansionMap })) {
            continue;
          }
          let matched = false;
          for (const s of suites) {
            let matchingProofs = suiteMatchQueue.get(s);
            if (!matchingProofs) {
              suiteMatchQueue.set(s, matchingProofs = /* @__PURE__ */ new Map());
            }
            let promise = matchingProofs.get(proof);
            if (!promise) {
              promise = s.matchProof({ proof, document: document2, documentLoader, expansionMap });
              matchingProofs.set(proof, promise);
            }
            if (await promise) {
              matched = true;
              proofToSuite.set(proof, s);
              break;
            }
          }
          if (matched) {
            const matches = purposeToProofs.get(purpose);
            if (matches) {
              matches.push(proof);
            } else {
              purposeToProofs.set(purpose, [proof]);
            }
          }
        }
      }
    }
  });

  // node_modules/jsonld-signatures/lib/VerificationError.js
  var require_VerificationError = __commonJS({
    "node_modules/jsonld-signatures/lib/VerificationError.js"(exports, module) {
      "use strict";
      var VerificationError = class extends Error {
        constructor(errors) {
          super("Verification error(s).");
          this.name = "VerificationError";
          this.errors = [].concat(errors);
        }
      };
      module.exports = VerificationError;
    }
  });

  // node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js
  var require_LinkedDataProof = __commonJS({
    "node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js"(exports, module) {
      "use strict";
      module.exports = class LinkedDataProof {
        constructor({ type } = {}) {
          if (typeof type !== "string") {
            throw new TypeError('A LinkedDataProof must have a "type".');
          }
          this.type = type;
        }
        async createProof({}) {
          throw new Error('"createProof" must be implemented in a derived class.');
        }
        async verifyProof({}) {
          throw new Error('"verifyProof" must be implemented in a derived class.');
        }
        async matchProof({
          proof
        }) {
          return proof.type === this.type;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/util.js
  var require_util3 = __commonJS({
    "node_modules/jsonld-signatures/lib/util.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.w3cDate = (date) => {
        if (date === void 0 || date === null) {
          date = new Date();
        } else if (typeof date === "number" || typeof date === "string") {
          date = new Date(date);
        }
        const str = date.toISOString();
        return str.substr(0, str.length - 5) + "Z";
      };
      api.concat = (b1, b2) => {
        const rval = new Uint8Array(b1.length + b2.length);
        rval.set(b1, 0);
        rval.set(b2, b1.length);
        return rval;
      };
    }
  });

  // node_modules/jsonld-signatures/lib/sha256digest-browser.js
  var require_sha256digest_browser = __commonJS({
    "node_modules/jsonld-signatures/lib/sha256digest-browser.js"(exports, module) {
      "use strict";
      var crypto = self && (self.crypto || self.msCrypto);
      module.exports = {
        async sha256digest({ string }) {
          const bytes = new TextEncoder().encode(string);
          return new Uint8Array(await crypto.subtle.digest("SHA-256", bytes));
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js
  var require_LinkedDataSignature = __commonJS({
    "node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js"(exports, module) {
      "use strict";
      var constants = require_constants2();
      var jsonld = require_jsonld();
      var util = require_util3();
      var { sha256digest } = require_sha256digest_browser();
      var LinkedDataProof = require_LinkedDataProof();
      module.exports = class LinkedDataSignature extends LinkedDataProof {
        constructor({
          type,
          proof,
          LDKeyClass,
          date,
          key,
          signer,
          verifier,
          useNativeCanonize,
          contextUrl
        } = {}) {
          super({ type });
          this.LDKeyClass = LDKeyClass;
          this.contextUrl = contextUrl;
          this.proof = proof;
          const vm = _processSignatureParams({ key, signer, verifier });
          this.verificationMethod = vm.verificationMethod;
          this.key = vm.key;
          this.signer = vm.signer;
          this.verifier = vm.verifier;
          if (date) {
            this.date = new Date(date);
            if (isNaN(this.date)) {
              throw TypeError(`"date" "${date}" is not a valid date.`);
            }
          }
          this.useNativeCanonize = useNativeCanonize;
          this._hashCache = null;
        }
        async createProof({ document: document2, purpose, documentLoader, expansionMap }) {
          let proof;
          if (this.proof) {
            proof = { ...this.proof };
          } else {
            proof = {};
          }
          proof.type = this.type;
          let date = this.date;
          if (proof.created === void 0 && date === void 0) {
            date = new Date();
          }
          if (date && typeof date !== "string") {
            date = util.w3cDate(date);
          }
          if (date) {
            proof.created = date;
          }
          proof.verificationMethod = this.verificationMethod;
          proof = await this.updateProof({
            document: document2,
            proof,
            purpose,
            documentLoader,
            expansionMap
          });
          proof = await purpose.update(proof, { document: document2, suite: this, documentLoader, expansionMap });
          const verifyData = await this.createVerifyData({
            document: document2,
            proof,
            documentLoader,
            expansionMap
          });
          proof = await this.sign({ verifyData, document: document2, proof, documentLoader, expansionMap });
          return proof;
        }
        async updateProof({ proof }) {
          return proof;
        }
        async verifyProof({ proof, document: document2, documentLoader, expansionMap }) {
          try {
            const verifyData = await this.createVerifyData({ document: document2, proof, documentLoader, expansionMap });
            const verificationMethod = await this.getVerificationMethod({ proof, document: document2, documentLoader, expansionMap });
            const verified = await this.verifySignature({
              verifyData,
              verificationMethod,
              document: document2,
              proof,
              documentLoader,
              expansionMap
            });
            if (!verified) {
              throw new Error("Invalid signature.");
            }
            return { verified: true, verificationMethod };
          } catch (error) {
            return { verified: false, error };
          }
        }
        async canonize(input, { documentLoader, expansionMap, skipExpansion }) {
          return jsonld.canonize(input, {
            algorithm: "URDNA2015",
            format: "application/n-quads",
            documentLoader,
            expansionMap,
            skipExpansion,
            useNative: this.useNativeCanonize
          });
        }
        async canonizeProof(proof, { document: document2, documentLoader, expansionMap }) {
          proof = {
            "@context": document2["@context"] || constants.SECURITY_CONTEXT_URL,
            ...proof
          };
          delete proof.jws;
          delete proof.signatureValue;
          delete proof.proofValue;
          return this.canonize(proof, {
            documentLoader,
            expansionMap,
            skipExpansion: false
          });
        }
        async createVerifyData({ document: document2, proof, documentLoader, expansionMap }) {
          let cachedDocHash;
          const { _hashCache } = this;
          if (_hashCache && _hashCache.document === document2) {
            cachedDocHash = _hashCache.hash;
          } else {
            this._hashCache = {
              document: document2,
              hash: cachedDocHash = this.canonize(document2, { documentLoader, expansionMap }).then((c14nDocument) => sha256digest({ string: c14nDocument }))
            };
          }
          const [proofHash, docHash] = await Promise.all([
            this.canonizeProof(proof, { document: document2, documentLoader, expansionMap }).then((c14nProofOptions) => sha256digest({ string: c14nProofOptions })),
            cachedDocHash
          ]);
          return util.concat(proofHash, docHash);
        }
        async getVerificationMethod({ proof, documentLoader }) {
          let { verificationMethod } = proof;
          if (typeof verificationMethod === "object") {
            verificationMethod = verificationMethod.id;
          }
          if (!verificationMethod) {
            throw new Error('No "verificationMethod" found in proof.');
          }
          const framed = await jsonld.frame(verificationMethod, {
            "@context": constants.SECURITY_CONTEXT_URL,
            "@embed": "@always",
            id: verificationMethod
          }, { documentLoader, compactToRelative: false });
          if (!framed) {
            throw new Error(`Verification method ${verificationMethod} not found.`);
          }
          if (framed.revoked !== void 0) {
            throw new Error("The verification method has been revoked.");
          }
          return framed;
        }
        async sign() {
          throw new Error("Must be implemented by a derived class.");
        }
        async verifySignature() {
          throw new Error("Must be implemented by a derived class.");
        }
        ensureSuiteContext({ document: document2, addSuiteContext }) {
          const { contextUrl } = this;
          if (_includesContext({ document: document2, contextUrl })) {
            return;
          }
          if (!addSuiteContext) {
            throw new TypeError(`The document to be signed must contain this suite's @context, "${contextUrl}".`);
          }
          const existingContext = document2["@context"] || [];
          document2["@context"] = Array.isArray(existingContext) ? [...existingContext, contextUrl] : [existingContext, contextUrl];
        }
      };
      function _includesContext({ document: document2, contextUrl }) {
        const context = document2["@context"];
        return context === contextUrl || Array.isArray(context) && context.includes(contextUrl);
      }
      function _processSignatureParams({ key, signer, verifier }) {
        const vm = {};
        if (key) {
          vm.key = key;
          vm.verificationMethod = key.id;
          if (typeof key.signer === "function") {
            vm.signer = key.signer();
          }
          if (typeof key.verifier === "function") {
            vm.verifier = key.verifier();
          }
          if (!(vm.signer || vm.verifier)) {
            throw new TypeError('The "key" parameter must contain a "signer" or "verifier" method.');
          }
        } else {
          vm.verificationMethod = signer && signer.id || verifier && verifier.id;
          vm.signer = signer;
          vm.verifier = verifier;
        }
        if (vm.signer) {
          if (typeof vm.signer.sign !== "function") {
            throw new TypeError("A signer API has not been specified.");
          }
        }
        if (vm.verifier) {
          if (typeof vm.verifier.verify !== "function") {
            throw new TypeError("A verifier API has not been specified.");
          }
        }
        return vm;
      }
    }
  });

  // node_modules/jsonld-signatures/lib/suites.js
  var require_suites = __commonJS({
    "node_modules/jsonld-signatures/lib/suites.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.suites = {
        LinkedDataProof: require_LinkedDataProof(),
        LinkedDataSignature: require_LinkedDataSignature()
      };
    }
  });

  // node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js
  var require_ProofPurpose = __commonJS({
    "node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js"(exports, module) {
      "use strict";
      module.exports = class ProofPurpose {
        constructor({ term, date, maxTimestampDelta = Infinity } = {}) {
          if (term === void 0) {
            throw new Error('"term" is required.');
          }
          if (maxTimestampDelta !== void 0 && typeof maxTimestampDelta !== "number") {
            throw new TypeError('"maxTimestampDelta" must be a number.');
          }
          this.term = term;
          if (date !== void 0) {
            this.date = new Date(date);
            if (isNaN(this.date)) {
              throw TypeError(`"date" "${date}" is not a valid date.`);
            }
          }
          this.maxTimestampDelta = maxTimestampDelta;
        }
        async validate(proof, {}) {
          try {
            if (this.maxTimestampDelta !== Infinity) {
              const expected = (this.date || new Date()).getTime();
              const delta = this.maxTimestampDelta * 1e3;
              const created = new Date(proof.created).getTime();
              if (!(created >= expected - delta && created <= expected + delta)) {
                throw new Error("The proof's created timestamp is out of range.");
              }
            }
            return { valid: true };
          } catch (error) {
            return { valid: false, error };
          }
        }
        async update(proof, {}) {
          proof.proofPurpose = this.term;
          return proof;
        }
        async match(proof, {}) {
          return proof.proofPurpose === this.term;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js
  var require_ControllerProofPurpose = __commonJS({
    "node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js"(exports, module) {
      "use strict";
      var constants = require_constants2();
      var jsonld = require_jsonld();
      var ProofPurpose = require_ProofPurpose();
      var DID_CONTEXT_V1 = "https://www.w3.org/ns/did/v1";
      var DID_VR_TERMS = [
        "assertionMethod",
        "authentication",
        "capabilityInvocation",
        "capabilityDelegation",
        "keyAgreement",
        "verificationMethod"
      ];
      module.exports = class ControllerProofPurpose extends ProofPurpose {
        constructor({ term, controller, date, maxTimestampDelta = Infinity } = {}) {
          super({ term, date, maxTimestampDelta });
          if (controller !== void 0) {
            if (typeof controller !== "object") {
              throw new TypeError('"controller" must be an object.');
            }
            this.controller = controller;
          }
          this._termDefinedByDIDContext = DID_VR_TERMS.includes(term);
        }
        async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
          try {
            const result = await super.validate(proof, { verificationMethod, documentLoader, expansionMap });
            if (!result.valid) {
              throw result.error;
            }
            const { id: verificationId } = verificationMethod;
            const { term, _termDefinedByDIDContext } = this;
            if (this.controller) {
              result.controller = this.controller;
            } else {
              const { controller } = verificationMethod;
              let controllerId;
              if (controller) {
                if (typeof controller === "object") {
                  controllerId = controller.id;
                } else if (typeof controller !== "string") {
                  throw new TypeError('"controller" must be a string representing a URL.');
                } else {
                  controllerId = controller;
                }
              }
              let { document: document2 } = await documentLoader(controllerId);
              const mustFrame = !(_termDefinedByDIDContext && document2["@context"] === DID_CONTEXT_V1 || Array.isArray(document2["@context"]) && document2["@context"][0] === DID_CONTEXT_V1);
              if (mustFrame) {
                document2 = await jsonld.frame(document2, {
                  "@context": constants.SECURITY_CONTEXT_URL,
                  id: controllerId,
                  [term]: {
                    "@embed": "@never",
                    id: verificationId
                  }
                }, { documentLoader, compactToRelative: false });
              }
              result.controller = document2;
            }
            const verificationMethods = jsonld.getValues(result.controller, term);
            result.valid = verificationMethods.some((vm) => vm === verificationId || typeof vm === "object" && vm.id === verificationId);
            if (!result.valid) {
              throw new Error(`Verification method "${verificationMethod.id}" not authorized by controller for proof purpose "${this.term}".`);
            }
            return result;
          } catch (error) {
            return { valid: false, error };
          }
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js
  var require_AssertionProofPurpose = __commonJS({
    "node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js"(exports, module) {
      "use strict";
      var ControllerProofPurpose = require_ControllerProofPurpose();
      module.exports = class AssertionProofPurpose extends ControllerProofPurpose {
        constructor({
          term = "assertionMethod",
          controller,
          date,
          maxTimestampDelta = Infinity
        } = {}) {
          super({ term, controller, date, maxTimestampDelta });
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js
  var require_AuthenticationProofPurpose = __commonJS({
    "node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js"(exports, module) {
      "use strict";
      var ControllerProofPurpose = require_ControllerProofPurpose();
      module.exports = class AuthenticationProofPurpose extends ControllerProofPurpose {
        constructor({
          term = "authentication",
          controller,
          challenge,
          date,
          domain,
          maxTimestampDelta = Infinity
        } = {}) {
          super({ term, controller, date, maxTimestampDelta });
          if (typeof challenge !== "string") {
            throw new TypeError('"challenge" must be a string.');
          }
          if (domain !== void 0 && typeof domain !== "string") {
            throw new TypeError('"domain" must be a string.');
          }
          this.challenge = challenge;
          this.domain = domain;
        }
        async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
          try {
            if (proof.challenge !== this.challenge) {
              throw new Error(`The challenge is not as expected; challenge="${proof.challenge}", expected="${this.challenge}"`);
            }
            if (this.domain !== void 0 && proof.domain !== this.domain) {
              throw new Error(`The domain is not as expected; domain="${proof.domain}", expected="${this.domain}"`);
            }
            return super.validate(proof, { verificationMethod, documentLoader, expansionMap });
          } catch (error) {
            return { valid: false, error };
          }
        }
        async update(proof, { document: document2, suite, documentLoader, expansionMap }) {
          proof = await super.update(proof, { document: document2, suite, documentLoader, expansionMap });
          proof.challenge = this.challenge;
          if (this.domain !== void 0) {
            proof.domain = this.domain;
          }
          return proof;
        }
      };
    }
  });

  // node_modules/jsonld-signatures/lib/purposes.js
  var require_purposes = __commonJS({
    "node_modules/jsonld-signatures/lib/purposes.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.purposes = {
        AssertionProofPurpose: require_AssertionProofPurpose(),
        AuthenticationProofPurpose: require_AuthenticationProofPurpose(),
        ControllerProofPurpose: require_ControllerProofPurpose(),
        ProofPurpose: require_ProofPurpose()
      };
    }
  });

  // node_modules/jsonld-signatures/lib/jsonld-signatures.js
  var require_jsonld_signatures = __commonJS({
    "node_modules/jsonld-signatures/lib/jsonld-signatures.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      var constants = require_constants2();
      Object.assign(api, constants);
      var ProofSet = require_ProofSet();
      var VerificationError = require_VerificationError();
      api.sign = async function sign(document2, {
        suite,
        purpose,
        documentLoader,
        expansionMap,
        addSuiteContext = true
      } = {}) {
        if (typeof document2 !== "object") {
          throw new TypeError('The "document" parameter must be an object.');
        }
        suite.ensureSuiteContext({ document: document2, addSuiteContext });
        try {
          return await new ProofSet().add(document2, { suite, purpose, documentLoader, expansionMap });
        } catch (e) {
          if (!documentLoader && e.name === "jsonld.InvalidUrl") {
            const { details: { url } } = e;
            const err = new Error(`A URL "${url}" could not be fetched; you need to pass "documentLoader" or resolve the URL before calling "sign".`);
            err.cause = e;
            throw err;
          }
          throw e;
        }
      };
      api.verify = async function verify(document2, {
        suite,
        purpose,
        documentLoader,
        expansionMap
      } = {}) {
        if (typeof document2 !== "object") {
          throw new TypeError('The "document" parameter must be an object.');
        }
        const result = await new ProofSet().verify(document2, { suite, purpose, documentLoader, expansionMap });
        const { error } = result;
        if (error) {
          if (!documentLoader && error.name === "jsonld.InvalidUrl") {
            const { details: { url } } = error;
            const urlError = new Error(`A URL "${url}" could not be fetched; you need to pass "documentLoader" or resolve the URL before calling "verify".`);
            result.error = new VerificationError(urlError);
          } else {
            result.error = new VerificationError(error);
          }
        }
        return result;
      };
      api.suites = require_suites().suites;
      api.purposes = require_purposes().purposes;
      Object.assign(api, require_documentLoader());
    }
  });

  // node_modules/crypto-ld/lib/env.js
  var require_env = __commonJS({
    "node_modules/crypto-ld/lib/env.js"(exports, module) {
      "use strict";
      var nodejs = typeof process !== "undefined" && process.versions && process.versions.node;
      var browser = !nodejs && (typeof window !== "undefined" || typeof self !== "undefined");
      module.exports = {
        nodejs,
        browser
      };
    }
  });

  // node_modules/node-forge/lib/forge.js
  var require_forge = __commonJS({
    "node_modules/node-forge/lib/forge.js"(exports, module) {
      module.exports = {
        options: {
          usePureJavaScript: false
        }
      };
    }
  });

  // node_modules/node-forge/lib/baseN.js
  var require_baseN = __commonJS({
    "node_modules/node-forge/lib/baseN.js"(exports, module) {
      var api = {};
      module.exports = api;
      var _reverseAlphabets = {};
      api.encode = function(input, alphabet, maxline) {
        if (typeof alphabet !== "string") {
          throw new TypeError('"alphabet" must be a string.');
        }
        if (maxline !== void 0 && typeof maxline !== "number") {
          throw new TypeError('"maxline" must be a number.');
        }
        var output = "";
        if (!(input instanceof Uint8Array)) {
          output = _encodeWithByteBuffer(input, alphabet);
        } else {
          var i = 0;
          var base = alphabet.length;
          var first = alphabet.charAt(0);
          var digits = [0];
          for (i = 0; i < input.length; ++i) {
            for (var j = 0, carry = input[i]; j < digits.length; ++j) {
              carry += digits[j] << 8;
              digits[j] = carry % base;
              carry = carry / base | 0;
            }
            while (carry > 0) {
              digits.push(carry % base);
              carry = carry / base | 0;
            }
          }
          for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
            output += first;
          }
          for (i = digits.length - 1; i >= 0; --i) {
            output += alphabet[digits[i]];
          }
        }
        if (maxline) {
          var regex = new RegExp(".{1," + maxline + "}", "g");
          output = output.match(regex).join("\r\n");
        }
        return output;
      };
      api.decode = function(input, alphabet) {
        if (typeof input !== "string") {
          throw new TypeError('"input" must be a string.');
        }
        if (typeof alphabet !== "string") {
          throw new TypeError('"alphabet" must be a string.');
        }
        var table = _reverseAlphabets[alphabet];
        if (!table) {
          table = _reverseAlphabets[alphabet] = [];
          for (var i = 0; i < alphabet.length; ++i) {
            table[alphabet.charCodeAt(i)] = i;
          }
        }
        input = input.replace(/\s/g, "");
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var bytes = [0];
        for (var i = 0; i < input.length; i++) {
          var value = table[input.charCodeAt(i)];
          if (value === void 0) {
            return;
          }
          for (var j = 0, carry = value; j < bytes.length; ++j) {
            carry += bytes[j] * base;
            bytes[j] = carry & 255;
            carry >>= 8;
          }
          while (carry > 0) {
            bytes.push(carry & 255);
            carry >>= 8;
          }
        }
        for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
          bytes.push(0);
        }
        if (typeof Buffer !== "undefined") {
          return Buffer.from(bytes.reverse());
        }
        return new Uint8Array(bytes.reverse());
      };
      function _encodeWithByteBuffer(input, alphabet) {
        var i = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length(); ++i) {
          for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        var output = "";
        for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
          output += first;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
        return output;
      }
    }
  });

  // node_modules/node-forge/lib/util.js
  var require_util4 = __commonJS({
    "node_modules/node-forge/lib/util.js"(exports, module) {
      var forge = require_forge();
      var baseN = require_baseN();
      var util = module.exports = forge.util = forge.util || {};
      (function() {
        if (typeof process !== "undefined" && process.nextTick && !process.browser) {
          util.nextTick = process.nextTick;
          if (typeof setImmediate === "function") {
            util.setImmediate = setImmediate;
          } else {
            util.setImmediate = util.nextTick;
          }
          return;
        }
        if (typeof setImmediate === "function") {
          util.setImmediate = function() {
            return setImmediate.apply(void 0, arguments);
          };
          util.nextTick = function(callback) {
            return setImmediate(callback);
          };
          return;
        }
        util.setImmediate = function(callback) {
          setTimeout(callback, 0);
        };
        if (typeof window !== "undefined" && typeof window.postMessage === "function") {
          let handler2 = function(event) {
            if (event.source === window && event.data === msg) {
              event.stopPropagation();
              var copy = callbacks.slice();
              callbacks.length = 0;
              copy.forEach(function(callback) {
                callback();
              });
            }
          };
          var handler = handler2;
          var msg = "forge.setImmediate";
          var callbacks = [];
          util.setImmediate = function(callback) {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              window.postMessage(msg, "*");
            }
          };
          window.addEventListener("message", handler2, true);
        }
        if (typeof MutationObserver !== "undefined") {
          var now = Date.now();
          var attr = true;
          var div = document.createElement("div");
          var callbacks = [];
          new MutationObserver(function() {
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }).observe(div, { attributes: true });
          var oldSetImmediate = util.setImmediate;
          util.setImmediate = function(callback) {
            if (Date.now() - now > 15) {
              now = Date.now();
              oldSetImmediate(callback);
            } else {
              callbacks.push(callback);
              if (callbacks.length === 1) {
                div.setAttribute("a", attr = !attr);
              }
            }
          };
        }
        util.nextTick = util.setImmediate;
      })();
      util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
      util.globalScope = function() {
        if (util.isNodejs) {
          return global;
        }
        return typeof self === "undefined" ? window : self;
      }();
      util.isArray = Array.isArray || function(x) {
        return Object.prototype.toString.call(x) === "[object Array]";
      };
      util.isArrayBuffer = function(x) {
        return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
      };
      util.isArrayBufferView = function(x) {
        return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
      };
      function _checkBitsParam(n) {
        if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
          throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
        }
      }
      util.ByteBuffer = ByteStringBuffer;
      function ByteStringBuffer(b) {
        this.data = "";
        this.read = 0;
        if (typeof b === "string") {
          this.data = b;
        } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
          if (typeof Buffer !== "undefined" && b instanceof Buffer) {
            this.data = b.toString("binary");
          } else {
            var arr = new Uint8Array(b);
            try {
              this.data = String.fromCharCode.apply(null, arr);
            } catch (e) {
              for (var i = 0; i < arr.length; ++i) {
                this.putByte(arr[i]);
              }
            }
          }
        } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
          this.data = b.data;
          this.read = b.read;
        }
        this._constructedStringLength = 0;
      }
      util.ByteStringBuffer = ByteStringBuffer;
      var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
      util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
        this._constructedStringLength += x;
        if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
          this.data.substr(0, 1);
          this._constructedStringLength = 0;
        }
      };
      util.ByteStringBuffer.prototype.length = function() {
        return this.data.length - this.read;
      };
      util.ByteStringBuffer.prototype.isEmpty = function() {
        return this.length() <= 0;
      };
      util.ByteStringBuffer.prototype.putByte = function(b) {
        return this.putBytes(String.fromCharCode(b));
      };
      util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
        b = String.fromCharCode(b);
        var d = this.data;
        while (n > 0) {
          if (n & 1) {
            d += b;
          }
          n >>>= 1;
          if (n > 0) {
            b += b;
          }
        }
        this.data = d;
        this._optimizeConstructedString(n);
        return this;
      };
      util.ByteStringBuffer.prototype.putBytes = function(bytes) {
        this.data += bytes;
        this._optimizeConstructedString(bytes.length);
        return this;
      };
      util.ByteStringBuffer.prototype.putString = function(str) {
        return this.putBytes(util.encodeUtf8(str));
      };
      util.ByteStringBuffer.prototype.putInt16 = function(i) {
        return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
      };
      util.ByteStringBuffer.prototype.putInt24 = function(i) {
        return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
      };
      util.ByteStringBuffer.prototype.putInt32 = function(i) {
        return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
      };
      util.ByteStringBuffer.prototype.putInt16Le = function(i) {
        return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
      };
      util.ByteStringBuffer.prototype.putInt24Le = function(i) {
        return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
      };
      util.ByteStringBuffer.prototype.putInt32Le = function(i) {
        return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
      };
      util.ByteStringBuffer.prototype.putInt = function(i, n) {
        _checkBitsParam(n);
        var bytes = "";
        do {
          n -= 8;
          bytes += String.fromCharCode(i >> n & 255);
        } while (n > 0);
        return this.putBytes(bytes);
      };
      util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
        if (i < 0) {
          i += 2 << n - 1;
        }
        return this.putInt(i, n);
      };
      util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
        return this.putBytes(buffer.getBytes());
      };
      util.ByteStringBuffer.prototype.getByte = function() {
        return this.data.charCodeAt(this.read++);
      };
      util.ByteStringBuffer.prototype.getInt16 = function() {
        var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
        this.read += 2;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt24 = function() {
        var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
        this.read += 3;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt32 = function() {
        var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
        this.read += 4;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt16Le = function() {
        var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
        this.read += 2;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt24Le = function() {
        var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
        this.read += 3;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt32Le = function() {
        var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
        this.read += 4;
        return rval;
      };
      util.ByteStringBuffer.prototype.getInt = function(n) {
        _checkBitsParam(n);
        var rval = 0;
        do {
          rval = (rval << 8) + this.data.charCodeAt(this.read++);
          n -= 8;
        } while (n > 0);
        return rval;
      };
      util.ByteStringBuffer.prototype.getSignedInt = function(n) {
        var x = this.getInt(n);
        var max = 2 << n - 2;
        if (x >= max) {
          x -= max << 1;
        }
        return x;
      };
      util.ByteStringBuffer.prototype.getBytes = function(count) {
        var rval;
        if (count) {
          count = Math.min(this.length(), count);
          rval = this.data.slice(this.read, this.read + count);
          this.read += count;
        } else if (count === 0) {
          rval = "";
        } else {
          rval = this.read === 0 ? this.data : this.data.slice(this.read);
          this.clear();
        }
        return rval;
      };
      util.ByteStringBuffer.prototype.bytes = function(count) {
        return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
      };
      util.ByteStringBuffer.prototype.at = function(i) {
        return this.data.charCodeAt(this.read + i);
      };
      util.ByteStringBuffer.prototype.setAt = function(i, b) {
        this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
        return this;
      };
      util.ByteStringBuffer.prototype.last = function() {
        return this.data.charCodeAt(this.data.length - 1);
      };
      util.ByteStringBuffer.prototype.copy = function() {
        var c = util.createBuffer(this.data);
        c.read = this.read;
        return c;
      };
      util.ByteStringBuffer.prototype.compact = function() {
        if (this.read > 0) {
          this.data = this.data.slice(this.read);
          this.read = 0;
        }
        return this;
      };
      util.ByteStringBuffer.prototype.clear = function() {
        this.data = "";
        this.read = 0;
        return this;
      };
      util.ByteStringBuffer.prototype.truncate = function(count) {
        var len = Math.max(0, this.length() - count);
        this.data = this.data.substr(this.read, len);
        this.read = 0;
        return this;
      };
      util.ByteStringBuffer.prototype.toHex = function() {
        var rval = "";
        for (var i = this.read; i < this.data.length; ++i) {
          var b = this.data.charCodeAt(i);
          if (b < 16) {
            rval += "0";
          }
          rval += b.toString(16);
        }
        return rval;
      };
      util.ByteStringBuffer.prototype.toString = function() {
        return util.decodeUtf8(this.bytes());
      };
      function DataBuffer(b, options) {
        options = options || {};
        this.read = options.readOffset || 0;
        this.growSize = options.growSize || 1024;
        var isArrayBuffer = util.isArrayBuffer(b);
        var isArrayBufferView = util.isArrayBufferView(b);
        if (isArrayBuffer || isArrayBufferView) {
          if (isArrayBuffer) {
            this.data = new DataView(b);
          } else {
            this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
          }
          this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
          return;
        }
        this.data = new DataView(new ArrayBuffer(0));
        this.write = 0;
        if (b !== null && b !== void 0) {
          this.putBytes(b);
        }
        if ("writeOffset" in options) {
          this.write = options.writeOffset;
        }
      }
      util.DataBuffer = DataBuffer;
      util.DataBuffer.prototype.length = function() {
        return this.write - this.read;
      };
      util.DataBuffer.prototype.isEmpty = function() {
        return this.length() <= 0;
      };
      util.DataBuffer.prototype.accommodate = function(amount, growSize) {
        if (this.length() >= amount) {
          return this;
        }
        growSize = Math.max(growSize || this.growSize, amount);
        var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
        var dst = new Uint8Array(this.length() + growSize);
        dst.set(src);
        this.data = new DataView(dst.buffer);
        return this;
      };
      util.DataBuffer.prototype.putByte = function(b) {
        this.accommodate(1);
        this.data.setUint8(this.write++, b);
        return this;
      };
      util.DataBuffer.prototype.fillWithByte = function(b, n) {
        this.accommodate(n);
        for (var i = 0; i < n; ++i) {
          this.data.setUint8(b);
        }
        return this;
      };
      util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
        if (util.isArrayBufferView(bytes)) {
          var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
          var len = src.byteLength - src.byteOffset;
          this.accommodate(len);
          var dst = new Uint8Array(this.data.buffer, this.write);
          dst.set(src);
          this.write += len;
          return this;
        }
        if (util.isArrayBuffer(bytes)) {
          var src = new Uint8Array(bytes);
          this.accommodate(src.byteLength);
          var dst = new Uint8Array(this.data.buffer);
          dst.set(src, this.write);
          this.write += src.byteLength;
          return this;
        }
        if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
          var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
          this.accommodate(src.byteLength);
          var dst = new Uint8Array(bytes.data.byteLength, this.write);
          dst.set(src);
          this.write += src.byteLength;
          return this;
        }
        if (bytes instanceof util.ByteStringBuffer) {
          bytes = bytes.data;
          encoding = "binary";
        }
        encoding = encoding || "binary";
        if (typeof bytes === "string") {
          var view;
          if (encoding === "hex") {
            this.accommodate(Math.ceil(bytes.length / 2));
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += util.binary.hex.decode(bytes, view, this.write);
            return this;
          }
          if (encoding === "base64") {
            this.accommodate(Math.ceil(bytes.length / 4) * 3);
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += util.binary.base64.decode(bytes, view, this.write);
            return this;
          }
          if (encoding === "utf8") {
            bytes = util.encodeUtf8(bytes);
            encoding = "binary";
          }
          if (encoding === "binary" || encoding === "raw") {
            this.accommodate(bytes.length);
            view = new Uint8Array(this.data.buffer, this.write);
            this.write += util.binary.raw.decode(view);
            return this;
          }
          if (encoding === "utf16") {
            this.accommodate(bytes.length * 2);
            view = new Uint16Array(this.data.buffer, this.write);
            this.write += util.text.utf16.encode(view);
            return this;
          }
          throw new Error("Invalid encoding: " + encoding);
        }
        throw Error("Invalid parameter: " + bytes);
      };
      util.DataBuffer.prototype.putBuffer = function(buffer) {
        this.putBytes(buffer);
        buffer.clear();
        return this;
      };
      util.DataBuffer.prototype.putString = function(str) {
        return this.putBytes(str, "utf16");
      };
      util.DataBuffer.prototype.putInt16 = function(i) {
        this.accommodate(2);
        this.data.setInt16(this.write, i);
        this.write += 2;
        return this;
      };
      util.DataBuffer.prototype.putInt24 = function(i) {
        this.accommodate(3);
        this.data.setInt16(this.write, i >> 8 & 65535);
        this.data.setInt8(this.write, i >> 16 & 255);
        this.write += 3;
        return this;
      };
      util.DataBuffer.prototype.putInt32 = function(i) {
        this.accommodate(4);
        this.data.setInt32(this.write, i);
        this.write += 4;
        return this;
      };
      util.DataBuffer.prototype.putInt16Le = function(i) {
        this.accommodate(2);
        this.data.setInt16(this.write, i, true);
        this.write += 2;
        return this;
      };
      util.DataBuffer.prototype.putInt24Le = function(i) {
        this.accommodate(3);
        this.data.setInt8(this.write, i >> 16 & 255);
        this.data.setInt16(this.write, i >> 8 & 65535, true);
        this.write += 3;
        return this;
      };
      util.DataBuffer.prototype.putInt32Le = function(i) {
        this.accommodate(4);
        this.data.setInt32(this.write, i, true);
        this.write += 4;
        return this;
      };
      util.DataBuffer.prototype.putInt = function(i, n) {
        _checkBitsParam(n);
        this.accommodate(n / 8);
        do {
          n -= 8;
          this.data.setInt8(this.write++, i >> n & 255);
        } while (n > 0);
        return this;
      };
      util.DataBuffer.prototype.putSignedInt = function(i, n) {
        _checkBitsParam(n);
        this.accommodate(n / 8);
        if (i < 0) {
          i += 2 << n - 1;
        }
        return this.putInt(i, n);
      };
      util.DataBuffer.prototype.getByte = function() {
        return this.data.getInt8(this.read++);
      };
      util.DataBuffer.prototype.getInt16 = function() {
        var rval = this.data.getInt16(this.read);
        this.read += 2;
        return rval;
      };
      util.DataBuffer.prototype.getInt24 = function() {
        var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
        this.read += 3;
        return rval;
      };
      util.DataBuffer.prototype.getInt32 = function() {
        var rval = this.data.getInt32(this.read);
        this.read += 4;
        return rval;
      };
      util.DataBuffer.prototype.getInt16Le = function() {
        var rval = this.data.getInt16(this.read, true);
        this.read += 2;
        return rval;
      };
      util.DataBuffer.prototype.getInt24Le = function() {
        var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
        this.read += 3;
        return rval;
      };
      util.DataBuffer.prototype.getInt32Le = function() {
        var rval = this.data.getInt32(this.read, true);
        this.read += 4;
        return rval;
      };
      util.DataBuffer.prototype.getInt = function(n) {
        _checkBitsParam(n);
        var rval = 0;
        do {
          rval = (rval << 8) + this.data.getInt8(this.read++);
          n -= 8;
        } while (n > 0);
        return rval;
      };
      util.DataBuffer.prototype.getSignedInt = function(n) {
        var x = this.getInt(n);
        var max = 2 << n - 2;
        if (x >= max) {
          x -= max << 1;
        }
        return x;
      };
      util.DataBuffer.prototype.getBytes = function(count) {
        var rval;
        if (count) {
          count = Math.min(this.length(), count);
          rval = this.data.slice(this.read, this.read + count);
          this.read += count;
        } else if (count === 0) {
          rval = "";
        } else {
          rval = this.read === 0 ? this.data : this.data.slice(this.read);
          this.clear();
        }
        return rval;
      };
      util.DataBuffer.prototype.bytes = function(count) {
        return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
      };
      util.DataBuffer.prototype.at = function(i) {
        return this.data.getUint8(this.read + i);
      };
      util.DataBuffer.prototype.setAt = function(i, b) {
        this.data.setUint8(i, b);
        return this;
      };
      util.DataBuffer.prototype.last = function() {
        return this.data.getUint8(this.write - 1);
      };
      util.DataBuffer.prototype.copy = function() {
        return new util.DataBuffer(this);
      };
      util.DataBuffer.prototype.compact = function() {
        if (this.read > 0) {
          var src = new Uint8Array(this.data.buffer, this.read);
          var dst = new Uint8Array(src.byteLength);
          dst.set(src);
          this.data = new DataView(dst);
          this.write -= this.read;
          this.read = 0;
        }
        return this;
      };
      util.DataBuffer.prototype.clear = function() {
        this.data = new DataView(new ArrayBuffer(0));
        this.read = this.write = 0;
        return this;
      };
      util.DataBuffer.prototype.truncate = function(count) {
        this.write = Math.max(0, this.length() - count);
        this.read = Math.min(this.read, this.write);
        return this;
      };
      util.DataBuffer.prototype.toHex = function() {
        var rval = "";
        for (var i = this.read; i < this.data.byteLength; ++i) {
          var b = this.data.getUint8(i);
          if (b < 16) {
            rval += "0";
          }
          rval += b.toString(16);
        }
        return rval;
      };
      util.DataBuffer.prototype.toString = function(encoding) {
        var view = new Uint8Array(this.data, this.read, this.length());
        encoding = encoding || "utf8";
        if (encoding === "binary" || encoding === "raw") {
          return util.binary.raw.encode(view);
        }
        if (encoding === "hex") {
          return util.binary.hex.encode(view);
        }
        if (encoding === "base64") {
          return util.binary.base64.encode(view);
        }
        if (encoding === "utf8") {
          return util.text.utf8.decode(view);
        }
        if (encoding === "utf16") {
          return util.text.utf16.decode(view);
        }
        throw new Error("Invalid encoding: " + encoding);
      };
      util.createBuffer = function(input, encoding) {
        encoding = encoding || "raw";
        if (input !== void 0 && encoding === "utf8") {
          input = util.encodeUtf8(input);
        }
        return new util.ByteBuffer(input);
      };
      util.fillString = function(c, n) {
        var s = "";
        while (n > 0) {
          if (n & 1) {
            s += c;
          }
          n >>>= 1;
          if (n > 0) {
            c += c;
          }
        }
        return s;
      };
      util.xorBytes = function(s1, s2, n) {
        var s3 = "";
        var b = "";
        var t = "";
        var i = 0;
        var c = 0;
        for (; n > 0; --n, ++i) {
          b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
          if (c >= 10) {
            s3 += t;
            t = "";
            c = 0;
          }
          t += String.fromCharCode(b);
          ++c;
        }
        s3 += t;
        return s3;
      };
      util.hexToBytes = function(hex) {
        var rval = "";
        var i = 0;
        if (hex.length & true) {
          i = 1;
          rval += String.fromCharCode(parseInt(hex[0], 16));
        }
        for (; i < hex.length; i += 2) {
          rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
        }
        return rval;
      };
      util.bytesToHex = function(bytes) {
        return util.createBuffer(bytes).toHex();
      };
      util.int32ToBytes = function(i) {
        return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
      };
      var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var _base64Idx = [
        62,
        -1,
        -1,
        -1,
        63,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        64,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51
      ];
      var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
      util.encode64 = function(input, maxline) {
        var line = "";
        var output = "";
        var chr1, chr2, chr3;
        var i = 0;
        while (i < input.length) {
          chr1 = input.charCodeAt(i++);
          chr2 = input.charCodeAt(i++);
          chr3 = input.charCodeAt(i++);
          line += _base64.charAt(chr1 >> 2);
          line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
          if (isNaN(chr2)) {
            line += "==";
          } else {
            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
            line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
          }
          if (maxline && line.length > maxline) {
            output += line.substr(0, maxline) + "\r\n";
            line = line.substr(maxline);
          }
        }
        output += line;
        return output;
      };
      util.decode64 = function(input) {
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        var output = "";
        var enc1, enc2, enc3, enc4;
        var i = 0;
        while (i < input.length) {
          enc1 = _base64Idx[input.charCodeAt(i++) - 43];
          enc2 = _base64Idx[input.charCodeAt(i++) - 43];
          enc3 = _base64Idx[input.charCodeAt(i++) - 43];
          enc4 = _base64Idx[input.charCodeAt(i++) - 43];
          output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
          if (enc3 !== 64) {
            output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
            if (enc4 !== 64) {
              output += String.fromCharCode((enc3 & 3) << 6 | enc4);
            }
          }
        }
        return output;
      };
      util.encodeUtf8 = function(str) {
        return unescape(encodeURIComponent(str));
      };
      util.decodeUtf8 = function(str) {
        return decodeURIComponent(escape(str));
      };
      util.binary = {
        raw: {},
        hex: {},
        base64: {},
        base58: {},
        baseN: {
          encode: baseN.encode,
          decode: baseN.decode
        }
      };
      util.binary.raw.encode = function(bytes) {
        return String.fromCharCode.apply(null, bytes);
      };
      util.binary.raw.decode = function(str, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(str.length);
        }
        offset = offset || 0;
        var j = offset;
        for (var i = 0; i < str.length; ++i) {
          out[j++] = str.charCodeAt(i);
        }
        return output ? j - offset : out;
      };
      util.binary.hex.encode = util.bytesToHex;
      util.binary.hex.decode = function(hex, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(Math.ceil(hex.length / 2));
        }
        offset = offset || 0;
        var i = 0, j = offset;
        if (hex.length & 1) {
          i = 1;
          out[j++] = parseInt(hex[0], 16);
        }
        for (; i < hex.length; i += 2) {
          out[j++] = parseInt(hex.substr(i, 2), 16);
        }
        return output ? j - offset : out;
      };
      util.binary.base64.encode = function(input, maxline) {
        var line = "";
        var output = "";
        var chr1, chr2, chr3;
        var i = 0;
        while (i < input.byteLength) {
          chr1 = input[i++];
          chr2 = input[i++];
          chr3 = input[i++];
          line += _base64.charAt(chr1 >> 2);
          line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
          if (isNaN(chr2)) {
            line += "==";
          } else {
            line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
            line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
          }
          if (maxline && line.length > maxline) {
            output += line.substr(0, maxline) + "\r\n";
            line = line.substr(maxline);
          }
        }
        output += line;
        return output;
      };
      util.binary.base64.decode = function(input, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(Math.ceil(input.length / 4) * 3);
        }
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        offset = offset || 0;
        var enc1, enc2, enc3, enc4;
        var i = 0, j = offset;
        while (i < input.length) {
          enc1 = _base64Idx[input.charCodeAt(i++) - 43];
          enc2 = _base64Idx[input.charCodeAt(i++) - 43];
          enc3 = _base64Idx[input.charCodeAt(i++) - 43];
          enc4 = _base64Idx[input.charCodeAt(i++) - 43];
          out[j++] = enc1 << 2 | enc2 >> 4;
          if (enc3 !== 64) {
            out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
            if (enc4 !== 64) {
              out[j++] = (enc3 & 3) << 6 | enc4;
            }
          }
        }
        return output ? j - offset : out.subarray(0, j);
      };
      util.binary.base58.encode = function(input, maxline) {
        return util.binary.baseN.encode(input, _base58, maxline);
      };
      util.binary.base58.decode = function(input, maxline) {
        return util.binary.baseN.decode(input, _base58, maxline);
      };
      util.text = {
        utf8: {},
        utf16: {}
      };
      util.text.utf8.encode = function(str, output, offset) {
        str = util.encodeUtf8(str);
        var out = output;
        if (!out) {
          out = new Uint8Array(str.length);
        }
        offset = offset || 0;
        var j = offset;
        for (var i = 0; i < str.length; ++i) {
          out[j++] = str.charCodeAt(i);
        }
        return output ? j - offset : out;
      };
      util.text.utf8.decode = function(bytes) {
        return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
      };
      util.text.utf16.encode = function(str, output, offset) {
        var out = output;
        if (!out) {
          out = new Uint8Array(str.length * 2);
        }
        var view = new Uint16Array(out.buffer);
        offset = offset || 0;
        var j = offset;
        var k = offset;
        for (var i = 0; i < str.length; ++i) {
          view[k++] = str.charCodeAt(i);
          j += 2;
        }
        return output ? j - offset : out;
      };
      util.text.utf16.decode = function(bytes) {
        return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
      };
      util.deflate = function(api, bytes, raw) {
        bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
        if (raw) {
          var start = 2;
          var flg = bytes.charCodeAt(1);
          if (flg & 32) {
            start = 6;
          }
          bytes = bytes.substring(start, bytes.length - 4);
        }
        return bytes;
      };
      util.inflate = function(api, bytes, raw) {
        var rval = api.inflate(util.encode64(bytes)).rval;
        return rval === null ? null : util.decode64(rval);
      };
      var _setStorageObject = function(api, id, obj) {
        if (!api) {
          throw new Error("WebStorage not available.");
        }
        var rval;
        if (obj === null) {
          rval = api.removeItem(id);
        } else {
          obj = util.encode64(JSON.stringify(obj));
          rval = api.setItem(id, obj);
        }
        if (typeof rval !== "undefined" && rval.rval !== true) {
          var error = new Error(rval.error.message);
          error.id = rval.error.id;
          error.name = rval.error.name;
          throw error;
        }
      };
      var _getStorageObject = function(api, id) {
        if (!api) {
          throw new Error("WebStorage not available.");
        }
        var rval = api.getItem(id);
        if (api.init) {
          if (rval.rval === null) {
            if (rval.error) {
              var error = new Error(rval.error.message);
              error.id = rval.error.id;
              error.name = rval.error.name;
              throw error;
            }
            rval = null;
          } else {
            rval = rval.rval;
          }
        }
        if (rval !== null) {
          rval = JSON.parse(util.decode64(rval));
        }
        return rval;
      };
      var _setItem = function(api, id, key, data) {
        var obj = _getStorageObject(api, id);
        if (obj === null) {
          obj = {};
        }
        obj[key] = data;
        _setStorageObject(api, id, obj);
      };
      var _getItem = function(api, id, key) {
        var rval = _getStorageObject(api, id);
        if (rval !== null) {
          rval = key in rval ? rval[key] : null;
        }
        return rval;
      };
      var _removeItem = function(api, id, key) {
        var obj = _getStorageObject(api, id);
        if (obj !== null && key in obj) {
          delete obj[key];
          var empty = true;
          for (var prop in obj) {
            empty = false;
            break;
          }
          if (empty) {
            obj = null;
          }
          _setStorageObject(api, id, obj);
        }
      };
      var _clearItems = function(api, id) {
        _setStorageObject(api, id, null);
      };
      var _callStorageFunction = function(func, args, location) {
        var rval = null;
        if (typeof location === "undefined") {
          location = ["web", "flash"];
        }
        var type;
        var done = false;
        var exception = null;
        for (var idx in location) {
          type = location[idx];
          try {
            if (type === "flash" || type === "both") {
              if (args[0] === null) {
                throw new Error("Flash local storage not available.");
              }
              rval = func.apply(this, args);
              done = type === "flash";
            }
            if (type === "web" || type === "both") {
              args[0] = localStorage;
              rval = func.apply(this, args);
              done = true;
            }
          } catch (ex) {
            exception = ex;
          }
          if (done) {
            break;
          }
        }
        if (!done) {
          throw exception;
        }
        return rval;
      };
      util.setItem = function(api, id, key, data, location) {
        _callStorageFunction(_setItem, arguments, location);
      };
      util.getItem = function(api, id, key, location) {
        return _callStorageFunction(_getItem, arguments, location);
      };
      util.removeItem = function(api, id, key, location) {
        _callStorageFunction(_removeItem, arguments, location);
      };
      util.clearItems = function(api, id, location) {
        _callStorageFunction(_clearItems, arguments, location);
      };
      util.parseUrl = function(str) {
        var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
        regex.lastIndex = 0;
        var m = regex.exec(str);
        var url = m === null ? null : {
          full: str,
          scheme: m[1],
          host: m[2],
          port: m[3],
          path: m[4]
        };
        if (url) {
          url.fullHost = url.host;
          if (url.port) {
            if (url.port !== 80 && url.scheme === "http") {
              url.fullHost += ":" + url.port;
            } else if (url.port !== 443 && url.scheme === "https") {
              url.fullHost += ":" + url.port;
            }
          } else if (url.scheme === "http") {
            url.port = 80;
          } else if (url.scheme === "https") {
            url.port = 443;
          }
          url.full = url.scheme + "://" + url.fullHost;
        }
        return url;
      };
      var _queryVariables = null;
      util.getQueryVariables = function(query) {
        var parse = function(q) {
          var rval2 = {};
          var kvpairs = q.split("&");
          for (var i = 0; i < kvpairs.length; i++) {
            var pos = kvpairs[i].indexOf("=");
            var key;
            var val;
            if (pos > 0) {
              key = kvpairs[i].substring(0, pos);
              val = kvpairs[i].substring(pos + 1);
            } else {
              key = kvpairs[i];
              val = null;
            }
            if (!(key in rval2)) {
              rval2[key] = [];
            }
            if (!(key in Object.prototype) && val !== null) {
              rval2[key].push(unescape(val));
            }
          }
          return rval2;
        };
        var rval;
        if (typeof query === "undefined") {
          if (_queryVariables === null) {
            if (typeof window !== "undefined" && window.location && window.location.search) {
              _queryVariables = parse(window.location.search.substring(1));
            } else {
              _queryVariables = {};
            }
          }
          rval = _queryVariables;
        } else {
          rval = parse(query);
        }
        return rval;
      };
      util.parseFragment = function(fragment) {
        var fp = fragment;
        var fq = "";
        var pos = fragment.indexOf("?");
        if (pos > 0) {
          fp = fragment.substring(0, pos);
          fq = fragment.substring(pos + 1);
        }
        var path = fp.split("/");
        if (path.length > 0 && path[0] === "") {
          path.shift();
        }
        var query = fq === "" ? {} : util.getQueryVariables(fq);
        return {
          pathString: fp,
          queryString: fq,
          path,
          query
        };
      };
      util.makeRequest = function(reqString) {
        var frag = util.parseFragment(reqString);
        var req = {
          path: frag.pathString,
          query: frag.queryString,
          getPath: function(i) {
            return typeof i === "undefined" ? frag.path : frag.path[i];
          },
          getQuery: function(k, i) {
            var rval;
            if (typeof k === "undefined") {
              rval = frag.query;
            } else {
              rval = frag.query[k];
              if (rval && typeof i !== "undefined") {
                rval = rval[i];
              }
            }
            return rval;
          },
          getQueryLast: function(k, _default) {
            var rval;
            var vals = req.getQuery(k);
            if (vals) {
              rval = vals[vals.length - 1];
            } else {
              rval = _default;
            }
            return rval;
          }
        };
        return req;
      };
      util.makeLink = function(path, query, fragment) {
        path = jQuery.isArray(path) ? path.join("/") : path;
        var qstr = jQuery.param(query || {});
        fragment = fragment || "";
        return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
      };
      util.isEmpty = function(obj) {
        for (var prop in obj) {
          if (obj.hasOwnProperty(prop)) {
            return false;
          }
        }
        return true;
      };
      util.format = function(format) {
        var re = /%./g;
        var match;
        var part;
        var argi = 0;
        var parts = [];
        var last = 0;
        while (match = re.exec(format)) {
          part = format.substring(last, re.lastIndex - 2);
          if (part.length > 0) {
            parts.push(part);
          }
          last = re.lastIndex;
          var code = match[0][1];
          switch (code) {
            case "s":
            case "o":
              if (argi < arguments.length) {
                parts.push(arguments[argi++ + 1]);
              } else {
                parts.push("<?>");
              }
              break;
            case "%":
              parts.push("%");
              break;
            default:
              parts.push("<%" + code + "?>");
          }
        }
        parts.push(format.substring(last));
        return parts.join("");
      };
      util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
        var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
        var d = dec_point === void 0 ? "," : dec_point;
        var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
        var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
        var j = i.length > 3 ? i.length % 3 : 0;
        return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
      };
      util.formatSize = function(size) {
        if (size >= 1073741824) {
          size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
        } else if (size >= 1048576) {
          size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
        } else if (size >= 1024) {
          size = util.formatNumber(size / 1024, 0) + " KiB";
        } else {
          size = util.formatNumber(size, 0) + " bytes";
        }
        return size;
      };
      util.bytesFromIP = function(ip) {
        if (ip.indexOf(".") !== -1) {
          return util.bytesFromIPv4(ip);
        }
        if (ip.indexOf(":") !== -1) {
          return util.bytesFromIPv6(ip);
        }
        return null;
      };
      util.bytesFromIPv4 = function(ip) {
        ip = ip.split(".");
        if (ip.length !== 4) {
          return null;
        }
        var b = util.createBuffer();
        for (var i = 0; i < ip.length; ++i) {
          var num = parseInt(ip[i], 10);
          if (isNaN(num)) {
            return null;
          }
          b.putByte(num);
        }
        return b.getBytes();
      };
      util.bytesFromIPv6 = function(ip) {
        var blanks = 0;
        ip = ip.split(":").filter(function(e) {
          if (e.length === 0)
            ++blanks;
          return true;
        });
        var zeros = (8 - ip.length + blanks) * 2;
        var b = util.createBuffer();
        for (var i = 0; i < 8; ++i) {
          if (!ip[i] || ip[i].length === 0) {
            b.fillWithByte(0, zeros);
            zeros = 0;
            continue;
          }
          var bytes = util.hexToBytes(ip[i]);
          if (bytes.length < 2) {
            b.putByte(0);
          }
          b.putBytes(bytes);
        }
        return b.getBytes();
      };
      util.bytesToIP = function(bytes) {
        if (bytes.length === 4) {
          return util.bytesToIPv4(bytes);
        }
        if (bytes.length === 16) {
          return util.bytesToIPv6(bytes);
        }
        return null;
      };
      util.bytesToIPv4 = function(bytes) {
        if (bytes.length !== 4) {
          return null;
        }
        var ip = [];
        for (var i = 0; i < bytes.length; ++i) {
          ip.push(bytes.charCodeAt(i));
        }
        return ip.join(".");
      };
      util.bytesToIPv6 = function(bytes) {
        if (bytes.length !== 16) {
          return null;
        }
        var ip = [];
        var zeroGroups = [];
        var zeroMaxGroup = 0;
        for (var i = 0; i < bytes.length; i += 2) {
          var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
          while (hex[0] === "0" && hex !== "0") {
            hex = hex.substr(1);
          }
          if (hex === "0") {
            var last = zeroGroups[zeroGroups.length - 1];
            var idx = ip.length;
            if (!last || idx !== last.end + 1) {
              zeroGroups.push({ start: idx, end: idx });
            } else {
              last.end = idx;
              if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
                zeroMaxGroup = zeroGroups.length - 1;
              }
            }
          }
          ip.push(hex);
        }
        if (zeroGroups.length > 0) {
          var group = zeroGroups[zeroMaxGroup];
          if (group.end - group.start > 0) {
            ip.splice(group.start, group.end - group.start + 1, "");
            if (group.start === 0) {
              ip.unshift("");
            }
            if (group.end === 7) {
              ip.push("");
            }
          }
        }
        return ip.join(":");
      };
      util.estimateCores = function(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        if ("cores" in util && !options.update) {
          return callback(null, util.cores);
        }
        if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
          util.cores = navigator.hardwareConcurrency;
          return callback(null, util.cores);
        }
        if (typeof Worker === "undefined") {
          util.cores = 1;
          return callback(null, util.cores);
        }
        if (typeof Blob === "undefined") {
          util.cores = 2;
          return callback(null, util.cores);
        }
        var blobUrl = URL.createObjectURL(new Blob([
          "(",
          function() {
            self.addEventListener("message", function(e) {
              var st = Date.now();
              var et = st + 4;
              while (Date.now() < et)
                ;
              self.postMessage({ st, et });
            });
          }.toString(),
          ")()"
        ], { type: "application/javascript" }));
        sample([], 5, 16);
        function sample(max, samples, numWorkers) {
          if (samples === 0) {
            var avg = Math.floor(max.reduce(function(avg2, x) {
              return avg2 + x;
            }, 0) / max.length);
            util.cores = Math.max(1, avg);
            URL.revokeObjectURL(blobUrl);
            return callback(null, util.cores);
          }
          map(numWorkers, function(err, results) {
            max.push(reduce(numWorkers, results));
            sample(max, samples - 1, numWorkers);
          });
        }
        function map(numWorkers, callback2) {
          var workers = [];
          var results = [];
          for (var i = 0; i < numWorkers; ++i) {
            var worker = new Worker(blobUrl);
            worker.addEventListener("message", function(e) {
              results.push(e.data);
              if (results.length === numWorkers) {
                for (var i2 = 0; i2 < numWorkers; ++i2) {
                  workers[i2].terminate();
                }
                callback2(null, results);
              }
            });
            workers.push(worker);
          }
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].postMessage(i);
          }
        }
        function reduce(numWorkers, results) {
          var overlaps = [];
          for (var n = 0; n < numWorkers; ++n) {
            var r1 = results[n];
            var overlap = overlaps[n] = [];
            for (var i = 0; i < numWorkers; ++i) {
              if (n === i) {
                continue;
              }
              var r2 = results[i];
              if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
                overlap.push(i);
              }
            }
          }
          return overlaps.reduce(function(max, overlap2) {
            return Math.max(max, overlap2.length);
          }, 0);
        }
      };
    }
  });

  // node_modules/node-forge/lib/cipher.js
  var require_cipher = __commonJS({
    "node_modules/node-forge/lib/cipher.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      module.exports = forge.cipher = forge.cipher || {};
      forge.cipher.algorithms = forge.cipher.algorithms || {};
      forge.cipher.createCipher = function(algorithm, key) {
        var api = algorithm;
        if (typeof api === "string") {
          api = forge.cipher.getAlgorithm(api);
          if (api) {
            api = api();
          }
        }
        if (!api) {
          throw new Error("Unsupported algorithm: " + algorithm);
        }
        return new forge.cipher.BlockCipher({
          algorithm: api,
          key,
          decrypt: false
        });
      };
      forge.cipher.createDecipher = function(algorithm, key) {
        var api = algorithm;
        if (typeof api === "string") {
          api = forge.cipher.getAlgorithm(api);
          if (api) {
            api = api();
          }
        }
        if (!api) {
          throw new Error("Unsupported algorithm: " + algorithm);
        }
        return new forge.cipher.BlockCipher({
          algorithm: api,
          key,
          decrypt: true
        });
      };
      forge.cipher.registerAlgorithm = function(name, algorithm) {
        name = name.toUpperCase();
        forge.cipher.algorithms[name] = algorithm;
      };
      forge.cipher.getAlgorithm = function(name) {
        name = name.toUpperCase();
        if (name in forge.cipher.algorithms) {
          return forge.cipher.algorithms[name];
        }
        return null;
      };
      var BlockCipher = forge.cipher.BlockCipher = function(options) {
        this.algorithm = options.algorithm;
        this.mode = this.algorithm.mode;
        this.blockSize = this.mode.blockSize;
        this._finish = false;
        this._input = null;
        this.output = null;
        this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
        this._decrypt = options.decrypt;
        this.algorithm.initialize(options);
      };
      BlockCipher.prototype.start = function(options) {
        options = options || {};
        var opts = {};
        for (var key in options) {
          opts[key] = options[key];
        }
        opts.decrypt = this._decrypt;
        this._finish = false;
        this._input = forge.util.createBuffer();
        this.output = options.output || forge.util.createBuffer();
        this.mode.start(opts);
      };
      BlockCipher.prototype.update = function(input) {
        if (input) {
          this._input.putBuffer(input);
        }
        while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
        }
        this._input.compact();
      };
      BlockCipher.prototype.finish = function(pad) {
        if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
          this.mode.pad = function(input) {
            return pad(this.blockSize, input, false);
          };
          this.mode.unpad = function(output) {
            return pad(this.blockSize, output, true);
          };
        }
        var options = {};
        options.decrypt = this._decrypt;
        options.overflow = this._input.length() % this.blockSize;
        if (!this._decrypt && this.mode.pad) {
          if (!this.mode.pad(this._input, options)) {
            return false;
          }
        }
        this._finish = true;
        this.update();
        if (this._decrypt && this.mode.unpad) {
          if (!this.mode.unpad(this.output, options)) {
            return false;
          }
        }
        if (this.mode.afterFinish) {
          if (!this.mode.afterFinish(this.output, options)) {
            return false;
          }
        }
        return true;
      };
    }
  });

  // node_modules/node-forge/lib/cipherModes.js
  var require_cipherModes = __commonJS({
    "node_modules/node-forge/lib/cipherModes.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      forge.cipher = forge.cipher || {};
      var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
      modes.ecb = function(options) {
        options = options || {};
        this.name = "ECB";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = new Array(this._ints);
        this._outBlock = new Array(this._ints);
      };
      modes.ecb.prototype.start = function(options) {
      };
      modes.ecb.prototype.encrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i]);
        }
      };
      modes.ecb.prototype.decrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
        }
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i]);
        }
      };
      modes.ecb.prototype.pad = function(input, options) {
        var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
        input.fillWithByte(padding, padding);
        return true;
      };
      modes.ecb.prototype.unpad = function(output, options) {
        if (options.overflow > 0) {
          return false;
        }
        var len = output.length();
        var count = output.at(len - 1);
        if (count > this.blockSize << 2) {
          return false;
        }
        output.truncate(count);
        return true;
      };
      modes.cbc = function(options) {
        options = options || {};
        this.name = "CBC";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = new Array(this._ints);
        this._outBlock = new Array(this._ints);
      };
      modes.cbc.prototype.start = function(options) {
        if (options.iv === null) {
          if (!this._prev) {
            throw new Error("Invalid IV parameter.");
          }
          this._iv = this._prev.slice(0);
        } else if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        } else {
          this._iv = transformIV(options.iv, this.blockSize);
          this._prev = this._iv.slice(0);
        }
      };
      modes.cbc.prototype.encrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._prev[i] ^ input.getInt32();
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i]);
        }
        this._prev = this._outBlock;
      };
      modes.cbc.prototype.decrypt = function(input, output, finish) {
        if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
          return true;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
        }
        this.cipher.decrypt(this._inBlock, this._outBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._prev[i] ^ this._outBlock[i]);
        }
        this._prev = this._inBlock.slice(0);
      };
      modes.cbc.prototype.pad = function(input, options) {
        var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
        input.fillWithByte(padding, padding);
        return true;
      };
      modes.cbc.prototype.unpad = function(output, options) {
        if (options.overflow > 0) {
          return false;
        }
        var len = output.length();
        var count = output.at(len - 1);
        if (count > this.blockSize << 2) {
          return false;
        }
        output.truncate(count);
        return true;
      };
      modes.cfb = function(options) {
        options = options || {};
        this.name = "CFB";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = null;
        this._outBlock = new Array(this._ints);
        this._partialBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
      };
      modes.cfb.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = transformIV(options.iv, this.blockSize);
        this._inBlock = this._iv.slice(0);
        this._partialBytes = 0;
      };
      modes.cfb.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
            output.putInt32(this._inBlock[i]);
          }
          return;
        }
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
          this._partialOutput.putInt32(this._partialBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        } else {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._partialBlock[i];
          }
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      };
      modes.cfb.prototype.decrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = input.getInt32();
            output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
          }
          return;
        }
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialBlock[i] = input.getInt32();
          this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        } else {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._partialBlock[i];
          }
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      };
      modes.ofb = function(options) {
        options = options || {};
        this.name = "OFB";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = null;
        this._outBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
      };
      modes.ofb.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = transformIV(options.iv, this.blockSize);
        this._inBlock = this._iv.slice(0);
        this._partialBytes = 0;
      };
      modes.ofb.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (input.length() === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(input.getInt32() ^ this._outBlock[i]);
            this._inBlock[i] = this._outBlock[i];
          }
          return;
        }
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        } else {
          for (var i = 0; i < this._ints; ++i) {
            this._inBlock[i] = this._outBlock[i];
          }
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      };
      modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
      modes.ctr = function(options) {
        options = options || {};
        this.name = "CTR";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = null;
        this._outBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
      };
      modes.ctr.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = transformIV(options.iv, this.blockSize);
        this._inBlock = this._iv.slice(0);
        this._partialBytes = 0;
      };
      modes.ctr.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
        } else {
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
          if (partialBytes > 0) {
            input.read -= this.blockSize;
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
          this._partialBytes = 0;
        }
        inc32(this._inBlock);
      };
      modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
      modes.gcm = function(options) {
        options = options || {};
        this.name = "GCM";
        this.cipher = options.cipher;
        this.blockSize = options.blockSize || 16;
        this._ints = this.blockSize / 4;
        this._inBlock = new Array(this._ints);
        this._outBlock = new Array(this._ints);
        this._partialOutput = forge.util.createBuffer();
        this._partialBytes = 0;
        this._R = 3774873600;
      };
      modes.gcm.prototype.start = function(options) {
        if (!("iv" in options)) {
          throw new Error("Invalid IV parameter.");
        }
        var iv = forge.util.createBuffer(options.iv);
        this._cipherLength = 0;
        var additionalData;
        if ("additionalData" in options) {
          additionalData = forge.util.createBuffer(options.additionalData);
        } else {
          additionalData = forge.util.createBuffer();
        }
        if ("tagLength" in options) {
          this._tagLength = options.tagLength;
        } else {
          this._tagLength = 128;
        }
        this._tag = null;
        if (options.decrypt) {
          this._tag = forge.util.createBuffer(options.tag).getBytes();
          if (this._tag.length !== this._tagLength / 8) {
            throw new Error("Authentication tag does not match tag length.");
          }
        }
        this._hashBlock = new Array(this._ints);
        this.tag = null;
        this._hashSubkey = new Array(this._ints);
        this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
        this.componentBits = 4;
        this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
        var ivLength = iv.length();
        if (ivLength === 12) {
          this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
        } else {
          this._j0 = [0, 0, 0, 0];
          while (iv.length() > 0) {
            this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
          }
          this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
        }
        this._inBlock = this._j0.slice(0);
        inc32(this._inBlock);
        this._partialBytes = 0;
        additionalData = forge.util.createBuffer(additionalData);
        this._aDataLength = from64To32(additionalData.length() * 8);
        var overflow = additionalData.length() % this.blockSize;
        if (overflow) {
          additionalData.fillWithByte(0, this.blockSize - overflow);
        }
        this._s = [0, 0, 0, 0];
        while (additionalData.length() > 0) {
          this._s = this.ghash(this._hashSubkey, this._s, [
            additionalData.getInt32(),
            additionalData.getInt32(),
            additionalData.getInt32(),
            additionalData.getInt32()
          ]);
        }
      };
      modes.gcm.prototype.encrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength === 0) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        if (this._partialBytes === 0 && inputLength >= this.blockSize) {
          for (var i = 0; i < this._ints; ++i) {
            output.putInt32(this._outBlock[i] ^= input.getInt32());
          }
          this._cipherLength += this.blockSize;
        } else {
          var partialBytes = (this.blockSize - inputLength) % this.blockSize;
          if (partialBytes > 0) {
            partialBytes = this.blockSize - partialBytes;
          }
          this._partialOutput.clear();
          for (var i = 0; i < this._ints; ++i) {
            this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
          }
          if (partialBytes <= 0 || finish) {
            if (finish) {
              var overflow = inputLength % this.blockSize;
              this._cipherLength += overflow;
              this._partialOutput.truncate(this.blockSize - overflow);
            } else {
              this._cipherLength += this.blockSize;
            }
            for (var i = 0; i < this._ints; ++i) {
              this._outBlock[i] = this._partialOutput.getInt32();
            }
            this._partialOutput.read -= this.blockSize;
          }
          if (this._partialBytes > 0) {
            this._partialOutput.getBytes(this._partialBytes);
          }
          if (partialBytes > 0 && !finish) {
            input.read -= this.blockSize;
            output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
            this._partialBytes = partialBytes;
            return true;
          }
          output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
          this._partialBytes = 0;
        }
        this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
        inc32(this._inBlock);
      };
      modes.gcm.prototype.decrypt = function(input, output, finish) {
        var inputLength = input.length();
        if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
          return true;
        }
        this.cipher.encrypt(this._inBlock, this._outBlock);
        inc32(this._inBlock);
        this._hashBlock[0] = input.getInt32();
        this._hashBlock[1] = input.getInt32();
        this._hashBlock[2] = input.getInt32();
        this._hashBlock[3] = input.getInt32();
        this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
        }
        if (inputLength < this.blockSize) {
          this._cipherLength += inputLength % this.blockSize;
        } else {
          this._cipherLength += this.blockSize;
        }
      };
      modes.gcm.prototype.afterFinish = function(output, options) {
        var rval = true;
        if (options.decrypt && options.overflow) {
          output.truncate(this.blockSize - options.overflow);
        }
        this.tag = forge.util.createBuffer();
        var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
        this._s = this.ghash(this._hashSubkey, this._s, lengths);
        var tag = [];
        this.cipher.encrypt(this._j0, tag);
        for (var i = 0; i < this._ints; ++i) {
          this.tag.putInt32(this._s[i] ^ tag[i]);
        }
        this.tag.truncate(this.tag.length() % (this._tagLength / 8));
        if (options.decrypt && this.tag.bytes() !== this._tag) {
          rval = false;
        }
        return rval;
      };
      modes.gcm.prototype.multiply = function(x, y) {
        var z_i = [0, 0, 0, 0];
        var v_i = y.slice(0);
        for (var i = 0; i < 128; ++i) {
          var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
          if (x_i) {
            z_i[0] ^= v_i[0];
            z_i[1] ^= v_i[1];
            z_i[2] ^= v_i[2];
            z_i[3] ^= v_i[3];
          }
          this.pow(v_i, v_i);
        }
        return z_i;
      };
      modes.gcm.prototype.pow = function(x, out) {
        var lsb = x[3] & 1;
        for (var i = 3; i > 0; --i) {
          out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
        }
        out[0] = x[0] >>> 1;
        if (lsb) {
          out[0] ^= this._R;
        }
      };
      modes.gcm.prototype.tableMultiply = function(x) {
        var z = [0, 0, 0, 0];
        for (var i = 0; i < 32; ++i) {
          var idx = i / 8 | 0;
          var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
          var ah = this._m[i][x_i];
          z[0] ^= ah[0];
          z[1] ^= ah[1];
          z[2] ^= ah[2];
          z[3] ^= ah[3];
        }
        return z;
      };
      modes.gcm.prototype.ghash = function(h, y, x) {
        y[0] ^= x[0];
        y[1] ^= x[1];
        y[2] ^= x[2];
        y[3] ^= x[3];
        return this.tableMultiply(y);
      };
      modes.gcm.prototype.generateHashTable = function(h, bits) {
        var multiplier = 8 / bits;
        var perInt = 4 * multiplier;
        var size = 16 * multiplier;
        var m = new Array(size);
        for (var i = 0; i < size; ++i) {
          var tmp = [0, 0, 0, 0];
          var idx = i / perInt | 0;
          var shft = (perInt - 1 - i % perInt) * bits;
          tmp[idx] = 1 << bits - 1 << shft;
          m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
        }
        return m;
      };
      modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
        var size = 1 << bits;
        var half = size >>> 1;
        var m = new Array(size);
        m[half] = mid.slice(0);
        var i = half >>> 1;
        while (i > 0) {
          this.pow(m[2 * i], m[i] = []);
          i >>= 1;
        }
        i = 2;
        while (i < half) {
          for (var j = 1; j < i; ++j) {
            var m_i = m[i];
            var m_j = m[j];
            m[i + j] = [
              m_i[0] ^ m_j[0],
              m_i[1] ^ m_j[1],
              m_i[2] ^ m_j[2],
              m_i[3] ^ m_j[3]
            ];
          }
          i *= 2;
        }
        m[0] = [0, 0, 0, 0];
        for (i = half + 1; i < size; ++i) {
          var c = m[i ^ half];
          m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
        }
        return m;
      };
      function transformIV(iv, blockSize) {
        if (typeof iv === "string") {
          iv = forge.util.createBuffer(iv);
        }
        if (forge.util.isArray(iv) && iv.length > 4) {
          var tmp = iv;
          iv = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) {
            iv.putByte(tmp[i]);
          }
        }
        if (iv.length() < blockSize) {
          throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
        }
        if (!forge.util.isArray(iv)) {
          var ints = [];
          var blocks = blockSize / 4;
          for (var i = 0; i < blocks; ++i) {
            ints.push(iv.getInt32());
          }
          iv = ints;
        }
        return iv;
      }
      function inc32(block) {
        block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
      }
      function from64To32(num) {
        return [num / 4294967296 | 0, num & 4294967295];
      }
    }
  });

  // node_modules/node-forge/lib/aes.js
  var require_aes = __commonJS({
    "node_modules/node-forge/lib/aes.js"(exports, module) {
      var forge = require_forge();
      require_cipher();
      require_cipherModes();
      require_util4();
      module.exports = forge.aes = forge.aes || {};
      forge.aes.startEncrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: false,
          mode
        });
        cipher.start(iv);
        return cipher;
      };
      forge.aes.createEncryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: false,
          mode
        });
      };
      forge.aes.startDecrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: true,
          mode
        });
        cipher.start(iv);
        return cipher;
      };
      forge.aes.createDecryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: true,
          mode
        });
      };
      forge.aes.Algorithm = function(name, mode) {
        if (!init) {
          initialize();
        }
        var self2 = this;
        self2.name = name;
        self2.mode = new mode({
          blockSize: 16,
          cipher: {
            encrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._w, inBlock, outBlock, false);
            },
            decrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._w, inBlock, outBlock, true);
            }
          }
        });
        self2._init = false;
      };
      forge.aes.Algorithm.prototype.initialize = function(options) {
        if (this._init) {
          return;
        }
        var key = options.key;
        var tmp;
        if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
          key = forge.util.createBuffer(key);
        } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
          tmp = key;
          key = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) {
            key.putByte(tmp[i]);
          }
        }
        if (!forge.util.isArray(key)) {
          tmp = key;
          key = [];
          var len = tmp.length();
          if (len === 16 || len === 24 || len === 32) {
            len = len >>> 2;
            for (var i = 0; i < len; ++i) {
              key.push(tmp.getInt32());
            }
          }
        }
        if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
          throw new Error("Invalid key parameter.");
        }
        var mode = this.mode.name;
        var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
        this._w = _expandKey(key, options.decrypt && !encryptOp);
        this._init = true;
      };
      forge.aes._expandKey = function(key, decrypt) {
        if (!init) {
          initialize();
        }
        return _expandKey(key, decrypt);
      };
      forge.aes._updateBlock = _updateBlock;
      registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
      registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
      registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
      registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
      registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
      registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
      function registerAlgorithm(name, mode) {
        var factory = function() {
          return new forge.aes.Algorithm(name, mode);
        };
        forge.cipher.registerAlgorithm(name, factory);
      }
      var init = false;
      var Nb = 4;
      var sbox;
      var isbox;
      var rcon;
      var mix;
      var imix;
      function initialize() {
        init = true;
        rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var xtime = new Array(256);
        for (var i = 0; i < 128; ++i) {
          xtime[i] = i << 1;
          xtime[i + 128] = i + 128 << 1 ^ 283;
        }
        sbox = new Array(256);
        isbox = new Array(256);
        mix = new Array(4);
        imix = new Array(4);
        for (var i = 0; i < 4; ++i) {
          mix[i] = new Array(256);
          imix[i] = new Array(256);
        }
        var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
        for (var i = 0; i < 256; ++i) {
          sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
          sx = sx >> 8 ^ sx & 255 ^ 99;
          sbox[e] = sx;
          isbox[sx] = e;
          sx2 = xtime[sx];
          e2 = xtime[e];
          e4 = xtime[e2];
          e8 = xtime[e4];
          me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
          ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
          for (var n = 0; n < 4; ++n) {
            mix[n][e] = me;
            imix[n][sx] = ime;
            me = me << 24 | me >>> 8;
            ime = ime << 24 | ime >>> 8;
          }
          if (e === 0) {
            e = ei = 1;
          } else {
            e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
            ei ^= xtime[xtime[ei]];
          }
        }
      }
      function _expandKey(key, decrypt) {
        var w = key.slice(0);
        var temp, iNk = 1;
        var Nk = w.length;
        var Nr1 = Nk + 6 + 1;
        var end = Nb * Nr1;
        for (var i = Nk; i < end; ++i) {
          temp = w[i - 1];
          if (i % Nk === 0) {
            temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
            iNk++;
          } else if (Nk > 6 && i % Nk === 4) {
            temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
          }
          w[i] = w[i - Nk] ^ temp;
        }
        if (decrypt) {
          var tmp;
          var m0 = imix[0];
          var m1 = imix[1];
          var m2 = imix[2];
          var m3 = imix[3];
          var wnew = w.slice(0);
          end = w.length;
          for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
            if (i === 0 || i === end - Nb) {
              wnew[i] = w[wi];
              wnew[i + 1] = w[wi + 3];
              wnew[i + 2] = w[wi + 2];
              wnew[i + 3] = w[wi + 1];
            } else {
              for (var n = 0; n < Nb; ++n) {
                tmp = w[wi + n];
                wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
              }
            }
          }
          w = wnew;
        }
        return w;
      }
      function _updateBlock(w, input, output, decrypt) {
        var Nr = w.length / 4 - 1;
        var m0, m1, m2, m3, sub;
        if (decrypt) {
          m0 = imix[0];
          m1 = imix[1];
          m2 = imix[2];
          m3 = imix[3];
          sub = isbox;
        } else {
          m0 = mix[0];
          m1 = mix[1];
          m2 = mix[2];
          m3 = mix[3];
          sub = sbox;
        }
        var a, b, c, d, a2, b2, c2;
        a = input[0] ^ w[0];
        b = input[decrypt ? 3 : 1] ^ w[1];
        c = input[2] ^ w[2];
        d = input[decrypt ? 1 : 3] ^ w[3];
        var i = 3;
        for (var round = 1; round < Nr; ++round) {
          a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
          b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
          c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
          d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
          a = a2;
          b = b2;
          c = c2;
        }
        output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
        output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
        output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
        output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
      }
      function _createCipher(options) {
        options = options || {};
        var mode = (options.mode || "CBC").toUpperCase();
        var algorithm = "AES-" + mode;
        var cipher;
        if (options.decrypt) {
          cipher = forge.cipher.createDecipher(algorithm, options.key);
        } else {
          cipher = forge.cipher.createCipher(algorithm, options.key);
        }
        var start = cipher.start;
        cipher.start = function(iv, options2) {
          var output = null;
          if (options2 instanceof forge.util.ByteBuffer) {
            output = options2;
            options2 = {};
          }
          options2 = options2 || {};
          options2.output = output;
          options2.iv = iv;
          start.call(cipher, options2);
        };
        return cipher;
      }
    }
  });

  // node_modules/node-forge/lib/oids.js
  var require_oids = __commonJS({
    "node_modules/node-forge/lib/oids.js"(exports, module) {
      var forge = require_forge();
      forge.pki = forge.pki || {};
      var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
      function _IN(id, name) {
        oids[id] = name;
        oids[name] = id;
      }
      function _I_(id, name) {
        oids[id] = name;
      }
      _IN("1.2.840.113549.1.1.1", "rsaEncryption");
      _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
      _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
      _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
      _IN("1.2.840.113549.1.1.8", "mgf1");
      _IN("1.2.840.113549.1.1.9", "pSpecified");
      _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
      _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
      _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
      _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
      _IN("1.3.101.112", "EdDSA25519");
      _IN("1.2.840.10040.4.3", "dsa-with-sha1");
      _IN("1.3.14.3.2.7", "desCBC");
      _IN("1.3.14.3.2.26", "sha1");
      _IN("2.16.840.1.101.3.4.2.1", "sha256");
      _IN("2.16.840.1.101.3.4.2.2", "sha384");
      _IN("2.16.840.1.101.3.4.2.3", "sha512");
      _IN("1.2.840.113549.2.5", "md5");
      _IN("1.2.840.113549.1.7.1", "data");
      _IN("1.2.840.113549.1.7.2", "signedData");
      _IN("1.2.840.113549.1.7.3", "envelopedData");
      _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
      _IN("1.2.840.113549.1.7.5", "digestedData");
      _IN("1.2.840.113549.1.7.6", "encryptedData");
      _IN("1.2.840.113549.1.9.1", "emailAddress");
      _IN("1.2.840.113549.1.9.2", "unstructuredName");
      _IN("1.2.840.113549.1.9.3", "contentType");
      _IN("1.2.840.113549.1.9.4", "messageDigest");
      _IN("1.2.840.113549.1.9.5", "signingTime");
      _IN("1.2.840.113549.1.9.6", "counterSignature");
      _IN("1.2.840.113549.1.9.7", "challengePassword");
      _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
      _IN("1.2.840.113549.1.9.14", "extensionRequest");
      _IN("1.2.840.113549.1.9.20", "friendlyName");
      _IN("1.2.840.113549.1.9.21", "localKeyId");
      _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
      _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
      _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
      _IN("1.2.840.113549.1.12.10.1.3", "certBag");
      _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
      _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
      _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
      _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
      _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
      _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
      _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
      _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
      _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
      _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
      _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
      _IN("1.2.840.113549.2.7", "hmacWithSHA1");
      _IN("1.2.840.113549.2.8", "hmacWithSHA224");
      _IN("1.2.840.113549.2.9", "hmacWithSHA256");
      _IN("1.2.840.113549.2.10", "hmacWithSHA384");
      _IN("1.2.840.113549.2.11", "hmacWithSHA512");
      _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
      _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
      _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
      _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
      _IN("2.5.4.3", "commonName");
      _IN("2.5.4.5", "serialName");
      _IN("2.5.4.6", "countryName");
      _IN("2.5.4.7", "localityName");
      _IN("2.5.4.8", "stateOrProvinceName");
      _IN("2.5.4.9", "streetAddress");
      _IN("2.5.4.10", "organizationName");
      _IN("2.5.4.11", "organizationalUnitName");
      _IN("2.5.4.13", "description");
      _IN("2.5.4.15", "businessCategory");
      _IN("2.5.4.17", "postalCode");
      _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
      _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
      _IN("2.16.840.1.113730.1.1", "nsCertType");
      _IN("2.16.840.1.113730.1.13", "nsComment");
      _I_("2.5.29.1", "authorityKeyIdentifier");
      _I_("2.5.29.2", "keyAttributes");
      _I_("2.5.29.3", "certificatePolicies");
      _I_("2.5.29.4", "keyUsageRestriction");
      _I_("2.5.29.5", "policyMapping");
      _I_("2.5.29.6", "subtreesConstraint");
      _I_("2.5.29.7", "subjectAltName");
      _I_("2.5.29.8", "issuerAltName");
      _I_("2.5.29.9", "subjectDirectoryAttributes");
      _I_("2.5.29.10", "basicConstraints");
      _I_("2.5.29.11", "nameConstraints");
      _I_("2.5.29.12", "policyConstraints");
      _I_("2.5.29.13", "basicConstraints");
      _IN("2.5.29.14", "subjectKeyIdentifier");
      _IN("2.5.29.15", "keyUsage");
      _I_("2.5.29.16", "privateKeyUsagePeriod");
      _IN("2.5.29.17", "subjectAltName");
      _IN("2.5.29.18", "issuerAltName");
      _IN("2.5.29.19", "basicConstraints");
      _I_("2.5.29.20", "cRLNumber");
      _I_("2.5.29.21", "cRLReason");
      _I_("2.5.29.22", "expirationDate");
      _I_("2.5.29.23", "instructionCode");
      _I_("2.5.29.24", "invalidityDate");
      _I_("2.5.29.25", "cRLDistributionPoints");
      _I_("2.5.29.26", "issuingDistributionPoint");
      _I_("2.5.29.27", "deltaCRLIndicator");
      _I_("2.5.29.28", "issuingDistributionPoint");
      _I_("2.5.29.29", "certificateIssuer");
      _I_("2.5.29.30", "nameConstraints");
      _IN("2.5.29.31", "cRLDistributionPoints");
      _IN("2.5.29.32", "certificatePolicies");
      _I_("2.5.29.33", "policyMappings");
      _I_("2.5.29.34", "policyConstraints");
      _IN("2.5.29.35", "authorityKeyIdentifier");
      _I_("2.5.29.36", "policyConstraints");
      _IN("2.5.29.37", "extKeyUsage");
      _I_("2.5.29.46", "freshestCRL");
      _I_("2.5.29.54", "inhibitAnyPolicy");
      _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
      _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
      _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
      _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
      _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
      _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
      _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
    }
  });

  // node_modules/node-forge/lib/asn1.js
  var require_asn1 = __commonJS({
    "node_modules/node-forge/lib/asn1.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      require_oids();
      var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
      asn1.Class = {
        UNIVERSAL: 0,
        APPLICATION: 64,
        CONTEXT_SPECIFIC: 128,
        PRIVATE: 192
      };
      asn1.Type = {
        NONE: 0,
        BOOLEAN: 1,
        INTEGER: 2,
        BITSTRING: 3,
        OCTETSTRING: 4,
        NULL: 5,
        OID: 6,
        ODESC: 7,
        EXTERNAL: 8,
        REAL: 9,
        ENUMERATED: 10,
        EMBEDDED: 11,
        UTF8: 12,
        ROID: 13,
        SEQUENCE: 16,
        SET: 17,
        PRINTABLESTRING: 19,
        IA5STRING: 22,
        UTCTIME: 23,
        GENERALIZEDTIME: 24,
        BMPSTRING: 30
      };
      asn1.create = function(tagClass, type, constructed, value, options) {
        if (forge.util.isArray(value)) {
          var tmp = [];
          for (var i = 0; i < value.length; ++i) {
            if (value[i] !== void 0) {
              tmp.push(value[i]);
            }
          }
          value = tmp;
        }
        var obj = {
          tagClass,
          type,
          constructed,
          composed: constructed || forge.util.isArray(value),
          value
        };
        if (options && "bitStringContents" in options) {
          obj.bitStringContents = options.bitStringContents;
          obj.original = asn1.copy(obj);
        }
        return obj;
      };
      asn1.copy = function(obj, options) {
        var copy;
        if (forge.util.isArray(obj)) {
          copy = [];
          for (var i = 0; i < obj.length; ++i) {
            copy.push(asn1.copy(obj[i], options));
          }
          return copy;
        }
        if (typeof obj === "string") {
          return obj;
        }
        copy = {
          tagClass: obj.tagClass,
          type: obj.type,
          constructed: obj.constructed,
          composed: obj.composed,
          value: asn1.copy(obj.value, options)
        };
        if (options && !options.excludeBitStringContents) {
          copy.bitStringContents = obj.bitStringContents;
        }
        return copy;
      };
      asn1.equals = function(obj1, obj2, options) {
        if (forge.util.isArray(obj1)) {
          if (!forge.util.isArray(obj2)) {
            return false;
          }
          if (obj1.length !== obj2.length) {
            return false;
          }
          for (var i = 0; i < obj1.length; ++i) {
            if (!asn1.equals(obj1[i], obj2[i])) {
              return false;
            }
          }
          return true;
        }
        if (typeof obj1 !== typeof obj2) {
          return false;
        }
        if (typeof obj1 === "string") {
          return obj1 === obj2;
        }
        var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
        if (options && options.includeBitStringContents) {
          equal = equal && obj1.bitStringContents === obj2.bitStringContents;
        }
        return equal;
      };
      asn1.getBerValueLength = function(b) {
        var b2 = b.getByte();
        if (b2 === 128) {
          return void 0;
        }
        var length;
        var longForm = b2 & 128;
        if (!longForm) {
          length = b2;
        } else {
          length = b.getInt((b2 & 127) << 3);
        }
        return length;
      };
      function _checkBufferLength(bytes, remaining, n) {
        if (n > remaining) {
          var error = new Error("Too few bytes to parse DER.");
          error.available = bytes.length();
          error.remaining = remaining;
          error.requested = n;
          throw error;
        }
      }
      var _getValueLength = function(bytes, remaining) {
        var b2 = bytes.getByte();
        remaining--;
        if (b2 === 128) {
          return void 0;
        }
        var length;
        var longForm = b2 & 128;
        if (!longForm) {
          length = b2;
        } else {
          var longFormBytes = b2 & 127;
          _checkBufferLength(bytes, remaining, longFormBytes);
          length = bytes.getInt(longFormBytes << 3);
        }
        if (length < 0) {
          throw new Error("Negative length: " + length);
        }
        return length;
      };
      asn1.fromDer = function(bytes, options) {
        if (options === void 0) {
          options = {
            strict: true,
            decodeBitStrings: true
          };
        }
        if (typeof options === "boolean") {
          options = {
            strict: options,
            decodeBitStrings: true
          };
        }
        if (!("strict" in options)) {
          options.strict = true;
        }
        if (!("decodeBitStrings" in options)) {
          options.decodeBitStrings = true;
        }
        if (typeof bytes === "string") {
          bytes = forge.util.createBuffer(bytes);
        }
        return _fromDer(bytes, bytes.length(), 0, options);
      };
      function _fromDer(bytes, remaining, depth, options) {
        var start;
        _checkBufferLength(bytes, remaining, 2);
        var b1 = bytes.getByte();
        remaining--;
        var tagClass = b1 & 192;
        var type = b1 & 31;
        start = bytes.length();
        var length = _getValueLength(bytes, remaining);
        remaining -= start - bytes.length();
        if (length !== void 0 && length > remaining) {
          if (options.strict) {
            var error = new Error("Too few bytes to read ASN.1 value.");
            error.available = bytes.length();
            error.remaining = remaining;
            error.requested = length;
            throw error;
          }
          length = remaining;
        }
        var value;
        var bitStringContents;
        var constructed = (b1 & 32) === 32;
        if (constructed) {
          value = [];
          if (length === void 0) {
            for (; ; ) {
              _checkBufferLength(bytes, remaining, 2);
              if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
                bytes.getBytes(2);
                remaining -= 2;
                break;
              }
              start = bytes.length();
              value.push(_fromDer(bytes, remaining, depth + 1, options));
              remaining -= start - bytes.length();
            }
          } else {
            while (length > 0) {
              start = bytes.length();
              value.push(_fromDer(bytes, length, depth + 1, options));
              remaining -= start - bytes.length();
              length -= start - bytes.length();
            }
          }
        }
        if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
          bitStringContents = bytes.bytes(length);
        }
        if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
          var savedRead = bytes.read;
          var savedRemaining = remaining;
          var unused = 0;
          if (type === asn1.Type.BITSTRING) {
            _checkBufferLength(bytes, remaining, 1);
            unused = bytes.getByte();
            remaining--;
          }
          if (unused === 0) {
            try {
              start = bytes.length();
              var subOptions = {
                verbose: options.verbose,
                strict: true,
                decodeBitStrings: true
              };
              var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
              var used = start - bytes.length();
              remaining -= used;
              if (type == asn1.Type.BITSTRING) {
                used++;
              }
              var tc = composed.tagClass;
              if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
                value = [composed];
              }
            } catch (ex) {
            }
          }
          if (value === void 0) {
            bytes.read = savedRead;
            remaining = savedRemaining;
          }
        }
        if (value === void 0) {
          if (length === void 0) {
            if (options.strict) {
              throw new Error("Non-constructed ASN.1 object of indefinite length.");
            }
            length = remaining;
          }
          if (type === asn1.Type.BMPSTRING) {
            value = "";
            for (; length > 0; length -= 2) {
              _checkBufferLength(bytes, remaining, 2);
              value += String.fromCharCode(bytes.getInt16());
              remaining -= 2;
            }
          } else {
            value = bytes.getBytes(length);
          }
        }
        var asn1Options = bitStringContents === void 0 ? null : {
          bitStringContents
        };
        return asn1.create(tagClass, type, constructed, value, asn1Options);
      }
      asn1.toDer = function(obj) {
        var bytes = forge.util.createBuffer();
        var b1 = obj.tagClass | obj.type;
        var value = forge.util.createBuffer();
        var useBitStringContents = false;
        if ("bitStringContents" in obj) {
          useBitStringContents = true;
          if (obj.original) {
            useBitStringContents = asn1.equals(obj, obj.original);
          }
        }
        if (useBitStringContents) {
          value.putBytes(obj.bitStringContents);
        } else if (obj.composed) {
          if (obj.constructed) {
            b1 |= 32;
          } else {
            value.putByte(0);
          }
          for (var i = 0; i < obj.value.length; ++i) {
            if (obj.value[i] !== void 0) {
              value.putBuffer(asn1.toDer(obj.value[i]));
            }
          }
        } else {
          if (obj.type === asn1.Type.BMPSTRING) {
            for (var i = 0; i < obj.value.length; ++i) {
              value.putInt16(obj.value.charCodeAt(i));
            }
          } else {
            if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
              value.putBytes(obj.value.substr(1));
            } else {
              value.putBytes(obj.value);
            }
          }
        }
        bytes.putByte(b1);
        if (value.length() <= 127) {
          bytes.putByte(value.length() & 127);
        } else {
          var len = value.length();
          var lenBytes = "";
          do {
            lenBytes += String.fromCharCode(len & 255);
            len = len >>> 8;
          } while (len > 0);
          bytes.putByte(lenBytes.length | 128);
          for (var i = lenBytes.length - 1; i >= 0; --i) {
            bytes.putByte(lenBytes.charCodeAt(i));
          }
        }
        bytes.putBuffer(value);
        return bytes;
      };
      asn1.oidToDer = function(oid) {
        var values = oid.split(".");
        var bytes = forge.util.createBuffer();
        bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
        var last, valueBytes, value, b;
        for (var i = 2; i < values.length; ++i) {
          last = true;
          valueBytes = [];
          value = parseInt(values[i], 10);
          do {
            b = value & 127;
            value = value >>> 7;
            if (!last) {
              b |= 128;
            }
            valueBytes.push(b);
            last = false;
          } while (value > 0);
          for (var n = valueBytes.length - 1; n >= 0; --n) {
            bytes.putByte(valueBytes[n]);
          }
        }
        return bytes;
      };
      asn1.derToOid = function(bytes) {
        var oid;
        if (typeof bytes === "string") {
          bytes = forge.util.createBuffer(bytes);
        }
        var b = bytes.getByte();
        oid = Math.floor(b / 40) + "." + b % 40;
        var value = 0;
        while (bytes.length() > 0) {
          b = bytes.getByte();
          value = value << 7;
          if (b & 128) {
            value += b & 127;
          } else {
            oid += "." + (value + b);
            value = 0;
          }
        }
        return oid;
      };
      asn1.utcTimeToDate = function(utc) {
        var date = new Date();
        var year = parseInt(utc.substr(0, 2), 10);
        year = year >= 50 ? 1900 + year : 2e3 + year;
        var MM = parseInt(utc.substr(2, 2), 10) - 1;
        var DD = parseInt(utc.substr(4, 2), 10);
        var hh = parseInt(utc.substr(6, 2), 10);
        var mm = parseInt(utc.substr(8, 2), 10);
        var ss = 0;
        if (utc.length > 11) {
          var c = utc.charAt(10);
          var end = 10;
          if (c !== "+" && c !== "-") {
            ss = parseInt(utc.substr(10, 2), 10);
            end += 2;
          }
        }
        date.setUTCFullYear(year, MM, DD);
        date.setUTCHours(hh, mm, ss, 0);
        if (end) {
          c = utc.charAt(end);
          if (c === "+" || c === "-") {
            var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
            var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
            var offset = hhoffset * 60 + mmoffset;
            offset *= 6e4;
            if (c === "+") {
              date.setTime(+date - offset);
            } else {
              date.setTime(+date + offset);
            }
          }
        }
        return date;
      };
      asn1.generalizedTimeToDate = function(gentime) {
        var date = new Date();
        var YYYY = parseInt(gentime.substr(0, 4), 10);
        var MM = parseInt(gentime.substr(4, 2), 10) - 1;
        var DD = parseInt(gentime.substr(6, 2), 10);
        var hh = parseInt(gentime.substr(8, 2), 10);
        var mm = parseInt(gentime.substr(10, 2), 10);
        var ss = parseInt(gentime.substr(12, 2), 10);
        var fff = 0;
        var offset = 0;
        var isUTC = false;
        if (gentime.charAt(gentime.length - 1) === "Z") {
          isUTC = true;
        }
        var end = gentime.length - 5, c = gentime.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
          var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
          offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            offset *= -1;
          }
          isUTC = true;
        }
        if (gentime.charAt(14) === ".") {
          fff = parseFloat(gentime.substr(14), 10) * 1e3;
        }
        if (isUTC) {
          date.setUTCFullYear(YYYY, MM, DD);
          date.setUTCHours(hh, mm, ss, fff);
          date.setTime(+date + offset);
        } else {
          date.setFullYear(YYYY, MM, DD);
          date.setHours(hh, mm, ss, fff);
        }
        return date;
      };
      asn1.dateToUtcTime = function(date) {
        if (typeof date === "string") {
          return date;
        }
        var rval = "";
        var format = [];
        format.push(("" + date.getUTCFullYear()).substr(2));
        format.push("" + (date.getUTCMonth() + 1));
        format.push("" + date.getUTCDate());
        format.push("" + date.getUTCHours());
        format.push("" + date.getUTCMinutes());
        format.push("" + date.getUTCSeconds());
        for (var i = 0; i < format.length; ++i) {
          if (format[i].length < 2) {
            rval += "0";
          }
          rval += format[i];
        }
        rval += "Z";
        return rval;
      };
      asn1.dateToGeneralizedTime = function(date) {
        if (typeof date === "string") {
          return date;
        }
        var rval = "";
        var format = [];
        format.push("" + date.getUTCFullYear());
        format.push("" + (date.getUTCMonth() + 1));
        format.push("" + date.getUTCDate());
        format.push("" + date.getUTCHours());
        format.push("" + date.getUTCMinutes());
        format.push("" + date.getUTCSeconds());
        for (var i = 0; i < format.length; ++i) {
          if (format[i].length < 2) {
            rval += "0";
          }
          rval += format[i];
        }
        rval += "Z";
        return rval;
      };
      asn1.integerToDer = function(x) {
        var rval = forge.util.createBuffer();
        if (x >= -128 && x < 128) {
          return rval.putSignedInt(x, 8);
        }
        if (x >= -32768 && x < 32768) {
          return rval.putSignedInt(x, 16);
        }
        if (x >= -8388608 && x < 8388608) {
          return rval.putSignedInt(x, 24);
        }
        if (x >= -2147483648 && x < 2147483648) {
          return rval.putSignedInt(x, 32);
        }
        var error = new Error("Integer too large; max is 32-bits.");
        error.integer = x;
        throw error;
      };
      asn1.derToInteger = function(bytes) {
        if (typeof bytes === "string") {
          bytes = forge.util.createBuffer(bytes);
        }
        var n = bytes.length() * 8;
        if (n > 32) {
          throw new Error("Integer too large; max is 32-bits.");
        }
        return bytes.getSignedInt(n);
      };
      asn1.validate = function(obj, v, capture, errors) {
        var rval = false;
        if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
          if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
            rval = true;
            if (v.value && forge.util.isArray(v.value)) {
              var j = 0;
              for (var i = 0; rval && i < v.value.length; ++i) {
                rval = v.value[i].optional || false;
                if (obj.value[j]) {
                  rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
                  if (rval) {
                    ++j;
                  } else if (v.value[i].optional) {
                    rval = true;
                  }
                }
                if (!rval && errors) {
                  errors.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
                }
              }
            }
            if (rval && capture) {
              if (v.capture) {
                capture[v.capture] = obj.value;
              }
              if (v.captureAsn1) {
                capture[v.captureAsn1] = obj;
              }
              if (v.captureBitStringContents && "bitStringContents" in obj) {
                capture[v.captureBitStringContents] = obj.bitStringContents;
              }
              if (v.captureBitStringValue && "bitStringContents" in obj) {
                var value;
                if (obj.bitStringContents.length < 2) {
                  capture[v.captureBitStringValue] = "";
                } else {
                  var unused = obj.bitStringContents.charCodeAt(0);
                  if (unused !== 0) {
                    throw new Error("captureBitStringValue only supported for zero unused bits");
                  }
                  capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
                }
              }
            }
          } else if (errors) {
            errors.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
          }
        } else if (errors) {
          if (obj.tagClass !== v.tagClass) {
            errors.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
          }
          if (obj.type !== v.type) {
            errors.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
          }
        }
        return rval;
      };
      var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
      asn1.prettyPrint = function(obj, level, indentation) {
        var rval = "";
        level = level || 0;
        indentation = indentation || 2;
        if (level > 0) {
          rval += "\n";
        }
        var indent = "";
        for (var i = 0; i < level * indentation; ++i) {
          indent += " ";
        }
        rval += indent + "Tag: ";
        switch (obj.tagClass) {
          case asn1.Class.UNIVERSAL:
            rval += "Universal:";
            break;
          case asn1.Class.APPLICATION:
            rval += "Application:";
            break;
          case asn1.Class.CONTEXT_SPECIFIC:
            rval += "Context-Specific:";
            break;
          case asn1.Class.PRIVATE:
            rval += "Private:";
            break;
        }
        if (obj.tagClass === asn1.Class.UNIVERSAL) {
          rval += obj.type;
          switch (obj.type) {
            case asn1.Type.NONE:
              rval += " (None)";
              break;
            case asn1.Type.BOOLEAN:
              rval += " (Boolean)";
              break;
            case asn1.Type.INTEGER:
              rval += " (Integer)";
              break;
            case asn1.Type.BITSTRING:
              rval += " (Bit string)";
              break;
            case asn1.Type.OCTETSTRING:
              rval += " (Octet string)";
              break;
            case asn1.Type.NULL:
              rval += " (Null)";
              break;
            case asn1.Type.OID:
              rval += " (Object Identifier)";
              break;
            case asn1.Type.ODESC:
              rval += " (Object Descriptor)";
              break;
            case asn1.Type.EXTERNAL:
              rval += " (External or Instance of)";
              break;
            case asn1.Type.REAL:
              rval += " (Real)";
              break;
            case asn1.Type.ENUMERATED:
              rval += " (Enumerated)";
              break;
            case asn1.Type.EMBEDDED:
              rval += " (Embedded PDV)";
              break;
            case asn1.Type.UTF8:
              rval += " (UTF8)";
              break;
            case asn1.Type.ROID:
              rval += " (Relative Object Identifier)";
              break;
            case asn1.Type.SEQUENCE:
              rval += " (Sequence)";
              break;
            case asn1.Type.SET:
              rval += " (Set)";
              break;
            case asn1.Type.PRINTABLESTRING:
              rval += " (Printable String)";
              break;
            case asn1.Type.IA5String:
              rval += " (IA5String (ASCII))";
              break;
            case asn1.Type.UTCTIME:
              rval += " (UTC time)";
              break;
            case asn1.Type.GENERALIZEDTIME:
              rval += " (Generalized time)";
              break;
            case asn1.Type.BMPSTRING:
              rval += " (BMP String)";
              break;
          }
        } else {
          rval += obj.type;
        }
        rval += "\n";
        rval += indent + "Constructed: " + obj.constructed + "\n";
        if (obj.composed) {
          var subvalues = 0;
          var sub = "";
          for (var i = 0; i < obj.value.length; ++i) {
            if (obj.value[i] !== void 0) {
              subvalues += 1;
              sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
              if (i + 1 < obj.value.length) {
                sub += ",";
              }
            }
          }
          rval += indent + "Sub values: " + subvalues + sub;
        } else {
          rval += indent + "Value: ";
          if (obj.type === asn1.Type.OID) {
            var oid = asn1.derToOid(obj.value);
            rval += oid;
            if (forge.pki && forge.pki.oids) {
              if (oid in forge.pki.oids) {
                rval += " (" + forge.pki.oids[oid] + ") ";
              }
            }
          }
          if (obj.type === asn1.Type.INTEGER) {
            try {
              rval += asn1.derToInteger(obj.value);
            } catch (ex) {
              rval += "0x" + forge.util.bytesToHex(obj.value);
            }
          } else if (obj.type === asn1.Type.BITSTRING) {
            if (obj.value.length > 1) {
              rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
            } else {
              rval += "(none)";
            }
            if (obj.value.length > 0) {
              var unused = obj.value.charCodeAt(0);
              if (unused == 1) {
                rval += " (1 unused bit shown)";
              } else if (unused > 1) {
                rval += " (" + unused + " unused bits shown)";
              }
            }
          } else if (obj.type === asn1.Type.OCTETSTRING) {
            if (!_nonLatinRegex.test(obj.value)) {
              rval += "(" + obj.value + ") ";
            }
            rval += "0x" + forge.util.bytesToHex(obj.value);
          } else if (obj.type === asn1.Type.UTF8) {
            rval += forge.util.decodeUtf8(obj.value);
          } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
            rval += obj.value;
          } else if (_nonLatinRegex.test(obj.value)) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          } else if (obj.value.length === 0) {
            rval += "[null]";
          } else {
            rval += obj.value;
          }
        }
        return rval;
      };
    }
  });

  // node_modules/node-forge/lib/md.js
  var require_md = __commonJS({
    "node_modules/node-forge/lib/md.js"(exports, module) {
      var forge = require_forge();
      module.exports = forge.md = forge.md || {};
      forge.md.algorithms = forge.md.algorithms || {};
    }
  });

  // node_modules/node-forge/lib/hmac.js
  var require_hmac = __commonJS({
    "node_modules/node-forge/lib/hmac.js"(exports, module) {
      var forge = require_forge();
      require_md();
      require_util4();
      var hmac = module.exports = forge.hmac = forge.hmac || {};
      hmac.create = function() {
        var _key = null;
        var _md = null;
        var _ipadding = null;
        var _opadding = null;
        var ctx = {};
        ctx.start = function(md, key) {
          if (md !== null) {
            if (typeof md === "string") {
              md = md.toLowerCase();
              if (md in forge.md.algorithms) {
                _md = forge.md.algorithms[md].create();
              } else {
                throw new Error('Unknown hash algorithm "' + md + '"');
              }
            } else {
              _md = md;
            }
          }
          if (key === null) {
            key = _key;
          } else {
            if (typeof key === "string") {
              key = forge.util.createBuffer(key);
            } else if (forge.util.isArray(key)) {
              var tmp = key;
              key = forge.util.createBuffer();
              for (var i = 0; i < tmp.length; ++i) {
                key.putByte(tmp[i]);
              }
            }
            var keylen = key.length();
            if (keylen > _md.blockLength) {
              _md.start();
              _md.update(key.bytes());
              key = _md.digest();
            }
            _ipadding = forge.util.createBuffer();
            _opadding = forge.util.createBuffer();
            keylen = key.length();
            for (var i = 0; i < keylen; ++i) {
              var tmp = key.at(i);
              _ipadding.putByte(54 ^ tmp);
              _opadding.putByte(92 ^ tmp);
            }
            if (keylen < _md.blockLength) {
              var tmp = _md.blockLength - keylen;
              for (var i = 0; i < tmp; ++i) {
                _ipadding.putByte(54);
                _opadding.putByte(92);
              }
            }
            _key = key;
            _ipadding = _ipadding.bytes();
            _opadding = _opadding.bytes();
          }
          _md.start();
          _md.update(_ipadding);
        };
        ctx.update = function(bytes) {
          _md.update(bytes);
        };
        ctx.getMac = function() {
          var inner = _md.digest().bytes();
          _md.start();
          _md.update(_opadding);
          _md.update(inner);
          return _md.digest();
        };
        ctx.digest = ctx.getMac;
        return ctx;
      };
    }
  });

  // node_modules/node-forge/lib/md5.js
  var require_md5 = __commonJS({
    "node_modules/node-forge/lib/md5.js"(exports, module) {
      var forge = require_forge();
      require_md();
      require_util4();
      var md5 = module.exports = forge.md5 = forge.md5 || {};
      forge.md.md5 = forge.md.algorithms.md5 = md5;
      md5.create = function() {
        if (!_initialized) {
          _init();
        }
        var _state = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(16);
        var md = {
          algorithm: "md5",
          blockLength: 64,
          digestLength: 16,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength64 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _state = {
            h0: 1732584193,
            h1: 4023233417,
            h2: 2562383102,
            h3: 271733878
          };
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_state, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var bits, carry = 0;
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            bits = md.fullMessageLength[i] * 8 + carry;
            carry = bits / 4294967296 >>> 0;
            finalBlock.putInt32Le(bits >>> 0);
          }
          var s2 = {
            h0: _state.h0,
            h1: _state.h1,
            h2: _state.h2,
            h3: _state.h3
          };
          _update(s2, _w, finalBlock);
          var rval = forge.util.createBuffer();
          rval.putInt32Le(s2.h0);
          rval.putInt32Le(s2.h1);
          rval.putInt32Le(s2.h2);
          rval.putInt32Le(s2.h3);
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _g = null;
      var _r = null;
      var _k = null;
      var _initialized = false;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 64);
        _g = [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          1,
          6,
          11,
          0,
          5,
          10,
          15,
          4,
          9,
          14,
          3,
          8,
          13,
          2,
          7,
          12,
          5,
          8,
          11,
          14,
          1,
          4,
          7,
          10,
          13,
          0,
          3,
          6,
          9,
          12,
          15,
          2,
          0,
          7,
          14,
          5,
          12,
          3,
          10,
          1,
          8,
          15,
          6,
          13,
          4,
          11,
          2,
          9
        ];
        _r = [
          7,
          12,
          17,
          22,
          7,
          12,
          17,
          22,
          7,
          12,
          17,
          22,
          7,
          12,
          17,
          22,
          5,
          9,
          14,
          20,
          5,
          9,
          14,
          20,
          5,
          9,
          14,
          20,
          5,
          9,
          14,
          20,
          4,
          11,
          16,
          23,
          4,
          11,
          16,
          23,
          4,
          11,
          16,
          23,
          4,
          11,
          16,
          23,
          6,
          10,
          15,
          21,
          6,
          10,
          15,
          21,
          6,
          10,
          15,
          21,
          6,
          10,
          15,
          21
        ];
        _k = new Array(64);
        for (var i = 0; i < 64; ++i) {
          _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
        }
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t, a, b, c, d, f, r, i;
        var len = bytes.length();
        while (len >= 64) {
          a = s.h0;
          b = s.h1;
          c = s.h2;
          d = s.h3;
          for (i = 0; i < 16; ++i) {
            w[i] = bytes.getInt32Le();
            f = d ^ b & (c ^ d);
            t = a + f + _k[i] + w[i];
            r = _r[i];
            a = d;
            d = c;
            c = b;
            b += t << r | t >>> 32 - r;
          }
          for (; i < 32; ++i) {
            f = c ^ d & (b ^ c);
            t = a + f + _k[i] + w[_g[i]];
            r = _r[i];
            a = d;
            d = c;
            c = b;
            b += t << r | t >>> 32 - r;
          }
          for (; i < 48; ++i) {
            f = b ^ c ^ d;
            t = a + f + _k[i] + w[_g[i]];
            r = _r[i];
            a = d;
            d = c;
            c = b;
            b += t << r | t >>> 32 - r;
          }
          for (; i < 64; ++i) {
            f = c ^ (b | ~d);
            t = a + f + _k[i] + w[_g[i]];
            r = _r[i];
            a = d;
            d = c;
            c = b;
            b += t << r | t >>> 32 - r;
          }
          s.h0 = s.h0 + a | 0;
          s.h1 = s.h1 + b | 0;
          s.h2 = s.h2 + c | 0;
          s.h3 = s.h3 + d | 0;
          len -= 64;
        }
      }
    }
  });

  // node_modules/node-forge/lib/pem.js
  var require_pem = __commonJS({
    "node_modules/node-forge/lib/pem.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      var pem = module.exports = forge.pem = forge.pem || {};
      pem.encode = function(msg, options) {
        options = options || {};
        var rval = "-----BEGIN " + msg.type + "-----\r\n";
        var header;
        if (msg.procType) {
          header = {
            name: "Proc-Type",
            values: [String(msg.procType.version), msg.procType.type]
          };
          rval += foldHeader(header);
        }
        if (msg.contentDomain) {
          header = { name: "Content-Domain", values: [msg.contentDomain] };
          rval += foldHeader(header);
        }
        if (msg.dekInfo) {
          header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
          if (msg.dekInfo.parameters) {
            header.values.push(msg.dekInfo.parameters);
          }
          rval += foldHeader(header);
        }
        if (msg.headers) {
          for (var i = 0; i < msg.headers.length; ++i) {
            rval += foldHeader(msg.headers[i]);
          }
        }
        if (msg.procType) {
          rval += "\r\n";
        }
        rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
        rval += "-----END " + msg.type + "-----\r\n";
        return rval;
      };
      pem.decode = function(str) {
        var rval = [];
        var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
        var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
        var rCRLF = /\r?\n/;
        var match;
        while (true) {
          match = rMessage.exec(str);
          if (!match) {
            break;
          }
          var msg = {
            type: match[1],
            procType: null,
            contentDomain: null,
            dekInfo: null,
            headers: [],
            body: forge.util.decode64(match[3])
          };
          rval.push(msg);
          if (!match[2]) {
            continue;
          }
          var lines = match[2].split(rCRLF);
          var li = 0;
          while (match && li < lines.length) {
            var line = lines[li].replace(/\s+$/, "");
            for (var nl = li + 1; nl < lines.length; ++nl) {
              var next = lines[nl];
              if (!/\s/.test(next[0])) {
                break;
              }
              line += next;
              li = nl;
            }
            match = line.match(rHeader);
            if (match) {
              var header = { name: match[1], values: [] };
              var values = match[2].split(",");
              for (var vi = 0; vi < values.length; ++vi) {
                header.values.push(ltrim(values[vi]));
              }
              if (!msg.procType) {
                if (header.name !== "Proc-Type") {
                  throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
                } else if (header.values.length !== 2) {
                  throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
                }
                msg.procType = { version: values[0], type: values[1] };
              } else if (!msg.contentDomain && header.name === "Content-Domain") {
                msg.contentDomain = values[0] || "";
              } else if (!msg.dekInfo && header.name === "DEK-Info") {
                if (header.values.length === 0) {
                  throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
                }
                msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
              } else {
                msg.headers.push(header);
              }
            }
            ++li;
          }
          if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
          }
        }
        if (rval.length === 0) {
          throw new Error("Invalid PEM formatted message.");
        }
        return rval;
      };
      function foldHeader(header) {
        var rval = header.name + ": ";
        var values = [];
        var insertSpace = function(match, $1) {
          return " " + $1;
        };
        for (var i = 0; i < header.values.length; ++i) {
          values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
        }
        rval += values.join(",") + "\r\n";
        var length = 0;
        var candidate = -1;
        for (var i = 0; i < rval.length; ++i, ++length) {
          if (length > 65 && candidate !== -1) {
            var insert = rval[candidate];
            if (insert === ",") {
              ++candidate;
              rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
            } else {
              rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
            }
            length = i - candidate - 1;
            candidate = -1;
            ++i;
          } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
            candidate = i;
          }
        }
        return rval;
      }
      function ltrim(str) {
        return str.replace(/^\s+/, "");
      }
    }
  });

  // node_modules/node-forge/lib/des.js
  var require_des = __commonJS({
    "node_modules/node-forge/lib/des.js"(exports, module) {
      var forge = require_forge();
      require_cipher();
      require_cipherModes();
      require_util4();
      module.exports = forge.des = forge.des || {};
      forge.des.startEncrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: false,
          mode: mode || (iv === null ? "ECB" : "CBC")
        });
        cipher.start(iv);
        return cipher;
      };
      forge.des.createEncryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: false,
          mode
        });
      };
      forge.des.startDecrypting = function(key, iv, output, mode) {
        var cipher = _createCipher({
          key,
          output,
          decrypt: true,
          mode: mode || (iv === null ? "ECB" : "CBC")
        });
        cipher.start(iv);
        return cipher;
      };
      forge.des.createDecryptionCipher = function(key, mode) {
        return _createCipher({
          key,
          output: null,
          decrypt: true,
          mode
        });
      };
      forge.des.Algorithm = function(name, mode) {
        var self2 = this;
        self2.name = name;
        self2.mode = new mode({
          blockSize: 8,
          cipher: {
            encrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._keys, inBlock, outBlock, false);
            },
            decrypt: function(inBlock, outBlock) {
              return _updateBlock(self2._keys, inBlock, outBlock, true);
            }
          }
        });
        self2._init = false;
      };
      forge.des.Algorithm.prototype.initialize = function(options) {
        if (this._init) {
          return;
        }
        var key = forge.util.createBuffer(options.key);
        if (this.name.indexOf("3DES") === 0) {
          if (key.length() !== 24) {
            throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
          }
        }
        this._keys = _createKeys(key);
        this._init = true;
      };
      registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
      registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
      registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
      registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
      registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
      registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
      registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
      registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
      registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
      registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
      function registerAlgorithm(name, mode) {
        var factory = function() {
          return new forge.des.Algorithm(name, mode);
        };
        forge.cipher.registerAlgorithm(name, factory);
      }
      var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
      var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
      var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
      var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
      var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
      var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
      var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
      var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
      function _createKeys(key) {
        var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
        var iterations = key.length() > 8 ? 3 : 1;
        var keys = [];
        var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
        var n = 0, tmp;
        for (var j = 0; j < iterations; j++) {
          var left = key.getInt32();
          var right = key.getInt32();
          tmp = (left >>> 4 ^ right) & 252645135;
          right ^= tmp;
          left ^= tmp << 4;
          tmp = (right >>> -16 ^ left) & 65535;
          left ^= tmp;
          right ^= tmp << -16;
          tmp = (left >>> 2 ^ right) & 858993459;
          right ^= tmp;
          left ^= tmp << 2;
          tmp = (right >>> -16 ^ left) & 65535;
          left ^= tmp;
          right ^= tmp << -16;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = (right >>> 8 ^ left) & 16711935;
          left ^= tmp;
          right ^= tmp << 8;
          tmp = (left >>> 1 ^ right) & 1431655765;
          right ^= tmp;
          left ^= tmp << 1;
          tmp = left << 8 | right >>> 20 & 240;
          left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
          right = tmp;
          for (var i = 0; i < shifts.length; ++i) {
            if (shifts[i]) {
              left = left << 2 | left >>> 26;
              right = right << 2 | right >>> 26;
            } else {
              left = left << 1 | left >>> 27;
              right = right << 1 | right >>> 27;
            }
            left &= -15;
            right &= -15;
            var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
            var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
            tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
            keys[n++] = lefttmp ^ tmp;
            keys[n++] = righttmp ^ tmp << 16;
          }
        }
        return keys;
      }
      function _updateBlock(keys, input, output, decrypt) {
        var iterations = keys.length === 32 ? 3 : 9;
        var looping;
        if (iterations === 3) {
          looping = decrypt ? [30, -2, -2] : [0, 32, 2];
        } else {
          looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
        }
        var tmp;
        var left = input[0];
        var right = input[1];
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (left >>> 16 ^ right) & 65535;
        right ^= tmp;
        left ^= tmp << 16;
        tmp = (right >>> 2 ^ left) & 858993459;
        left ^= tmp;
        right ^= tmp << 2;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        left = left << 1 | left >>> 31;
        right = right << 1 | right >>> 31;
        for (var j = 0; j < iterations; j += 3) {
          var endloop = looping[j + 1];
          var loopinc = looping[j + 2];
          for (var i = looping[j]; i != endloop; i += loopinc) {
            var right1 = right ^ keys[i];
            var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
            tmp = left;
            left = right;
            right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
          }
          tmp = left;
          left = right;
          right = tmp;
        }
        left = left >>> 1 | left << 31;
        right = right >>> 1 | right << 31;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (right >>> 2 ^ left) & 858993459;
        left ^= tmp;
        right ^= tmp << 2;
        tmp = (left >>> 16 ^ right) & 65535;
        right ^= tmp;
        left ^= tmp << 16;
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        output[0] = left;
        output[1] = right;
      }
      function _createCipher(options) {
        options = options || {};
        var mode = (options.mode || "CBC").toUpperCase();
        var algorithm = "DES-" + mode;
        var cipher;
        if (options.decrypt) {
          cipher = forge.cipher.createDecipher(algorithm, options.key);
        } else {
          cipher = forge.cipher.createCipher(algorithm, options.key);
        }
        var start = cipher.start;
        cipher.start = function(iv, options2) {
          var output = null;
          if (options2 instanceof forge.util.ByteBuffer) {
            output = options2;
            options2 = {};
          }
          options2 = options2 || {};
          options2.output = output;
          options2.iv = iv;
          start.call(cipher, options2);
        };
        return cipher;
      }
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/node-forge/lib/pbkdf2.js
  var require_pbkdf2 = __commonJS({
    "node_modules/node-forge/lib/pbkdf2.js"(exports, module) {
      var forge = require_forge();
      require_hmac();
      require_md();
      require_util4();
      var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
      var crypto;
      if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
        crypto = require_crypto();
      }
      module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
        if (typeof md === "function") {
          callback = md;
          md = null;
        }
        if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto.pbkdf2 && (md === null || typeof md !== "object") && (crypto.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
          if (typeof md !== "string") {
            md = "sha1";
          }
          p = Buffer.from(p, "binary");
          s = Buffer.from(s, "binary");
          if (!callback) {
            if (crypto.pbkdf2Sync.length === 4) {
              return crypto.pbkdf2Sync(p, s, c, dkLen).toString("binary");
            }
            return crypto.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
          }
          if (crypto.pbkdf2Sync.length === 4) {
            return crypto.pbkdf2(p, s, c, dkLen, function(err2, key) {
              if (err2) {
                return callback(err2);
              }
              callback(null, key.toString("binary"));
            });
          }
          return crypto.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        if (typeof md === "undefined" || md === null) {
          md = "sha1";
        }
        if (typeof md === "string") {
          if (!(md in forge.md.algorithms)) {
            throw new Error("Unknown hash algorithm: " + md);
          }
          md = forge.md[md].create();
        }
        var hLen = md.digestLength;
        if (dkLen > 4294967295 * hLen) {
          var err = new Error("Derived key is too long.");
          if (callback) {
            return callback(err);
          }
          throw err;
        }
        var len = Math.ceil(dkLen / hLen);
        var r = dkLen - (len - 1) * hLen;
        var prf = forge.hmac.create();
        prf.start(md, p);
        var dk = "";
        var xor, u_c, u_c1;
        if (!callback) {
          for (var i = 1; i <= len; ++i) {
            prf.start(null, null);
            prf.update(s);
            prf.update(forge.util.int32ToBytes(i));
            xor = u_c1 = prf.digest().getBytes();
            for (var j = 2; j <= c; ++j) {
              prf.start(null, null);
              prf.update(u_c1);
              u_c = prf.digest().getBytes();
              xor = forge.util.xorBytes(xor, u_c, hLen);
              u_c1 = u_c;
            }
            dk += i < len ? xor : xor.substr(0, r);
          }
          return dk;
        }
        var i = 1, j;
        function outer() {
          if (i > len) {
            return callback(null, dk);
          }
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          j = 2;
          inner();
        }
        function inner() {
          if (j <= c) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
            ++j;
            return forge.util.setImmediate(inner);
          }
          dk += i < len ? xor : xor.substr(0, r);
          ++i;
          outer();
        }
        outer();
      };
    }
  });

  // node_modules/node-forge/lib/sha256.js
  var require_sha256 = __commonJS({
    "node_modules/node-forge/lib/sha256.js"(exports, module) {
      var forge = require_forge();
      require_md();
      require_util4();
      var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
      forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
      sha256.create = function() {
        if (!_initialized) {
          _init();
        }
        var _state = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(64);
        var md = {
          algorithm: "sha256",
          blockLength: 64,
          digestLength: 32,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength64 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _state = {
            h0: 1779033703,
            h1: 3144134277,
            h2: 1013904242,
            h3: 2773480762,
            h4: 1359893119,
            h5: 2600822924,
            h6: 528734635,
            h7: 1541459225
          };
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_state, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var next, carry;
          var bits = md.fullMessageLength[0] * 8;
          for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
            next = md.fullMessageLength[i + 1] * 8;
            carry = next / 4294967296 >>> 0;
            bits += carry;
            finalBlock.putInt32(bits >>> 0);
            bits = next >>> 0;
          }
          finalBlock.putInt32(bits);
          var s2 = {
            h0: _state.h0,
            h1: _state.h1,
            h2: _state.h2,
            h3: _state.h3,
            h4: _state.h4,
            h5: _state.h5,
            h6: _state.h6,
            h7: _state.h7
          };
          _update(s2, _w, finalBlock);
          var rval = forge.util.createBuffer();
          rval.putInt32(s2.h0);
          rval.putInt32(s2.h1);
          rval.putInt32(s2.h2);
          rval.putInt32(s2.h3);
          rval.putInt32(s2.h4);
          rval.putInt32(s2.h5);
          rval.putInt32(s2.h6);
          rval.putInt32(s2.h7);
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _initialized = false;
      var _k = null;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 64);
        _k = [
          1116352408,
          1899447441,
          3049323471,
          3921009573,
          961987163,
          1508970993,
          2453635748,
          2870763221,
          3624381080,
          310598401,
          607225278,
          1426881987,
          1925078388,
          2162078206,
          2614888103,
          3248222580,
          3835390401,
          4022224774,
          264347078,
          604807628,
          770255983,
          1249150122,
          1555081692,
          1996064986,
          2554220882,
          2821834349,
          2952996808,
          3210313671,
          3336571891,
          3584528711,
          113926993,
          338241895,
          666307205,
          773529912,
          1294757372,
          1396182291,
          1695183700,
          1986661051,
          2177026350,
          2456956037,
          2730485921,
          2820302411,
          3259730800,
          3345764771,
          3516065817,
          3600352804,
          4094571909,
          275423344,
          430227734,
          506948616,
          659060556,
          883997877,
          958139571,
          1322822218,
          1537002063,
          1747873779,
          1955562222,
          2024104815,
          2227730452,
          2361852424,
          2428436474,
          2756734187,
          3204031479,
          3329325298
        ];
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
        var len = bytes.length();
        while (len >= 64) {
          for (i = 0; i < 16; ++i) {
            w[i] = bytes.getInt32();
          }
          for (; i < 64; ++i) {
            t1 = w[i - 2];
            t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
            t2 = w[i - 15];
            t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
            w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
          }
          a = s.h0;
          b = s.h1;
          c = s.h2;
          d = s.h3;
          e = s.h4;
          f = s.h5;
          g = s.h6;
          h = s.h7;
          for (i = 0; i < 64; ++i) {
            s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
            ch = g ^ e & (f ^ g);
            s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
            maj = a & b | c & (a ^ b);
            t1 = h + s1 + ch + _k[i] + w[i];
            t2 = s0 + maj;
            h = g;
            g = f;
            f = e;
            e = d + t1 >>> 0;
            d = c;
            c = b;
            b = a;
            a = t1 + t2 >>> 0;
          }
          s.h0 = s.h0 + a | 0;
          s.h1 = s.h1 + b | 0;
          s.h2 = s.h2 + c | 0;
          s.h3 = s.h3 + d | 0;
          s.h4 = s.h4 + e | 0;
          s.h5 = s.h5 + f | 0;
          s.h6 = s.h6 + g | 0;
          s.h7 = s.h7 + h | 0;
          len -= 64;
        }
      }
    }
  });

  // node_modules/node-forge/lib/prng.js
  var require_prng = __commonJS({
    "node_modules/node-forge/lib/prng.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      var _crypto = null;
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
        _crypto = require_crypto();
      }
      var prng = module.exports = forge.prng = forge.prng || {};
      prng.create = function(plugin) {
        var ctx = {
          plugin,
          key: null,
          seed: null,
          time: null,
          reseeds: 0,
          generated: 0,
          keyBytes: ""
        };
        var md = plugin.md;
        var pools = new Array(32);
        for (var i = 0; i < 32; ++i) {
          pools[i] = md.create();
        }
        ctx.pools = pools;
        ctx.pool = 0;
        ctx.generate = function(count, callback) {
          if (!callback) {
            return ctx.generateSync(count);
          }
          var cipher = ctx.plugin.cipher;
          var increment = ctx.plugin.increment;
          var formatKey = ctx.plugin.formatKey;
          var formatSeed = ctx.plugin.formatSeed;
          var b = forge.util.createBuffer();
          ctx.key = null;
          generate();
          function generate(err) {
            if (err) {
              return callback(err);
            }
            if (b.length() >= count) {
              return callback(null, b.getBytes(count));
            }
            if (ctx.generated > 1048575) {
              ctx.key = null;
            }
            if (ctx.key === null) {
              return forge.util.nextTick(function() {
                _reseed(generate);
              });
            }
            var bytes = cipher(ctx.key, ctx.seed);
            ctx.generated += bytes.length;
            b.putBytes(bytes);
            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
            forge.util.setImmediate(generate);
          }
        };
        ctx.generateSync = function(count) {
          var cipher = ctx.plugin.cipher;
          var increment = ctx.plugin.increment;
          var formatKey = ctx.plugin.formatKey;
          var formatSeed = ctx.plugin.formatSeed;
          ctx.key = null;
          var b = forge.util.createBuffer();
          while (b.length() < count) {
            if (ctx.generated > 1048575) {
              ctx.key = null;
            }
            if (ctx.key === null) {
              _reseedSync();
            }
            var bytes = cipher(ctx.key, ctx.seed);
            ctx.generated += bytes.length;
            b.putBytes(bytes);
            ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
            ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          }
          return b.getBytes(count);
        };
        function _reseed(callback) {
          if (ctx.pools[0].messageLength >= 32) {
            _seed();
            return callback();
          }
          var needed = 32 - ctx.pools[0].messageLength << 5;
          ctx.seedFile(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            ctx.collect(bytes);
            _seed();
            callback();
          });
        }
        function _reseedSync() {
          if (ctx.pools[0].messageLength >= 32) {
            return _seed();
          }
          var needed = 32 - ctx.pools[0].messageLength << 5;
          ctx.collect(ctx.seedFileSync(needed));
          _seed();
        }
        function _seed() {
          ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
          var md2 = ctx.plugin.md.create();
          md2.update(ctx.keyBytes);
          var _2powK = 1;
          for (var k = 0; k < 32; ++k) {
            if (ctx.reseeds % _2powK === 0) {
              md2.update(ctx.pools[k].digest().getBytes());
              ctx.pools[k].start();
            }
            _2powK = _2powK << 1;
          }
          ctx.keyBytes = md2.digest().getBytes();
          md2.start();
          md2.update(ctx.keyBytes);
          var seedBytes = md2.digest().getBytes();
          ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
          ctx.seed = ctx.plugin.formatSeed(seedBytes);
          ctx.generated = 0;
        }
        function defaultSeedFile(needed) {
          var getRandomValues = null;
          var globalScope = forge.util.globalScope;
          var _crypto2 = globalScope.crypto || globalScope.msCrypto;
          if (_crypto2 && _crypto2.getRandomValues) {
            getRandomValues = function(arr) {
              return _crypto2.getRandomValues(arr);
            };
          }
          var b = forge.util.createBuffer();
          if (getRandomValues) {
            while (b.length() < needed) {
              var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
              var entropy = new Uint32Array(Math.floor(count));
              try {
                getRandomValues(entropy);
                for (var i2 = 0; i2 < entropy.length; ++i2) {
                  b.putInt32(entropy[i2]);
                }
              } catch (e) {
                if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                  throw e;
                }
              }
            }
          }
          if (b.length() < needed) {
            var hi, lo, next;
            var seed = Math.floor(Math.random() * 65536);
            while (b.length() < needed) {
              lo = 16807 * (seed & 65535);
              hi = 16807 * (seed >> 16);
              lo += (hi & 32767) << 16;
              lo += hi >> 15;
              lo = (lo & 2147483647) + (lo >> 31);
              seed = lo & 4294967295;
              for (var i2 = 0; i2 < 3; ++i2) {
                next = seed >>> (i2 << 3);
                next ^= Math.floor(Math.random() * 256);
                b.putByte(String.fromCharCode(next & 255));
              }
            }
          }
          return b.getBytes(needed);
        }
        if (_crypto) {
          ctx.seedFile = function(needed, callback) {
            _crypto.randomBytes(needed, function(err, bytes) {
              if (err) {
                return callback(err);
              }
              callback(null, bytes.toString());
            });
          };
          ctx.seedFileSync = function(needed) {
            return _crypto.randomBytes(needed).toString();
          };
        } else {
          ctx.seedFile = function(needed, callback) {
            try {
              callback(null, defaultSeedFile(needed));
            } catch (e) {
              callback(e);
            }
          };
          ctx.seedFileSync = defaultSeedFile;
        }
        ctx.collect = function(bytes) {
          var count = bytes.length;
          for (var i2 = 0; i2 < count; ++i2) {
            ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
            ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
          }
        };
        ctx.collectInt = function(i2, n) {
          var bytes = "";
          for (var x = 0; x < n; x += 8) {
            bytes += String.fromCharCode(i2 >> x & 255);
          }
          ctx.collect(bytes);
        };
        ctx.registerWorker = function(worker) {
          if (worker === self) {
            ctx.seedFile = function(needed, callback) {
              function listener2(e) {
                var data = e.data;
                if (data.forge && data.forge.prng) {
                  self.removeEventListener("message", listener2);
                  callback(data.forge.prng.err, data.forge.prng.bytes);
                }
              }
              self.addEventListener("message", listener2);
              self.postMessage({ forge: { prng: { needed } } });
            };
          } else {
            var listener = function(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                  worker.postMessage({ forge: { prng: { err, bytes } } });
                });
              }
            };
            worker.addEventListener("message", listener);
          }
        };
        return ctx;
      };
    }
  });

  // node_modules/node-forge/lib/random.js
  var require_random = __commonJS({
    "node_modules/node-forge/lib/random.js"(exports, module) {
      var forge = require_forge();
      require_aes();
      require_sha256();
      require_prng();
      require_util4();
      (function() {
        if (forge.random && forge.random.getBytes) {
          module.exports = forge.random;
          return;
        }
        (function(jQuery2) {
          var prng_aes = {};
          var _prng_aes_output = new Array(4);
          var _prng_aes_buffer = forge.util.createBuffer();
          prng_aes.formatKey = function(key2) {
            var tmp = forge.util.createBuffer(key2);
            key2 = new Array(4);
            key2[0] = tmp.getInt32();
            key2[1] = tmp.getInt32();
            key2[2] = tmp.getInt32();
            key2[3] = tmp.getInt32();
            return forge.aes._expandKey(key2, false);
          };
          prng_aes.formatSeed = function(seed) {
            var tmp = forge.util.createBuffer(seed);
            seed = new Array(4);
            seed[0] = tmp.getInt32();
            seed[1] = tmp.getInt32();
            seed[2] = tmp.getInt32();
            seed[3] = tmp.getInt32();
            return seed;
          };
          prng_aes.cipher = function(key2, seed) {
            forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
            _prng_aes_buffer.putInt32(_prng_aes_output[0]);
            _prng_aes_buffer.putInt32(_prng_aes_output[1]);
            _prng_aes_buffer.putInt32(_prng_aes_output[2]);
            _prng_aes_buffer.putInt32(_prng_aes_output[3]);
            return _prng_aes_buffer.getBytes();
          };
          prng_aes.increment = function(seed) {
            ++seed[3];
            return seed;
          };
          prng_aes.md = forge.md.sha256;
          function spawnPrng() {
            var ctx = forge.prng.create(prng_aes);
            ctx.getBytes = function(count, callback) {
              return ctx.generate(count, callback);
            };
            ctx.getBytesSync = function(count) {
              return ctx.generate(count);
            };
            return ctx;
          }
          var _ctx = spawnPrng();
          var getRandomValues = null;
          var globalScope = forge.util.globalScope;
          var _crypto = globalScope.crypto || globalScope.msCrypto;
          if (_crypto && _crypto.getRandomValues) {
            getRandomValues = function(arr) {
              return _crypto.getRandomValues(arr);
            };
          }
          if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
            if (typeof window === "undefined" || window.document === void 0) {
            }
            _ctx.collectInt(+new Date(), 32);
            if (typeof navigator !== "undefined") {
              var _navBytes = "";
              for (var key in navigator) {
                try {
                  if (typeof navigator[key] == "string") {
                    _navBytes += navigator[key];
                  }
                } catch (e) {
                }
              }
              _ctx.collect(_navBytes);
              _navBytes = null;
            }
            if (jQuery2) {
              jQuery2().mousemove(function(e) {
                _ctx.collectInt(e.clientX, 16);
                _ctx.collectInt(e.clientY, 16);
              });
              jQuery2().keypress(function(e) {
                _ctx.collectInt(e.charCode, 8);
              });
            }
          }
          if (!forge.random) {
            forge.random = _ctx;
          } else {
            for (var key in _ctx) {
              forge.random[key] = _ctx[key];
            }
          }
          forge.random.createInstance = spawnPrng;
          module.exports = forge.random;
        })(typeof jQuery !== "undefined" ? jQuery : null);
      })();
    }
  });

  // node_modules/node-forge/lib/rc2.js
  var require_rc2 = __commonJS({
    "node_modules/node-forge/lib/rc2.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      var piTable = [
        217,
        120,
        249,
        196,
        25,
        221,
        181,
        237,
        40,
        233,
        253,
        121,
        74,
        160,
        216,
        157,
        198,
        126,
        55,
        131,
        43,
        118,
        83,
        142,
        98,
        76,
        100,
        136,
        68,
        139,
        251,
        162,
        23,
        154,
        89,
        245,
        135,
        179,
        79,
        19,
        97,
        69,
        109,
        141,
        9,
        129,
        125,
        50,
        189,
        143,
        64,
        235,
        134,
        183,
        123,
        11,
        240,
        149,
        33,
        34,
        92,
        107,
        78,
        130,
        84,
        214,
        101,
        147,
        206,
        96,
        178,
        28,
        115,
        86,
        192,
        20,
        167,
        140,
        241,
        220,
        18,
        117,
        202,
        31,
        59,
        190,
        228,
        209,
        66,
        61,
        212,
        48,
        163,
        60,
        182,
        38,
        111,
        191,
        14,
        218,
        70,
        105,
        7,
        87,
        39,
        242,
        29,
        155,
        188,
        148,
        67,
        3,
        248,
        17,
        199,
        246,
        144,
        239,
        62,
        231,
        6,
        195,
        213,
        47,
        200,
        102,
        30,
        215,
        8,
        232,
        234,
        222,
        128,
        82,
        238,
        247,
        132,
        170,
        114,
        172,
        53,
        77,
        106,
        42,
        150,
        26,
        210,
        113,
        90,
        21,
        73,
        116,
        75,
        159,
        208,
        94,
        4,
        24,
        164,
        236,
        194,
        224,
        65,
        110,
        15,
        81,
        203,
        204,
        36,
        145,
        175,
        80,
        161,
        244,
        112,
        57,
        153,
        124,
        58,
        133,
        35,
        184,
        180,
        122,
        252,
        2,
        54,
        91,
        37,
        85,
        151,
        49,
        45,
        93,
        250,
        152,
        227,
        138,
        146,
        174,
        5,
        223,
        41,
        16,
        103,
        108,
        186,
        201,
        211,
        0,
        230,
        207,
        225,
        158,
        168,
        44,
        99,
        22,
        1,
        63,
        88,
        226,
        137,
        169,
        13,
        56,
        52,
        27,
        171,
        51,
        255,
        176,
        187,
        72,
        12,
        95,
        185,
        177,
        205,
        46,
        197,
        243,
        219,
        71,
        229,
        165,
        156,
        119,
        10,
        166,
        32,
        104,
        254,
        127,
        193,
        173
      ];
      var s = [1, 2, 3, 5];
      var rol = function(word, bits) {
        return word << bits & 65535 | (word & 65535) >> 16 - bits;
      };
      var ror = function(word, bits) {
        return (word & 65535) >> bits | word << 16 - bits & 65535;
      };
      module.exports = forge.rc2 = forge.rc2 || {};
      forge.rc2.expandKey = function(key, effKeyBits) {
        if (typeof key === "string") {
          key = forge.util.createBuffer(key);
        }
        effKeyBits = effKeyBits || 128;
        var L = key;
        var T = key.length();
        var T1 = effKeyBits;
        var T8 = Math.ceil(T1 / 8);
        var TM = 255 >> (T1 & 7);
        var i;
        for (i = T; i < 128; i++) {
          L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
        }
        L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
        for (i = 127 - T8; i >= 0; i--) {
          L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
        }
        return L;
      };
      var createCipher = function(key, bits, encrypt) {
        var _finish = false, _input = null, _output = null, _iv = null;
        var mixRound, mashRound;
        var i, j, K = [];
        key = forge.rc2.expandKey(key, bits);
        for (i = 0; i < 64; i++) {
          K.push(key.getInt16Le());
        }
        if (encrypt) {
          mixRound = function(R) {
            for (i = 0; i < 4; i++) {
              R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
              R[i] = rol(R[i], s[i]);
              j++;
            }
          };
          mashRound = function(R) {
            for (i = 0; i < 4; i++) {
              R[i] += K[R[(i + 3) % 4] & 63];
            }
          };
        } else {
          mixRound = function(R) {
            for (i = 3; i >= 0; i--) {
              R[i] = ror(R[i], s[i]);
              R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
              j--;
            }
          };
          mashRound = function(R) {
            for (i = 3; i >= 0; i--) {
              R[i] -= K[R[(i + 3) % 4] & 63];
            }
          };
        }
        var runPlan = function(plan) {
          var R = [];
          for (i = 0; i < 4; i++) {
            var val = _input.getInt16Le();
            if (_iv !== null) {
              if (encrypt) {
                val ^= _iv.getInt16Le();
              } else {
                _iv.putInt16Le(val);
              }
            }
            R.push(val & 65535);
          }
          j = encrypt ? 0 : 63;
          for (var ptr = 0; ptr < plan.length; ptr++) {
            for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
              plan[ptr][1](R);
            }
          }
          for (i = 0; i < 4; i++) {
            if (_iv !== null) {
              if (encrypt) {
                _iv.putInt16Le(R[i]);
              } else {
                R[i] ^= _iv.getInt16Le();
              }
            }
            _output.putInt16Le(R[i]);
          }
        };
        var cipher = null;
        cipher = {
          start: function(iv, output) {
            if (iv) {
              if (typeof iv === "string") {
                iv = forge.util.createBuffer(iv);
              }
            }
            _finish = false;
            _input = forge.util.createBuffer();
            _output = output || new forge.util.createBuffer();
            _iv = iv;
            cipher.output = _output;
          },
          update: function(input) {
            if (!_finish) {
              _input.putBuffer(input);
            }
            while (_input.length() >= 8) {
              runPlan([
                [5, mixRound],
                [1, mashRound],
                [6, mixRound],
                [1, mashRound],
                [5, mixRound]
              ]);
            }
          },
          finish: function(pad) {
            var rval = true;
            if (encrypt) {
              if (pad) {
                rval = pad(8, _input, !encrypt);
              } else {
                var padding = _input.length() === 8 ? 8 : 8 - _input.length();
                _input.fillWithByte(padding, padding);
              }
            }
            if (rval) {
              _finish = true;
              cipher.update();
            }
            if (!encrypt) {
              rval = _input.length() === 0;
              if (rval) {
                if (pad) {
                  rval = pad(8, _output, !encrypt);
                } else {
                  var len = _output.length();
                  var count = _output.at(len - 1);
                  if (count > len) {
                    rval = false;
                  } else {
                    _output.truncate(count);
                  }
                }
              }
            }
            return rval;
          }
        };
        return cipher;
      };
      forge.rc2.startEncrypting = function(key, iv, output) {
        var cipher = forge.rc2.createEncryptionCipher(key, 128);
        cipher.start(iv, output);
        return cipher;
      };
      forge.rc2.createEncryptionCipher = function(key, bits) {
        return createCipher(key, bits, true);
      };
      forge.rc2.startDecrypting = function(key, iv, output) {
        var cipher = forge.rc2.createDecryptionCipher(key, 128);
        cipher.start(iv, output);
        return cipher;
      };
      forge.rc2.createDecryptionCipher = function(key, bits) {
        return createCipher(key, bits, false);
      };
    }
  });

  // node_modules/node-forge/lib/jsbn.js
  var require_jsbn = __commonJS({
    "node_modules/node-forge/lib/jsbn.js"(exports, module) {
      var forge = require_forge();
      module.exports = forge.jsbn = forge.jsbn || {};
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        this.data = [];
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      forge.jsbn.BigInteger = BigInteger;
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this.data[i++] + w.data[j] + c;
          c = Math.floor(v / 67108864);
          w.data[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this.data[i] & 32767;
          var h = this.data[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w.data[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this.data[i] & 16383;
          var h = this.data[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w.data[j++] = l & 268435455;
        }
        return c;
      }
      if (typeof navigator === "undefined") {
        BigInteger.prototype.am = am3;
        dbits = 28;
      } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr;
      var vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r.data[i] = this.data[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this.data[0] = x;
        else if (x < -1)
          this.data[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this.data[this.t++] = x;
          else if (sh + k > this.DB) {
            this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this.data[this.t++] = x >> this.DB - sh;
          } else
            this.data[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this.data[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this.data[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this.data[i] & (1 << p) - 1) << k - p;
              d |= this.data[--i] >> (p += this.DB - k);
            } else {
              d = this.data[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this.data[i] - a.data[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t;
        if ((t = x >>> 16) != 0) {
          x = t;
          r += 16;
        }
        if ((t = x >> 8) != 0) {
          x = t;
          r += 8;
        }
        if ((t = x >> 4) != 0) {
          x = t;
          r += 4;
        }
        if ((t = x >> 2) != 0) {
          x = t;
          r += 2;
        }
        if ((t = x >> 1) != 0) {
          x = t;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r.data[i + n] = this.data[i];
        for (i = n - 1; i >= 0; --i)
          r.data[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r.data[i - n] = this.data[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r.data[i + ds + 1] = this.data[i] >> cbs | c;
          c = (this.data[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r.data[i] = 0;
        r.data[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r.data[0] = this.data[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
          r.data[i - ds] = this.data[i] >> bs;
        }
        if (bs > 0)
          r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this.data[i] - a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r.data[i++] = this.DV + c;
        else if (c > 0)
          r.data[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r.data[i] = 0;
        for (i = 0; i < y.t; ++i)
          r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r.data[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
          if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r.data[i + x.t] -= x.DV;
            r.data[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm.data[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y.data[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t = q == null ? nbi() : q;
        y.dlShiftTo(j, t);
        if (r.compareTo(t) >= 0) {
          r.data[r.t++] = 1;
          r.subTo(t, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t);
        t.subTo(y, y);
        while (y.t < ys)
          y.data[y.t++] = 0;
        while (--j >= 0) {
          var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
          if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t);
            r.subTo(t, r);
            while (r.data[i] < --qd)
              r.subTo(t, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this.data[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x.data[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x.data[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x.data[j] >= x.DV) {
            x.data[j] -= x.DV;
            x.data[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z.mulTo(r2, g, r);
          else {
            var t = r;
            r = r2;
            r2 = t;
          }
        }
        return z.revert(r);
      }
      function bnModPowInt(e, m) {
        var z;
        if (e < 256 || m.isEven())
          z = new Classic(m);
        else
          z = new Montgomery(m);
        return this.exp(e, z);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this.data[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this.data[0];
        else if (this.t == 0)
          return 0;
        return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z = nbi(), r = "";
        this.divRemTo(d, y, z);
        while (y.signum() > 0) {
          r = (a + z.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z);
        }
        return z.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t > 0)
            x[0] &= (1 << t) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this.data[i] & (1 << p) - 1) << 8 - p;
              d |= this.data[--i] >> (p += this.DB - 8);
            } else {
              d = this.data[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r.data[i] = op(this.data[i], a.data[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r.data[i] = op(this.data[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r.data[i] = op(f, a.data[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r.data[i] = this.DM & ~this.data[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this.data[i] != 0)
            return i * this.DB + lbit(this.data[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this.data[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this.data[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this.data[i] + a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a.data[i];
            r.data[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r.data[i++] = c;
        else if (c < -1)
          r.data[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this.data[this.t++] = 0;
        this.data[w] += n;
        while (this.data[w] >= this.DV) {
          this.data[w] -= this.DV;
          if (++w >= this.t)
            this.data[this.t++] = 0;
          ++this.data[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r.data[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a.data[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r.data[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z = new Classic(m);
        else if (m.isEven())
          z = new Barrett(m);
        else
          z = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
        i = nbits(e.data[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e.data[j] >> i - k1 & km;
          else {
            w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e.data[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z.sqrTo(r, r2);
              z.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z.sqrTo(r, r2);
            else {
              t = r;
              r = r2;
              r2 = t;
            }
            z.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e.data[j] & 1 << i) == 0) {
            z.sqrTo(r, r2);
            t = r;
            r = r2;
            r2 = t;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t = x;
          x = y;
          y = t;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this.data[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this.data[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t) {
        var i, x = this.abs();
        if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x.data[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t);
      }
      function bnpMillerRabin(t) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        var prng = bnGetPrng();
        var a;
        for (var i = 0; i < t; ++i) {
          do {
            a = new BigInteger(this.bitLength(), prng);
          } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      function bnGetPrng() {
        return {
          nextBytes: function(x) {
            for (var i = 0; i < x.length; ++i) {
              x[i] = Math.floor(Math.random() * 256);
            }
          }
        };
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    }
  });

  // node_modules/node-forge/lib/sha1.js
  var require_sha1 = __commonJS({
    "node_modules/node-forge/lib/sha1.js"(exports, module) {
      var forge = require_forge();
      require_md();
      require_util4();
      var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
      forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
      sha1.create = function() {
        if (!_initialized) {
          _init();
        }
        var _state = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(80);
        var md = {
          algorithm: "sha1",
          blockLength: 64,
          digestLength: 20,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 8
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength64 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _state = {
            h0: 1732584193,
            h1: 4023233417,
            h2: 2562383102,
            h3: 271733878,
            h4: 3285377520
          };
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_state, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var next, carry;
          var bits = md.fullMessageLength[0] * 8;
          for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
            next = md.fullMessageLength[i + 1] * 8;
            carry = next / 4294967296 >>> 0;
            bits += carry;
            finalBlock.putInt32(bits >>> 0);
            bits = next >>> 0;
          }
          finalBlock.putInt32(bits);
          var s2 = {
            h0: _state.h0,
            h1: _state.h1,
            h2: _state.h2,
            h3: _state.h3,
            h4: _state.h4
          };
          _update(s2, _w, finalBlock);
          var rval = forge.util.createBuffer();
          rval.putInt32(s2.h0);
          rval.putInt32(s2.h1);
          rval.putInt32(s2.h2);
          rval.putInt32(s2.h3);
          rval.putInt32(s2.h4);
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _initialized = false;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 64);
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t, a, b, c, d, e, f, i;
        var len = bytes.length();
        while (len >= 64) {
          a = s.h0;
          b = s.h1;
          c = s.h2;
          d = s.h3;
          e = s.h4;
          for (i = 0; i < 16; ++i) {
            t = bytes.getInt32();
            w[i] = t;
            f = d ^ b & (c ^ d);
            t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 20; ++i) {
            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
            t = t << 1 | t >>> 31;
            w[i] = t;
            f = d ^ b & (c ^ d);
            t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 32; ++i) {
            t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
            t = t << 1 | t >>> 31;
            w[i] = t;
            f = b ^ c ^ d;
            t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 40; ++i) {
            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
            t = t << 2 | t >>> 30;
            w[i] = t;
            f = b ^ c ^ d;
            t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 60; ++i) {
            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
            t = t << 2 | t >>> 30;
            w[i] = t;
            f = b & c | d & (b ^ c);
            t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          for (; i < 80; ++i) {
            t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
            t = t << 2 | t >>> 30;
            w[i] = t;
            f = b ^ c ^ d;
            t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
            e = d;
            d = c;
            c = (b << 30 | b >>> 2) >>> 0;
            b = a;
            a = t;
          }
          s.h0 = s.h0 + a | 0;
          s.h1 = s.h1 + b | 0;
          s.h2 = s.h2 + c | 0;
          s.h3 = s.h3 + d | 0;
          s.h4 = s.h4 + e | 0;
          len -= 64;
        }
      }
    }
  });

  // node_modules/node-forge/lib/pkcs1.js
  var require_pkcs1 = __commonJS({
    "node_modules/node-forge/lib/pkcs1.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      require_random();
      require_sha1();
      var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
      pkcs1.encode_rsa_oaep = function(key, message, options) {
        var label;
        var seed;
        var md;
        var mgf1Md;
        if (typeof options === "string") {
          label = options;
          seed = arguments[3] || void 0;
          md = arguments[4] || void 0;
        } else if (options) {
          label = options.label || void 0;
          seed = options.seed || void 0;
          md = options.md || void 0;
          if (options.mgf1 && options.mgf1.md) {
            mgf1Md = options.mgf1.md;
          }
        }
        if (!md) {
          md = forge.md.sha1.create();
        } else {
          md.start();
        }
        if (!mgf1Md) {
          mgf1Md = md;
        }
        var keyLength = Math.ceil(key.n.bitLength() / 8);
        var maxLength = keyLength - 2 * md.digestLength - 2;
        if (message.length > maxLength) {
          var error = new Error("RSAES-OAEP input message length is too long.");
          error.length = message.length;
          error.maxLength = maxLength;
          throw error;
        }
        if (!label) {
          label = "";
        }
        md.update(label, "raw");
        var lHash = md.digest();
        var PS = "";
        var PS_length = maxLength - message.length;
        for (var i = 0; i < PS_length; i++) {
          PS += "\0";
        }
        var DB = lHash.getBytes() + PS + "" + message;
        if (!seed) {
          seed = forge.random.getBytes(md.digestLength);
        } else if (seed.length !== md.digestLength) {
          var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
          error.seedLength = seed.length;
          error.digestLength = md.digestLength;
          throw error;
        }
        var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
        var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
        var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
        var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
        return "\0" + maskedSeed + maskedDB;
      };
      pkcs1.decode_rsa_oaep = function(key, em, options) {
        var label;
        var md;
        var mgf1Md;
        if (typeof options === "string") {
          label = options;
          md = arguments[3] || void 0;
        } else if (options) {
          label = options.label || void 0;
          md = options.md || void 0;
          if (options.mgf1 && options.mgf1.md) {
            mgf1Md = options.mgf1.md;
          }
        }
        var keyLength = Math.ceil(key.n.bitLength() / 8);
        if (em.length !== keyLength) {
          var error = new Error("RSAES-OAEP encoded message length is invalid.");
          error.length = em.length;
          error.expectedLength = keyLength;
          throw error;
        }
        if (md === void 0) {
          md = forge.md.sha1.create();
        } else {
          md.start();
        }
        if (!mgf1Md) {
          mgf1Md = md;
        }
        if (keyLength < 2 * md.digestLength + 2) {
          throw new Error("RSAES-OAEP key is too short for the hash function.");
        }
        if (!label) {
          label = "";
        }
        md.update(label, "raw");
        var lHash = md.digest().getBytes();
        var y = em.charAt(0);
        var maskedSeed = em.substring(1, md.digestLength + 1);
        var maskedDB = em.substring(1 + md.digestLength);
        var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
        var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
        var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
        var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
        var lHashPrime = db.substring(0, md.digestLength);
        var error = y !== "\0";
        for (var i = 0; i < md.digestLength; ++i) {
          error |= lHash.charAt(i) !== lHashPrime.charAt(i);
        }
        var in_ps = 1;
        var index = md.digestLength;
        for (var j = md.digestLength; j < db.length; j++) {
          var code = db.charCodeAt(j);
          var is_0 = code & 1 ^ 1;
          var error_mask = in_ps ? 65534 : 0;
          error |= code & error_mask;
          in_ps = in_ps & is_0;
          index += in_ps;
        }
        if (error || db.charCodeAt(index) !== 1) {
          throw new Error("Invalid RSAES-OAEP padding.");
        }
        return db.substring(index + 1);
      };
      function rsa_mgf1(seed, maskLength, hash) {
        if (!hash) {
          hash = forge.md.sha1.create();
        }
        var t = "";
        var count = Math.ceil(maskLength / hash.digestLength);
        for (var i = 0; i < count; ++i) {
          var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
          hash.start();
          hash.update(seed + c);
          t += hash.digest().getBytes();
        }
        return t.substring(0, maskLength);
      }
    }
  });

  // node_modules/node-forge/lib/prime.js
  var require_prime = __commonJS({
    "node_modules/node-forge/lib/prime.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      require_jsbn();
      require_random();
      (function() {
        if (forge.prime) {
          module.exports = forge.prime;
          return;
        }
        var prime = module.exports = forge.prime = forge.prime || {};
        var BigInteger = forge.jsbn.BigInteger;
        var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
        var THIRTY = new BigInteger(null);
        THIRTY.fromInt(30);
        var op_or = function(x, y) {
          return x | y;
        };
        prime.generateProbablePrime = function(bits, options, callback) {
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          options = options || {};
          var algorithm = options.algorithm || "PRIMEINC";
          if (typeof algorithm === "string") {
            algorithm = { name: algorithm };
          }
          algorithm.options = algorithm.options || {};
          var prng = options.prng || forge.random;
          var rng = {
            nextBytes: function(x) {
              var b = prng.getBytesSync(x.length);
              for (var i = 0; i < x.length; ++i) {
                x[i] = b.charCodeAt(i);
              }
            }
          };
          if (algorithm.name === "PRIMEINC") {
            return primeincFindPrime(bits, rng, algorithm.options, callback);
          }
          throw new Error("Invalid prime generation algorithm: " + algorithm.name);
        };
        function primeincFindPrime(bits, rng, options, callback) {
          if ("workers" in options) {
            return primeincFindPrimeWithWorkers(bits, rng, options, callback);
          }
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
          var num = generateRandom(bits, rng);
          var deltaIdx = 0;
          var mrTests = getMillerRabinTests(num.bitLength());
          if ("millerRabinTests" in options) {
            mrTests = options.millerRabinTests;
          }
          var maxBlockTime = 10;
          if ("maxBlockTime" in options) {
            maxBlockTime = options.maxBlockTime;
          }
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        }
        function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
          var start = +new Date();
          do {
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            if (num.isProbablePrime(mrTests)) {
              return callback(null, num);
            }
            num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
          } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
          forge.util.setImmediate(function() {
            _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
          });
        }
        function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
          if (typeof Worker === "undefined") {
            return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
          }
          var num = generateRandom(bits, rng);
          var numWorkers = options.workers;
          var workLoad = options.workLoad || 100;
          var range = workLoad * 30 / 8;
          var workerScript = options.workerScript || "forge/prime.worker.js";
          if (numWorkers === -1) {
            return forge.util.estimateCores(function(err, cores) {
              if (err) {
                cores = 2;
              }
              numWorkers = cores - 1;
              generate();
            });
          }
          generate();
          function generate() {
            numWorkers = Math.max(1, numWorkers);
            var workers = [];
            for (var i = 0; i < numWorkers; ++i) {
              workers[i] = new Worker(workerScript);
            }
            var running = numWorkers;
            for (var i = 0; i < numWorkers; ++i) {
              workers[i].addEventListener("message", workerMessage);
            }
            var found = false;
            function workerMessage(e) {
              if (found) {
                return;
              }
              --running;
              var data = e.data;
              if (data.found) {
                for (var i2 = 0; i2 < workers.length; ++i2) {
                  workers[i2].terminate();
                }
                found = true;
                return callback(null, new BigInteger(data.prime, 16));
              }
              if (num.bitLength() > bits) {
                num = generateRandom(bits, rng);
              }
              var hex = num.toString(16);
              e.target.postMessage({
                hex,
                workLoad
              });
              num.dAddOffset(range, 0);
            }
          }
        }
        function generateRandom(bits, rng) {
          var num = new BigInteger(bits, rng);
          var bits1 = bits - 1;
          if (!num.testBit(bits1)) {
            num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
          }
          num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
          return num;
        }
        function getMillerRabinTests(bits) {
          if (bits <= 100)
            return 27;
          if (bits <= 150)
            return 18;
          if (bits <= 200)
            return 15;
          if (bits <= 250)
            return 12;
          if (bits <= 300)
            return 9;
          if (bits <= 350)
            return 8;
          if (bits <= 400)
            return 7;
          if (bits <= 500)
            return 6;
          if (bits <= 600)
            return 5;
          if (bits <= 800)
            return 4;
          if (bits <= 1250)
            return 3;
          return 2;
        }
      })();
    }
  });

  // node_modules/node-forge/lib/rsa.js
  var require_rsa = __commonJS({
    "node_modules/node-forge/lib/rsa.js"(exports, module) {
      var forge = require_forge();
      require_asn1();
      require_jsbn();
      require_oids();
      require_pkcs1();
      require_prime();
      require_random();
      require_util4();
      if (typeof BigInteger === "undefined") {
        BigInteger = forge.jsbn.BigInteger;
      }
      var BigInteger;
      var _crypto = forge.util.isNodejs ? require_crypto() : null;
      var asn1 = forge.asn1;
      var util = forge.util;
      forge.pki = forge.pki || {};
      module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
      var pki = forge.pki;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var privateKeyValidator = {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PrivateKeyInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion"
        }, {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "privateKeyOid"
          }]
        }, {
          name: "PrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "privateKey"
        }]
      };
      var rsaPrivateKeyValidator = {
        name: "RSAPrivateKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RSAPrivateKey.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion"
        }, {
          name: "RSAPrivateKey.modulus",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyModulus"
        }, {
          name: "RSAPrivateKey.publicExponent",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPublicExponent"
        }, {
          name: "RSAPrivateKey.privateExponent",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrivateExponent"
        }, {
          name: "RSAPrivateKey.prime1",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrime1"
        }, {
          name: "RSAPrivateKey.prime2",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyPrime2"
        }, {
          name: "RSAPrivateKey.exponent1",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyExponent1"
        }, {
          name: "RSAPrivateKey.exponent2",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyExponent2"
        }, {
          name: "RSAPrivateKey.coefficient",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyCoefficient"
        }]
      };
      var rsaPublicKeyValidator = {
        name: "RSAPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RSAPublicKey.modulus",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "publicKeyModulus"
        }, {
          name: "RSAPublicKey.exponent",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "publicKeyExponent"
        }]
      };
      var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
        name: "SubjectPublicKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "subjectPublicKeyInfo",
        value: [{
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        }, {
          name: "SubjectPublicKeyInfo.subjectPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: "rsaPublicKey"
          }]
        }]
      };
      var emsaPkcs1v15encode = function(md) {
        var oid;
        if (md.algorithm in pki.oids) {
          oid = pki.oids[md.algorithm];
        } else {
          var error = new Error("Unknown message digest algorithm.");
          error.algorithm = md.algorithm;
          throw error;
        }
        var oidBytes = asn1.oidToDer(oid).getBytes();
        var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
        digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
        var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
        digestInfo.value.push(digestAlgorithm);
        digestInfo.value.push(digest);
        return asn1.toDer(digestInfo).getBytes();
      };
      var _modPow = function(x, key, pub) {
        if (pub) {
          return x.modPow(key.e, key.n);
        }
        if (!key.p || !key.q) {
          return x.modPow(key.d, key.n);
        }
        if (!key.dP) {
          key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
        }
        if (!key.dQ) {
          key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
        }
        if (!key.qInv) {
          key.qInv = key.q.modInverse(key.p);
        }
        var r;
        do {
          r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
        } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
        x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
        var xp = x.mod(key.p).modPow(key.dP, key.p);
        var xq = x.mod(key.q).modPow(key.dQ, key.q);
        while (xp.compareTo(xq) < 0) {
          xp = xp.add(key.p);
        }
        var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
        y = y.multiply(r.modInverse(key.n)).mod(key.n);
        return y;
      };
      pki.rsa.encrypt = function(m, key, bt) {
        var pub = bt;
        var eb;
        var k = Math.ceil(key.n.bitLength() / 8);
        if (bt !== false && bt !== true) {
          pub = bt === 2;
          eb = _encodePkcs1_v1_5(m, key, bt);
        } else {
          eb = forge.util.createBuffer();
          eb.putBytes(m);
        }
        var x = new BigInteger(eb.toHex(), 16);
        var y = _modPow(x, key, pub);
        var yhex = y.toString(16);
        var ed = forge.util.createBuffer();
        var zeros = k - Math.ceil(yhex.length / 2);
        while (zeros > 0) {
          ed.putByte(0);
          --zeros;
        }
        ed.putBytes(forge.util.hexToBytes(yhex));
        return ed.getBytes();
      };
      pki.rsa.decrypt = function(ed, key, pub, ml) {
        var k = Math.ceil(key.n.bitLength() / 8);
        if (ed.length !== k) {
          var error = new Error("Encrypted message length is invalid.");
          error.length = ed.length;
          error.expected = k;
          throw error;
        }
        var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
        if (y.compareTo(key.n) >= 0) {
          throw new Error("Encrypted message is invalid.");
        }
        var x = _modPow(y, key, pub);
        var xhex = x.toString(16);
        var eb = forge.util.createBuffer();
        var zeros = k - Math.ceil(xhex.length / 2);
        while (zeros > 0) {
          eb.putByte(0);
          --zeros;
        }
        eb.putBytes(forge.util.hexToBytes(xhex));
        if (ml !== false) {
          return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
        }
        return eb.getBytes();
      };
      pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
        if (typeof bits === "string") {
          bits = parseInt(bits, 10);
        }
        bits = bits || 2048;
        options = options || {};
        var prng = options.prng || forge.random;
        var rng = {
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        var algorithm = options.algorithm || "PRIMEINC";
        var rval;
        if (algorithm === "PRIMEINC") {
          rval = {
            algorithm,
            state: 0,
            bits,
            rng,
            eInt: e || 65537,
            e: new BigInteger(null),
            p: null,
            q: null,
            qBits: bits >> 1,
            pBits: bits - (bits >> 1),
            pqState: 0,
            num: null,
            keys: null
          };
          rval.e.fromInt(rval.eInt);
        } else {
          throw new Error("Invalid key generation algorithm: " + algorithm);
        }
        return rval;
      };
      pki.rsa.stepKeyPairGenerationState = function(state, n) {
        if (!("algorithm" in state)) {
          state.algorithm = "PRIMEINC";
        }
        var THIRTY = new BigInteger(null);
        THIRTY.fromInt(30);
        var deltaIdx = 0;
        var op_or = function(x, y) {
          return x | y;
        };
        var t1 = +new Date();
        var t2;
        var total = 0;
        while (state.keys === null && (n <= 0 || total < n)) {
          if (state.state === 0) {
            var bits = state.p === null ? state.pBits : state.qBits;
            var bits1 = bits - 1;
            if (state.pqState === 0) {
              state.num = new BigInteger(bits, state.rng);
              if (!state.num.testBit(bits1)) {
                state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
              }
              state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
              deltaIdx = 0;
              ++state.pqState;
            } else if (state.pqState === 1) {
              if (state.num.bitLength() > bits) {
                state.pqState = 0;
              } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
                ++state.pqState;
              } else {
                state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
              }
            } else if (state.pqState === 2) {
              state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
            } else if (state.pqState === 3) {
              state.pqState = 0;
              if (state.p === null) {
                state.p = state.num;
              } else {
                state.q = state.num;
              }
              if (state.p !== null && state.q !== null) {
                ++state.state;
              }
              state.num = null;
            }
          } else if (state.state === 1) {
            if (state.p.compareTo(state.q) < 0) {
              state.num = state.p;
              state.p = state.q;
              state.q = state.num;
            }
            ++state.state;
          } else if (state.state === 2) {
            state.p1 = state.p.subtract(BigInteger.ONE);
            state.q1 = state.q.subtract(BigInteger.ONE);
            state.phi = state.p1.multiply(state.q1);
            ++state.state;
          } else if (state.state === 3) {
            if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
              ++state.state;
            } else {
              state.p = null;
              state.q = null;
              state.state = 0;
            }
          } else if (state.state === 4) {
            state.n = state.p.multiply(state.q);
            if (state.n.bitLength() === state.bits) {
              ++state.state;
            } else {
              state.q = null;
              state.state = 0;
            }
          } else if (state.state === 5) {
            var d = state.e.modInverse(state.phi);
            state.keys = {
              privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
              publicKey: pki.rsa.setPublicKey(state.n, state.e)
            };
          }
          t2 = +new Date();
          total += t2 - t1;
          t1 = t2;
        }
        return state.keys !== null;
      };
      pki.rsa.generateKeyPair = function(bits, e, options, callback) {
        if (arguments.length === 1) {
          if (typeof bits === "object") {
            options = bits;
            bits = void 0;
          } else if (typeof bits === "function") {
            callback = bits;
            bits = void 0;
          }
        } else if (arguments.length === 2) {
          if (typeof bits === "number") {
            if (typeof e === "function") {
              callback = e;
              e = void 0;
            } else if (typeof e !== "number") {
              options = e;
              e = void 0;
            }
          } else {
            options = bits;
            callback = e;
            bits = void 0;
            e = void 0;
          }
        } else if (arguments.length === 3) {
          if (typeof e === "number") {
            if (typeof options === "function") {
              callback = options;
              options = void 0;
            }
          } else {
            callback = options;
            options = e;
            e = void 0;
          }
        }
        options = options || {};
        if (bits === void 0) {
          bits = options.bits || 2048;
        }
        if (e === void 0) {
          e = options.e || 65537;
        }
        if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
          if (callback) {
            if (_detectNodeCrypto("generateKeyPair")) {
              return _crypto.generateKeyPair("rsa", {
                modulusLength: bits,
                publicExponent: e,
                publicKeyEncoding: {
                  type: "spki",
                  format: "pem"
                },
                privateKeyEncoding: {
                  type: "pkcs8",
                  format: "pem"
                }
              }, function(err, pub, priv) {
                if (err) {
                  return callback(err);
                }
                callback(null, {
                  privateKey: pki.privateKeyFromPem(priv),
                  publicKey: pki.publicKeyFromPem(pub)
                });
              });
            }
            if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
              return util.globalScope.crypto.subtle.generateKey({
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: bits,
                publicExponent: _intToUint8Array(e),
                hash: { name: "SHA-256" }
              }, true, ["sign", "verify"]).then(function(pair) {
                return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
              }).then(void 0, function(err) {
                callback(err);
              }).then(function(pkcs8) {
                if (pkcs8) {
                  var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                  callback(null, {
                    privateKey,
                    publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                  });
                }
              });
            }
            if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
              var genOp = util.globalScope.msCrypto.subtle.generateKey({
                name: "RSASSA-PKCS1-v1_5",
                modulusLength: bits,
                publicExponent: _intToUint8Array(e),
                hash: { name: "SHA-256" }
              }, true, ["sign", "verify"]);
              genOp.oncomplete = function(e2) {
                var pair = e2.target.result;
                var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
                exportOp.oncomplete = function(e3) {
                  var pkcs8 = e3.target.result;
                  var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                  callback(null, {
                    privateKey,
                    publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                  });
                };
                exportOp.onerror = function(err) {
                  callback(err);
                };
              };
              genOp.onerror = function(err) {
                callback(err);
              };
              return;
            }
          } else {
            if (_detectNodeCrypto("generateKeyPairSync")) {
              var keypair = _crypto.generateKeyPairSync("rsa", {
                modulusLength: bits,
                publicExponent: e,
                publicKeyEncoding: {
                  type: "spki",
                  format: "pem"
                },
                privateKeyEncoding: {
                  type: "pkcs8",
                  format: "pem"
                }
              });
              return {
                privateKey: pki.privateKeyFromPem(keypair.privateKey),
                publicKey: pki.publicKeyFromPem(keypair.publicKey)
              };
            }
          }
        }
        var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
        if (!callback) {
          pki.rsa.stepKeyPairGenerationState(state, 0);
          return state.keys;
        }
        _generateKeyPair(state, options, callback);
      };
      pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
        var key = {
          n,
          e
        };
        key.encrypt = function(data, scheme, schemeOptions) {
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          } else if (scheme === void 0) {
            scheme = "RSAES-PKCS1-V1_5";
          }
          if (scheme === "RSAES-PKCS1-V1_5") {
            scheme = {
              encode: function(m, key2, pub) {
                return _encodePkcs1_v1_5(m, key2, 2).getBytes();
              }
            };
          } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
            scheme = {
              encode: function(m, key2) {
                return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
              }
            };
          } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
            scheme = { encode: function(e3) {
              return e3;
            } };
          } else if (typeof scheme === "string") {
            throw new Error('Unsupported encryption scheme: "' + scheme + '".');
          }
          var e2 = scheme.encode(data, key, true);
          return pki.rsa.encrypt(e2, key, true);
        };
        key.verify = function(digest, signature, scheme) {
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          } else if (scheme === void 0) {
            scheme = "RSASSA-PKCS1-V1_5";
          }
          if (scheme === "RSASSA-PKCS1-V1_5") {
            scheme = {
              verify: function(digest2, d2) {
                d2 = _decodePkcs1_v1_5(d2, key, true);
                var obj = asn1.fromDer(d2);
                return digest2 === obj.value[1].value;
              }
            };
          } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
            scheme = {
              verify: function(digest2, d2) {
                d2 = _decodePkcs1_v1_5(d2, key, true);
                return digest2 === d2;
              }
            };
          }
          var d = pki.rsa.decrypt(signature, key, true, false);
          return scheme.verify(digest, d, key.n.bitLength());
        };
        return key;
      };
      pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
        var key = {
          n,
          e,
          d,
          p,
          q,
          dP,
          dQ,
          qInv
        };
        key.decrypt = function(data, scheme, schemeOptions) {
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          } else if (scheme === void 0) {
            scheme = "RSAES-PKCS1-V1_5";
          }
          var d2 = pki.rsa.decrypt(data, key, false, false);
          if (scheme === "RSAES-PKCS1-V1_5") {
            scheme = { decode: _decodePkcs1_v1_5 };
          } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
            scheme = {
              decode: function(d3, key2) {
                return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
              }
            };
          } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
            scheme = { decode: function(d3) {
              return d3;
            } };
          } else {
            throw new Error('Unsupported encryption scheme: "' + scheme + '".');
          }
          return scheme.decode(d2, key, false);
        };
        key.sign = function(md, scheme) {
          var bt = false;
          if (typeof scheme === "string") {
            scheme = scheme.toUpperCase();
          }
          if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
            scheme = { encode: emsaPkcs1v15encode };
            bt = 1;
          } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
            scheme = { encode: function() {
              return md;
            } };
            bt = 1;
          }
          var d2 = scheme.encode(md, key.n.bitLength());
          return pki.rsa.encrypt(d2, key, bt);
        };
        return key;
      };
      pki.wrapRsaPrivateKey = function(rsaKey) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
        ]);
      };
      pki.privateKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
          obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
        }
        capture = {};
        errors = [];
        if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
          var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
          error.errors = errors;
          throw error;
        }
        var n, e, d, p, q, dP, dQ, qInv;
        n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
        e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
        d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
        p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
        q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
        dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
        dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
        qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
        return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
      };
      pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
        ]);
      };
      pki.publicKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
          var oid = asn1.derToOid(capture.publicKeyOid);
          if (oid !== pki.oids.rsaEncryption) {
            var error = new Error("Cannot read public key. Unknown OID.");
            error.oid = oid;
            throw error;
          }
          obj = capture.rsaPublicKey;
        }
        errors = [];
        if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
          var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
          error.errors = errors;
          throw error;
        }
        var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
        var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
        return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
      };
      pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
            pki.publicKeyToRSAPublicKey(key)
          ])
        ]);
      };
      pki.publicKeyToRSAPublicKey = function(key) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))
        ]);
      };
      function _encodePkcs1_v1_5(m, key, bt) {
        var eb = forge.util.createBuffer();
        var k = Math.ceil(key.n.bitLength() / 8);
        if (m.length > k - 11) {
          var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
          error.length = m.length;
          error.max = k - 11;
          throw error;
        }
        eb.putByte(0);
        eb.putByte(bt);
        var padNum = k - 3 - m.length;
        var padByte;
        if (bt === 0 || bt === 1) {
          padByte = bt === 0 ? 0 : 255;
          for (var i = 0; i < padNum; ++i) {
            eb.putByte(padByte);
          }
        } else {
          while (padNum > 0) {
            var numZeros = 0;
            var padBytes = forge.random.getBytes(padNum);
            for (var i = 0; i < padNum; ++i) {
              padByte = padBytes.charCodeAt(i);
              if (padByte === 0) {
                ++numZeros;
              } else {
                eb.putByte(padByte);
              }
            }
            padNum = numZeros;
          }
        }
        eb.putByte(0);
        eb.putBytes(m);
        return eb;
      }
      function _decodePkcs1_v1_5(em, key, pub, ml) {
        var k = Math.ceil(key.n.bitLength() / 8);
        var eb = forge.util.createBuffer(em);
        var first = eb.getByte();
        var bt = eb.getByte();
        if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
          throw new Error("Encryption block is invalid.");
        }
        var padNum = 0;
        if (bt === 0) {
          padNum = k - 3 - ml;
          for (var i = 0; i < padNum; ++i) {
            if (eb.getByte() !== 0) {
              throw new Error("Encryption block is invalid.");
            }
          }
        } else if (bt === 1) {
          padNum = 0;
          while (eb.length() > 1) {
            if (eb.getByte() !== 255) {
              --eb.read;
              break;
            }
            ++padNum;
          }
        } else if (bt === 2) {
          padNum = 0;
          while (eb.length() > 1) {
            if (eb.getByte() === 0) {
              --eb.read;
              break;
            }
            ++padNum;
          }
        }
        var zero = eb.getByte();
        if (zero !== 0 || padNum !== k - 3 - eb.length()) {
          throw new Error("Encryption block is invalid.");
        }
        return eb.getBytes();
      }
      function _generateKeyPair(state, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var opts = {
          algorithm: {
            name: options.algorithm || "PRIMEINC",
            options: {
              workers: options.workers || 2,
              workLoad: options.workLoad || 100,
              workerScript: options.workerScript
            }
          }
        };
        if ("prng" in options) {
          opts.prng = options.prng;
        }
        generate();
        function generate() {
          getPrime(state.pBits, function(err, num) {
            if (err) {
              return callback(err);
            }
            state.p = num;
            if (state.q !== null) {
              return finish(err, state.q);
            }
            getPrime(state.qBits, finish);
          });
        }
        function getPrime(bits, callback2) {
          forge.prime.generateProbablePrime(bits, opts, callback2);
        }
        function finish(err, num) {
          if (err) {
            return callback(err);
          }
          state.q = num;
          if (state.p.compareTo(state.q) < 0) {
            var tmp = state.p;
            state.p = state.q;
            state.q = tmp;
          }
          if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
            state.p = null;
            generate();
            return;
          }
          if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
            state.q = null;
            getPrime(state.qBits, finish);
            return;
          }
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
            state.p = state.q = null;
            generate();
            return;
          }
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() !== state.bits) {
            state.q = null;
            getPrime(state.qBits, finish);
            return;
          }
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
          callback(null, state.keys);
        }
      }
      function _bnToBytes(b) {
        var hex = b.toString(16);
        if (hex[0] >= "8") {
          hex = "00" + hex;
        }
        var bytes = forge.util.hexToBytes(hex);
        if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
          return bytes.substr(1);
        }
        return bytes;
      }
      function _getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
      function _detectNodeCrypto(fn) {
        return forge.util.isNodejs && typeof _crypto[fn] === "function";
      }
      function _detectSubtleCrypto(fn) {
        return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
      }
      function _detectSubtleMsCrypto(fn) {
        return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
      }
      function _intToUint8Array(x) {
        var bytes = forge.util.hexToBytes(x.toString(16));
        var buffer = new Uint8Array(bytes.length);
        for (var i = 0; i < bytes.length; ++i) {
          buffer[i] = bytes.charCodeAt(i);
        }
        return buffer;
      }
    }
  });

  // node_modules/node-forge/lib/pbe.js
  var require_pbe = __commonJS({
    "node_modules/node-forge/lib/pbe.js"(exports, module) {
      var forge = require_forge();
      require_aes();
      require_asn1();
      require_des();
      require_md();
      require_oids();
      require_pbkdf2();
      require_pem();
      require_random();
      require_rc2();
      require_rsa();
      require_util4();
      if (typeof BigInteger === "undefined") {
        BigInteger = forge.jsbn.BigInteger;
      }
      var BigInteger;
      var asn1 = forge.asn1;
      var pki = forge.pki = forge.pki || {};
      module.exports = pki.pbe = forge.pbe = forge.pbe || {};
      var oids = pki.oids;
      var encryptedPrivateKeyValidator = {
        name: "EncryptedPrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encryptionOid"
          }, {
            name: "AlgorithmIdentifier.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "encryptionParams"
          }]
        }, {
          name: "EncryptedPrivateKeyInfo.encryptedData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encryptedData"
        }]
      };
      var PBES2AlgorithmsValidator = {
        name: "PBES2Algorithms",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.keyDerivationFunc.oid",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "kdfOid"
          }, {
            name: "PBES2Algorithms.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "PBES2Algorithms.params.salt",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "kdfSalt"
            }, {
              name: "PBES2Algorithms.params.iterationCount",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "kdfIterationCount"
            }, {
              name: "PBES2Algorithms.params.keyLength",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              optional: true,
              capture: "keyLength"
            }, {
              name: "PBES2Algorithms.params.prf",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              optional: true,
              value: [{
                name: "PBES2Algorithms.params.prf.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "prfOid"
              }]
            }]
          }]
        }, {
          name: "PBES2Algorithms.encryptionScheme",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.encryptionScheme.oid",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encOid"
          }, {
            name: "PBES2Algorithms.encryptionScheme.iv",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "encIv"
          }]
        }]
      };
      var pkcs12PbeParamsValidator = {
        name: "pkcs-12PbeParams",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "pkcs-12PbeParams.salt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "salt"
        }, {
          name: "pkcs-12PbeParams.iterations",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "iterations"
        }]
      };
      pki.encryptPrivateKeyInfo = function(obj, password, options) {
        options = options || {};
        options.saltSize = options.saltSize || 8;
        options.count = options.count || 2048;
        options.algorithm = options.algorithm || "aes128";
        options.prfAlgorithm = options.prfAlgorithm || "sha1";
        var salt = forge.random.getBytesSync(options.saltSize);
        var count = options.count;
        var countBytes = asn1.integerToDer(count);
        var dkLen;
        var encryptionAlgorithm;
        var encryptedData;
        if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
          var ivLen, encOid, cipherFn;
          switch (options.algorithm) {
            case "aes128":
              dkLen = 16;
              ivLen = 16;
              encOid = oids["aes128-CBC"];
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "aes192":
              dkLen = 24;
              ivLen = 16;
              encOid = oids["aes192-CBC"];
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "aes256":
              dkLen = 32;
              ivLen = 16;
              encOid = oids["aes256-CBC"];
              cipherFn = forge.aes.createEncryptionCipher;
              break;
            case "des":
              dkLen = 8;
              ivLen = 8;
              encOid = oids["desCBC"];
              cipherFn = forge.des.createEncryptionCipher;
              break;
            default:
              var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
              error.algorithm = options.algorithm;
              throw error;
          }
          var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
          var md = prfAlgorithmToMessageDigest(prfAlgorithm);
          var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
          var iv = forge.random.getBytesSync(ivLen);
          var cipher = cipherFn(dk);
          cipher.start(iv);
          cipher.update(asn1.toDer(obj));
          cipher.finish();
          encryptedData = cipher.output.getBytes();
          var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
          encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
                params
              ]),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
              ])
            ])
          ]);
        } else if (options.algorithm === "3des") {
          dkLen = 24;
          var saltBytes = new forge.util.ByteBuffer(salt);
          var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
          var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
          var cipher = forge.des.createEncryptionCipher(dk);
          cipher.start(iv);
          cipher.update(asn1.toDer(obj));
          cipher.finish();
          encryptedData = cipher.output.getBytes();
          encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
            ])
          ]);
        } else {
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          error.algorithm = options.algorithm;
          throw error;
        }
        var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          encryptionAlgorithm,
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
        ]);
        return rval;
      };
      pki.decryptPrivateKeyInfo = function(obj, password) {
        var rval = null;
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
          var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.encryptionOid);
        var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
        var encrypted = forge.util.createBuffer(capture.encryptedData);
        cipher.update(encrypted);
        if (cipher.finish()) {
          rval = asn1.fromDer(cipher.output);
        }
        return rval;
      };
      pki.encryptedPrivateKeyToPem = function(epki, maxline) {
        var msg = {
          type: "ENCRYPTED PRIVATE KEY",
          body: asn1.toDer(epki).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.encryptedPrivateKeyFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "ENCRYPTED PRIVATE KEY") {
          var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
        }
        return asn1.fromDer(msg.body);
      };
      pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
        options = options || {};
        if (!options.legacy) {
          var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
          rval = pki.encryptPrivateKeyInfo(rval, password, options);
          return pki.encryptedPrivateKeyToPem(rval);
        }
        var algorithm;
        var iv;
        var dkLen;
        var cipherFn;
        switch (options.algorithm) {
          case "aes128":
            algorithm = "AES-128-CBC";
            dkLen = 16;
            iv = forge.random.getBytesSync(16);
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            algorithm = "AES-192-CBC";
            dkLen = 24;
            iv = forge.random.getBytesSync(16);
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            algorithm = "AES-256-CBC";
            dkLen = 32;
            iv = forge.random.getBytesSync(16);
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "3des":
            algorithm = "DES-EDE3-CBC";
            dkLen = 24;
            iv = forge.random.getBytesSync(8);
            cipherFn = forge.des.createEncryptionCipher;
            break;
          case "des":
            algorithm = "DES-CBC";
            dkLen = 8;
            iv = forge.random.getBytesSync(8);
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
            error.algorithm = options.algorithm;
            throw error;
        }
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
        cipher.finish();
        var msg = {
          type: "RSA PRIVATE KEY",
          procType: {
            version: "4",
            type: "ENCRYPTED"
          },
          dekInfo: {
            algorithm,
            parameters: forge.util.bytesToHex(iv).toUpperCase()
          },
          body: cipher.output.getBytes()
        };
        return forge.pem.encode(msg);
      };
      pki.decryptRsaPrivateKey = function(pem, password) {
        var rval = null;
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
          var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
          error.headerType = error;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          var dkLen;
          var cipherFn;
          switch (msg.dekInfo.algorithm) {
            case "DES-CBC":
              dkLen = 8;
              cipherFn = forge.des.createDecryptionCipher;
              break;
            case "DES-EDE3-CBC":
              dkLen = 24;
              cipherFn = forge.des.createDecryptionCipher;
              break;
            case "AES-128-CBC":
              dkLen = 16;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "AES-192-CBC":
              dkLen = 24;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "AES-256-CBC":
              dkLen = 32;
              cipherFn = forge.aes.createDecryptionCipher;
              break;
            case "RC2-40-CBC":
              dkLen = 5;
              cipherFn = function(key) {
                return forge.rc2.createDecryptionCipher(key, 40);
              };
              break;
            case "RC2-64-CBC":
              dkLen = 8;
              cipherFn = function(key) {
                return forge.rc2.createDecryptionCipher(key, 64);
              };
              break;
            case "RC2-128-CBC":
              dkLen = 16;
              cipherFn = function(key) {
                return forge.rc2.createDecryptionCipher(key, 128);
              };
              break;
            default:
              var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
              error.algorithm = msg.dekInfo.algorithm;
              throw error;
          }
          var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
          var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
          var cipher = cipherFn(dk);
          cipher.start(iv);
          cipher.update(forge.util.createBuffer(msg.body));
          if (cipher.finish()) {
            rval = cipher.output.getBytes();
          } else {
            return rval;
          }
        } else {
          rval = msg.body;
        }
        if (msg.type === "ENCRYPTED PRIVATE KEY") {
          rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
        } else {
          rval = asn1.fromDer(rval);
        }
        if (rval !== null) {
          rval = pki.privateKeyFromAsn1(rval);
        }
        return rval;
      };
      pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
        var j, l;
        if (typeof md === "undefined" || md === null) {
          if (!("sha1" in forge.md)) {
            throw new Error('"sha1" hash algorithm unavailable.');
          }
          md = forge.md.sha1.create();
        }
        var u = md.digestLength;
        var v = md.blockLength;
        var result = new forge.util.ByteBuffer();
        var passBuf = new forge.util.ByteBuffer();
        if (password !== null && password !== void 0) {
          for (l = 0; l < password.length; l++) {
            passBuf.putInt16(password.charCodeAt(l));
          }
          passBuf.putInt16(0);
        }
        var p = passBuf.length();
        var s = salt.length();
        var D = new forge.util.ByteBuffer();
        D.fillWithByte(id, v);
        var Slen = v * Math.ceil(s / v);
        var S = new forge.util.ByteBuffer();
        for (l = 0; l < Slen; l++) {
          S.putByte(salt.at(l % s));
        }
        var Plen = v * Math.ceil(p / v);
        var P = new forge.util.ByteBuffer();
        for (l = 0; l < Plen; l++) {
          P.putByte(passBuf.at(l % p));
        }
        var I = S;
        I.putBuffer(P);
        var c = Math.ceil(n / u);
        for (var i = 1; i <= c; i++) {
          var buf = new forge.util.ByteBuffer();
          buf.putBytes(D.bytes());
          buf.putBytes(I.bytes());
          for (var round = 0; round < iter; round++) {
            md.start();
            md.update(buf.getBytes());
            buf = md.digest();
          }
          var B = new forge.util.ByteBuffer();
          for (l = 0; l < v; l++) {
            B.putByte(buf.at(l % u));
          }
          var k = Math.ceil(s / v) + Math.ceil(p / v);
          var Inew = new forge.util.ByteBuffer();
          for (j = 0; j < k; j++) {
            var chunk = new forge.util.ByteBuffer(I.getBytes(v));
            var x = 511;
            for (l = B.length() - 1; l >= 0; l--) {
              x = x >> 8;
              x += B.at(l) + chunk.at(l);
              chunk.setAt(l, x & 255);
            }
            Inew.putBuffer(chunk);
          }
          I = Inew;
          result.putBuffer(buf);
        }
        result.truncate(result.length() - n);
        return result;
      };
      pki.pbe.getCipher = function(oid, params, password) {
        switch (oid) {
          case pki.oids["pkcs5PBES2"]:
            return pki.pbe.getCipherForPBES2(oid, params, password);
          case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
            return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
          default:
            var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
            error.oid = oid;
            error.supportedOids = [
              "pkcs5PBES2",
              "pbeWithSHAAnd3-KeyTripleDES-CBC",
              "pbewithSHAAnd40BitRC2-CBC"
            ];
            throw error;
        }
      };
      pki.pbe.getCipherForPBES2 = function(oid, params, password) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
          var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          error.errors = errors;
          throw error;
        }
        oid = asn1.derToOid(capture.kdfOid);
        if (oid !== pki.oids["pkcs5PBKDF2"]) {
          var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
          error.oid = oid;
          error.supportedOids = ["pkcs5PBKDF2"];
          throw error;
        }
        oid = asn1.derToOid(capture.encOid);
        if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
          var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
          error.oid = oid;
          error.supportedOids = [
            "aes128-CBC",
            "aes192-CBC",
            "aes256-CBC",
            "des-EDE3-CBC",
            "desCBC"
          ];
          throw error;
        }
        var salt = capture.kdfSalt;
        var count = forge.util.createBuffer(capture.kdfIterationCount);
        count = count.getInt(count.length() << 3);
        var dkLen;
        var cipherFn;
        switch (pki.oids[oid]) {
          case "aes128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "aes192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "aes256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "des-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "desCBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
        }
        var md = prfOidToMessageDigest(capture.prfOid);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = capture.encIv;
        var cipher = cipherFn(dk);
        cipher.start(iv);
        return cipher;
      };
      pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
          var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
          error.errors = errors;
          throw error;
        }
        var salt = forge.util.createBuffer(capture.salt);
        var count = forge.util.createBuffer(capture.iterations);
        count = count.getInt(count.length() << 3);
        var dkLen, dIvLen, cipherFn;
        switch (oid) {
          case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
            dkLen = 24;
            dIvLen = 8;
            cipherFn = forge.des.startDecrypting;
            break;
          case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
            dkLen = 5;
            dIvLen = 8;
            cipherFn = function(key2, iv2) {
              var cipher = forge.rc2.createDecryptionCipher(key2, 40);
              cipher.start(iv2, null);
              return cipher;
            };
            break;
          default:
            var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
            error.oid = oid;
            throw error;
        }
        var md = prfOidToMessageDigest(capture.prfOid);
        var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
        md.start();
        var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
        return cipherFn(key, iv);
      };
      pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
        if (typeof md === "undefined" || md === null) {
          if (!("md5" in forge.md)) {
            throw new Error('"md5" hash algorithm unavailable.');
          }
          md = forge.md.md5.create();
        }
        if (salt === null) {
          salt = "";
        }
        var digests = [hash(md, password + salt)];
        for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
          digests.push(hash(md, digests[i - 1] + password + salt));
        }
        return digests.join("").substr(0, dkLen);
      };
      function hash(md, bytes) {
        return md.start().update(bytes).digest().getBytes();
      }
      function prfOidToMessageDigest(prfOid) {
        var prfAlgorithm;
        if (!prfOid) {
          prfAlgorithm = "hmacWithSHA1";
        } else {
          prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
          if (!prfAlgorithm) {
            var error = new Error("Unsupported PRF OID.");
            error.oid = prfOid;
            error.supported = [
              "hmacWithSHA1",
              "hmacWithSHA224",
              "hmacWithSHA256",
              "hmacWithSHA384",
              "hmacWithSHA512"
            ];
            throw error;
          }
        }
        return prfAlgorithmToMessageDigest(prfAlgorithm);
      }
      function prfAlgorithmToMessageDigest(prfAlgorithm) {
        var factory = forge.md;
        switch (prfAlgorithm) {
          case "hmacWithSHA224":
            factory = forge.md.sha512;
          case "hmacWithSHA1":
          case "hmacWithSHA256":
          case "hmacWithSHA384":
          case "hmacWithSHA512":
            prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
            break;
          default:
            var error = new Error("Unsupported PRF algorithm.");
            error.algorithm = prfAlgorithm;
            error.supported = [
              "hmacWithSHA1",
              "hmacWithSHA224",
              "hmacWithSHA256",
              "hmacWithSHA384",
              "hmacWithSHA512"
            ];
            throw error;
        }
        if (!factory || !(prfAlgorithm in factory)) {
          throw new Error("Unknown hash algorithm: " + prfAlgorithm);
        }
        return factory[prfAlgorithm].create();
      }
      function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
        var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
        ]);
        if (prfAlgorithm !== "hmacWithSHA1") {
          params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]));
        }
        return params;
      }
    }
  });

  // node_modules/node-forge/lib/pkcs7asn1.js
  var require_pkcs7asn1 = __commonJS({
    "node_modules/node-forge/lib/pkcs7asn1.js"(exports, module) {
      var forge = require_forge();
      require_asn1();
      require_util4();
      var asn1 = forge.asn1;
      var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
      forge.pkcs7 = forge.pkcs7 || {};
      forge.pkcs7.asn1 = p7v;
      var contentInfoValidator = {
        name: "ContentInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "ContentInfo.ContentType",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "contentType"
        }, {
          name: "ContentInfo.content",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          captureAsn1: "content"
        }]
      };
      p7v.contentInfoValidator = contentInfoValidator;
      var encryptedContentInfoValidator = {
        name: "EncryptedContentInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentType",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "contentType"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encAlgorithm"
          }, {
            name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
            tagClass: asn1.Class.UNIVERSAL,
            captureAsn1: "encParameter"
          }]
        }, {
          name: "EncryptedContentInfo.encryptedContent",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          capture: "encryptedContent",
          captureAsn1: "encryptedContentAsn1"
        }]
      };
      p7v.envelopedDataValidator = {
        name: "EnvelopedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EnvelopedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        }, {
          name: "EnvelopedData.RecipientInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "recipientInfos"
        }].concat(encryptedContentInfoValidator)
      };
      p7v.encryptedDataValidator = {
        name: "EncryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        }].concat(encryptedContentInfoValidator)
      };
      var signerValidator = {
        name: "SignerInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false
        }, {
          name: "SignerInfo.issuerAndSerialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.issuerAndSerialNumber.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "issuer"
          }, {
            name: "SignerInfo.issuerAndSerialNumber.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "serial"
          }]
        }, {
          name: "SignerInfo.digestAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "SignerInfo.digestAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "digestAlgorithm"
          }, {
            name: "SignerInfo.digestAlgorithm.parameter",
            tagClass: asn1.Class.UNIVERSAL,
            constructed: false,
            captureAsn1: "digestParameter",
            optional: true
          }]
        }, {
          name: "SignerInfo.authenticatedAttributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "authenticatedAttributes"
        }, {
          name: "SignerInfo.digestEncryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          capture: "signatureAlgorithm"
        }, {
          name: "SignerInfo.encryptedDigest",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "signature"
        }, {
          name: "SignerInfo.unauthenticatedAttributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          optional: true,
          capture: "unauthenticatedAttributes"
        }]
      };
      p7v.signedDataValidator = {
        name: "SignedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "SignedData.Version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "version"
          },
          {
            name: "SignedData.DigestAlgorithms",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true,
            captureAsn1: "digestAlgorithms"
          },
          contentInfoValidator,
          {
            name: "SignedData.Certificates",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            optional: true,
            captureAsn1: "certificates"
          },
          {
            name: "SignedData.CertificateRevocationLists",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            optional: true,
            captureAsn1: "crls"
          },
          {
            name: "SignedData.SignerInfos",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            capture: "signerInfos",
            optional: true,
            value: [signerValidator]
          }
        ]
      };
      p7v.recipientInfoValidator = {
        name: "RecipientInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        }, {
          name: "RecipientInfo.issuerAndSerial",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.issuerAndSerial.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "issuer"
          }, {
            name: "RecipientInfo.issuerAndSerial.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "serial"
          }]
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "encAlgorithm"
          }, {
            name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
            tagClass: asn1.Class.UNIVERSAL,
            constructed: false,
            captureAsn1: "encParameter"
          }]
        }, {
          name: "RecipientInfo.encryptedKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encKey"
        }]
      };
    }
  });

  // node_modules/node-forge/lib/mgf1.js
  var require_mgf1 = __commonJS({
    "node_modules/node-forge/lib/mgf1.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      forge.mgf = forge.mgf || {};
      var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
      mgf1.create = function(md) {
        var mgf = {
          generate: function(seed, maskLen) {
            var t = new forge.util.ByteBuffer();
            var len = Math.ceil(maskLen / md.digestLength);
            for (var i = 0; i < len; i++) {
              var c = new forge.util.ByteBuffer();
              c.putInt32(i);
              md.start();
              md.update(seed + c.getBytes());
              t.putBuffer(md.digest());
            }
            t.truncate(t.length() - maskLen);
            return t.getBytes();
          }
        };
        return mgf;
      };
    }
  });

  // node_modules/node-forge/lib/mgf.js
  var require_mgf = __commonJS({
    "node_modules/node-forge/lib/mgf.js"(exports, module) {
      var forge = require_forge();
      require_mgf1();
      module.exports = forge.mgf = forge.mgf || {};
      forge.mgf.mgf1 = forge.mgf1;
    }
  });

  // node_modules/node-forge/lib/pss.js
  var require_pss = __commonJS({
    "node_modules/node-forge/lib/pss.js"(exports, module) {
      var forge = require_forge();
      require_random();
      require_util4();
      var pss = module.exports = forge.pss = forge.pss || {};
      pss.create = function(options) {
        if (arguments.length === 3) {
          options = {
            md: arguments[0],
            mgf: arguments[1],
            saltLength: arguments[2]
          };
        }
        var hash = options.md;
        var mgf = options.mgf;
        var hLen = hash.digestLength;
        var salt_ = options.salt || null;
        if (typeof salt_ === "string") {
          salt_ = forge.util.createBuffer(salt_);
        }
        var sLen;
        if ("saltLength" in options) {
          sLen = options.saltLength;
        } else if (salt_ !== null) {
          sLen = salt_.length();
        } else {
          throw new Error("Salt length not specified or specific salt not given.");
        }
        if (salt_ !== null && salt_.length() !== sLen) {
          throw new Error("Given salt length does not match length of given salt.");
        }
        var prng = options.prng || forge.random;
        var pssobj = {};
        pssobj.encode = function(md, modBits) {
          var i;
          var emBits = modBits - 1;
          var emLen = Math.ceil(emBits / 8);
          var mHash = md.digest().getBytes();
          if (emLen < hLen + sLen + 2) {
            throw new Error("Message is too long to encrypt.");
          }
          var salt;
          if (salt_ === null) {
            salt = prng.getBytesSync(sLen);
          } else {
            salt = salt_.bytes();
          }
          var m_ = new forge.util.ByteBuffer();
          m_.fillWithByte(0, 8);
          m_.putBytes(mHash);
          m_.putBytes(salt);
          hash.start();
          hash.update(m_.getBytes());
          var h = hash.digest().getBytes();
          var ps = new forge.util.ByteBuffer();
          ps.fillWithByte(0, emLen - sLen - hLen - 2);
          ps.putByte(1);
          ps.putBytes(salt);
          var db = ps.getBytes();
          var maskLen = emLen - hLen - 1;
          var dbMask = mgf.generate(h, maskLen);
          var maskedDB = "";
          for (i = 0; i < maskLen; i++) {
            maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
          }
          var mask = 65280 >> 8 * emLen - emBits & 255;
          maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
          return maskedDB + h + String.fromCharCode(188);
        };
        pssobj.verify = function(mHash, em, modBits) {
          var i;
          var emBits = modBits - 1;
          var emLen = Math.ceil(emBits / 8);
          em = em.substr(-emLen);
          if (emLen < hLen + sLen + 2) {
            throw new Error("Inconsistent parameters to PSS signature verification.");
          }
          if (em.charCodeAt(emLen - 1) !== 188) {
            throw new Error("Encoded message does not end in 0xBC.");
          }
          var maskLen = emLen - hLen - 1;
          var maskedDB = em.substr(0, maskLen);
          var h = em.substr(maskLen, hLen);
          var mask = 65280 >> 8 * emLen - emBits & 255;
          if ((maskedDB.charCodeAt(0) & mask) !== 0) {
            throw new Error("Bits beyond keysize not zero as expected.");
          }
          var dbMask = mgf.generate(h, maskLen);
          var db = "";
          for (i = 0; i < maskLen; i++) {
            db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
          }
          db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
          var checkLen = emLen - hLen - sLen - 2;
          for (i = 0; i < checkLen; i++) {
            if (db.charCodeAt(i) !== 0) {
              throw new Error("Leftmost octets not zero as expected");
            }
          }
          if (db.charCodeAt(checkLen) !== 1) {
            throw new Error("Inconsistent PSS signature, 0x01 marker not found");
          }
          var salt = db.substr(-sLen);
          var m_ = new forge.util.ByteBuffer();
          m_.fillWithByte(0, 8);
          m_.putBytes(mHash);
          m_.putBytes(salt);
          hash.start();
          hash.update(m_.getBytes());
          var h_ = hash.digest().getBytes();
          return h === h_;
        };
        return pssobj;
      };
    }
  });

  // node_modules/node-forge/lib/x509.js
  var require_x509 = __commonJS({
    "node_modules/node-forge/lib/x509.js"(exports, module) {
      var forge = require_forge();
      require_aes();
      require_asn1();
      require_des();
      require_md();
      require_mgf();
      require_oids();
      require_pem();
      require_pss();
      require_rsa();
      require_util4();
      var asn1 = forge.asn1;
      var pki = module.exports = forge.pki = forge.pki || {};
      var oids = pki.oids;
      var _shortNames = {};
      _shortNames["CN"] = oids["commonName"];
      _shortNames["commonName"] = "CN";
      _shortNames["C"] = oids["countryName"];
      _shortNames["countryName"] = "C";
      _shortNames["L"] = oids["localityName"];
      _shortNames["localityName"] = "L";
      _shortNames["ST"] = oids["stateOrProvinceName"];
      _shortNames["stateOrProvinceName"] = "ST";
      _shortNames["O"] = oids["organizationName"];
      _shortNames["organizationName"] = "O";
      _shortNames["OU"] = oids["organizationalUnitName"];
      _shortNames["organizationalUnitName"] = "OU";
      _shortNames["E"] = oids["emailAddress"];
      _shortNames["emailAddress"] = "E";
      var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
      var x509CertificateValidator = {
        name: "Certificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.TBSCertificate",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "tbsCertificate",
          value: [
            {
              name: "Certificate.TBSCertificate.version",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 0,
              constructed: true,
              optional: true,
              value: [{
                name: "Certificate.TBSCertificate.version.integer",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.INTEGER,
                constructed: false,
                capture: "certVersion"
              }]
            },
            {
              name: "Certificate.TBSCertificate.serialNumber",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certSerialNumber"
            },
            {
              name: "Certificate.TBSCertificate.signature",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "Certificate.TBSCertificate.signature.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "certinfoSignatureOid"
              }, {
                name: "Certificate.TBSCertificate.signature.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                optional: true,
                captureAsn1: "certinfoSignatureParams"
              }]
            },
            {
              name: "Certificate.TBSCertificate.issuer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certIssuer"
            },
            {
              name: "Certificate.TBSCertificate.validity",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "Certificate.TBSCertificate.validity.notBefore (utc)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.UTCTIME,
                constructed: false,
                optional: true,
                capture: "certValidity1UTCTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.GENERALIZEDTIME,
                constructed: false,
                optional: true,
                capture: "certValidity2GeneralizedTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notAfter (utc)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.UTCTIME,
                constructed: false,
                optional: true,
                capture: "certValidity3UTCTime"
              }, {
                name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.GENERALIZEDTIME,
                constructed: false,
                optional: true,
                capture: "certValidity4GeneralizedTime"
              }]
            },
            {
              name: "Certificate.TBSCertificate.subject",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              captureAsn1: "certSubject"
            },
            publicKeyValidator,
            {
              name: "Certificate.TBSCertificate.issuerUniqueID",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 1,
              constructed: true,
              optional: true,
              value: [{
                name: "Certificate.TBSCertificate.issuerUniqueID.id",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.BITSTRING,
                constructed: false,
                captureBitStringValue: "certIssuerUniqueId"
              }]
            },
            {
              name: "Certificate.TBSCertificate.subjectUniqueID",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 2,
              constructed: true,
              optional: true,
              value: [{
                name: "Certificate.TBSCertificate.subjectUniqueID.id",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.BITSTRING,
                constructed: false,
                captureBitStringValue: "certSubjectUniqueId"
              }]
            },
            {
              name: "Certificate.TBSCertificate.extensions",
              tagClass: asn1.Class.CONTEXT_SPECIFIC,
              type: 3,
              constructed: true,
              captureAsn1: "certExtensions",
              optional: true
            }
          ]
        }, {
          name: "Certificate.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "certSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "certSignatureParams"
          }]
        }, {
          name: "Certificate.signatureValue",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "certSignature"
        }]
      };
      var rsassaPssParameterValidator = {
        name: "rsapss",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "hashOid"
            }]
          }]
        }, {
          name: "rsapss.maskGenAlgorithm",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenOid"
            }, {
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "maskGenHashOid"
              }]
            }]
          }]
        }, {
          name: "rsapss.saltLength",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          optional: true,
          value: [{
            name: "rsapss.saltLength.saltLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.INTEGER,
            constructed: false,
            capture: "saltLength"
          }]
        }, {
          name: "rsapss.trailerField",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          optional: true,
          value: [{
            name: "rsapss.trailer.trailer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.INTEGER,
            constructed: false,
            capture: "trailer"
          }]
        }]
      };
      var certificationRequestInfoValidator = {
        name: "CertificationRequestInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certificationRequestInfo",
        value: [
          {
            name: "CertificationRequestInfo.integer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certificationRequestInfoVersion"
          },
          {
            name: "CertificationRequestInfo.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certificationRequestInfoSubject"
          },
          publicKeyValidator,
          {
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            capture: "certificationRequestInfoAttributes",
            value: [{
              name: "CertificationRequestInfo.attributes",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "CertificationRequestInfo.attributes.type",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false
              }, {
                name: "CertificationRequestInfo.attributes.value",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SET,
                constructed: true
              }]
            }]
          }
        ]
      };
      var certificationRequestValidator = {
        name: "CertificationRequest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "csr",
        value: [
          certificationRequestInfoValidator,
          {
            name: "CertificationRequest.signatureAlgorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequest.signatureAlgorithm.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "csrSignatureOid"
            }, {
              name: "CertificationRequest.signatureAlgorithm.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "csrSignatureParams"
            }]
          },
          {
            name: "CertificationRequest.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "csrSignature"
          }
        ]
      };
      pki.RDNAttributesAsArray = function(rdn, md) {
        var rval = [];
        var set, attr, obj;
        for (var si = 0; si < rdn.value.length; ++si) {
          set = rdn.value[si];
          for (var i = 0; i < set.value.length; ++i) {
            obj = {};
            attr = set.value[i];
            obj.type = asn1.derToOid(attr.value[0].value);
            obj.value = attr.value[1].value;
            obj.valueTagClass = attr.value[1].type;
            if (obj.type in oids) {
              obj.name = oids[obj.type];
              if (obj.name in _shortNames) {
                obj.shortName = _shortNames[obj.name];
              }
            }
            if (md) {
              md.update(obj.type);
              md.update(obj.value);
            }
            rval.push(obj);
          }
        }
        return rval;
      };
      pki.CRIAttributesAsArray = function(attributes) {
        var rval = [];
        for (var si = 0; si < attributes.length; ++si) {
          var seq = attributes[si];
          var type = asn1.derToOid(seq.value[0].value);
          var values = seq.value[1].value;
          for (var vi = 0; vi < values.length; ++vi) {
            var obj = {};
            obj.type = type;
            obj.value = values[vi].value;
            obj.valueTagClass = values[vi].type;
            if (obj.type in oids) {
              obj.name = oids[obj.type];
              if (obj.name in _shortNames) {
                obj.shortName = _shortNames[obj.name];
              }
            }
            if (obj.type === oids.extensionRequest) {
              obj.extensions = [];
              for (var ei = 0; ei < obj.value.length; ++ei) {
                obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
              }
            }
            rval.push(obj);
          }
        }
        return rval;
      };
      function _getAttribute(obj, options) {
        if (typeof options === "string") {
          options = { shortName: options };
        }
        var rval = null;
        var attr;
        for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
          attr = obj.attributes[i];
          if (options.type && options.type === attr.type) {
            rval = attr;
          } else if (options.name && options.name === attr.name) {
            rval = attr;
          } else if (options.shortName && options.shortName === attr.shortName) {
            rval = attr;
          }
        }
        return rval;
      }
      var _readSignatureParameters = function(oid, obj, fillDefaults) {
        var params = {};
        if (oid !== oids["RSASSA-PSS"]) {
          return params;
        }
        if (fillDefaults) {
          params = {
            hash: {
              algorithmOid: oids["sha1"]
            },
            mgf: {
              algorithmOid: oids["mgf1"],
              hash: {
                algorithmOid: oids["sha1"]
              }
            },
            saltLength: 20
          };
        }
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
          var error = new Error("Cannot read RSASSA-PSS parameter block.");
          error.errors = errors;
          throw error;
        }
        if (capture.hashOid !== void 0) {
          params.hash = params.hash || {};
          params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
        }
        if (capture.maskGenOid !== void 0) {
          params.mgf = params.mgf || {};
          params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
          params.mgf.hash = params.mgf.hash || {};
          params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
        }
        if (capture.saltLength !== void 0) {
          params.saltLength = capture.saltLength.charCodeAt(0);
        }
        return params;
      };
      pki.certificateFromPem = function(pem, computeHash, strict) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
          var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body, strict);
        return pki.certificateFromAsn1(obj, computeHash);
      };
      pki.certificateToPem = function(cert, maxline) {
        var msg = {
          type: "CERTIFICATE",
          body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.publicKeyFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
          var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert public key from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body);
        return pki.publicKeyFromAsn1(obj);
      };
      pki.publicKeyToPem = function(key, maxline) {
        var msg = {
          type: "PUBLIC KEY",
          body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
        var msg = {
          type: "RSA PUBLIC KEY",
          body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.getPublicKeyFingerprint = function(key, options) {
        options = options || {};
        var md = options.md || forge.md.sha1.create();
        var type = options.type || "RSAPublicKey";
        var bytes;
        switch (type) {
          case "RSAPublicKey":
            bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
            break;
          case "SubjectPublicKeyInfo":
            bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
            break;
          default:
            throw new Error('Unknown fingerprint type "' + options.type + '".');
        }
        md.start();
        md.update(bytes);
        var digest = md.digest();
        if (options.encoding === "hex") {
          var hex = digest.toHex();
          if (options.delimiter) {
            return hex.match(/.{2}/g).join(options.delimiter);
          }
          return hex;
        } else if (options.encoding === "binary") {
          return digest.getBytes();
        } else if (options.encoding) {
          throw new Error('Unknown encoding "' + options.encoding + '".');
        }
        return digest;
      };
      pki.certificationRequestFromPem = function(pem, computeHash, strict) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "CERTIFICATE REQUEST") {
          var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body, strict);
        return pki.certificationRequestFromAsn1(obj, computeHash);
      };
      pki.certificationRequestToPem = function(csr, maxline) {
        var msg = {
          type: "CERTIFICATE REQUEST",
          body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.createCertificate = function() {
        var cert = {};
        cert.version = 2;
        cert.serialNumber = "00";
        cert.signatureOid = null;
        cert.signature = null;
        cert.siginfo = {};
        cert.siginfo.algorithmOid = null;
        cert.validity = {};
        cert.validity.notBefore = new Date();
        cert.validity.notAfter = new Date();
        cert.issuer = {};
        cert.issuer.getField = function(sn) {
          return _getAttribute(cert.issuer, sn);
        };
        cert.issuer.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.issuer.attributes.push(attr);
        };
        cert.issuer.attributes = [];
        cert.issuer.hash = null;
        cert.subject = {};
        cert.subject.getField = function(sn) {
          return _getAttribute(cert.subject, sn);
        };
        cert.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.subject.attributes.push(attr);
        };
        cert.subject.attributes = [];
        cert.subject.hash = null;
        cert.extensions = [];
        cert.publicKey = null;
        cert.md = null;
        cert.setSubject = function(attrs, uniqueId) {
          _fillMissingFields(attrs);
          cert.subject.attributes = attrs;
          delete cert.subject.uniqueId;
          if (uniqueId) {
            cert.subject.uniqueId = uniqueId;
          }
          cert.subject.hash = null;
        };
        cert.setIssuer = function(attrs, uniqueId) {
          _fillMissingFields(attrs);
          cert.issuer.attributes = attrs;
          delete cert.issuer.uniqueId;
          if (uniqueId) {
            cert.issuer.uniqueId = uniqueId;
          }
          cert.issuer.hash = null;
        };
        cert.setExtensions = function(exts) {
          for (var i = 0; i < exts.length; ++i) {
            _fillMissingExtensionFields(exts[i], { cert });
          }
          cert.extensions = exts;
        };
        cert.getExtension = function(options) {
          if (typeof options === "string") {
            options = { name: options };
          }
          var rval = null;
          var ext;
          for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
            ext = cert.extensions[i];
            if (options.id && ext.id === options.id) {
              rval = ext;
            } else if (options.name && ext.name === options.name) {
              rval = ext;
            }
          }
          return rval;
        };
        cert.sign = function(key, md) {
          cert.md = md || forge.md.sha1.create();
          var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
          if (!algorithmOid) {
            var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
            error.algorithm = cert.md.algorithm;
            throw error;
          }
          cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
          cert.tbsCertificate = pki.getTBSCertificate(cert);
          var bytes = asn1.toDer(cert.tbsCertificate);
          cert.md.update(bytes.getBytes());
          cert.signature = key.sign(cert.md);
        };
        cert.verify = function(child) {
          var rval = false;
          if (!cert.issued(child)) {
            var issuer = child.issuer;
            var subject = cert.subject;
            var error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
            error.expectedIssuer = issuer.attributes;
            error.actualIssuer = subject.attributes;
            throw error;
          }
          var md = child.md;
          if (md === null) {
            if (child.signatureOid in oids) {
              var oid = oids[child.signatureOid];
              switch (oid) {
                case "sha1WithRSAEncryption":
                  md = forge.md.sha1.create();
                  break;
                case "md5WithRSAEncryption":
                  md = forge.md.md5.create();
                  break;
                case "sha256WithRSAEncryption":
                  md = forge.md.sha256.create();
                  break;
                case "sha384WithRSAEncryption":
                  md = forge.md.sha384.create();
                  break;
                case "sha512WithRSAEncryption":
                  md = forge.md.sha512.create();
                  break;
                case "RSASSA-PSS":
                  md = forge.md.sha256.create();
                  break;
              }
            }
            if (md === null) {
              var error = new Error("Could not compute certificate digest. Unknown signature OID.");
              error.signatureOid = child.signatureOid;
              throw error;
            }
            var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
            var bytes = asn1.toDer(tbsCertificate);
            md.update(bytes.getBytes());
          }
          if (md !== null) {
            var scheme;
            switch (child.signatureOid) {
              case oids.sha1WithRSAEncryption:
                scheme = void 0;
                break;
              case oids["RSASSA-PSS"]:
                var hash, mgf;
                hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  var error = new Error("Unsupported MGF hash function.");
                  error.oid = child.signatureParameters.mgf.hash.algorithmOid;
                  error.name = hash;
                  throw error;
                }
                mgf = oids[child.signatureParameters.mgf.algorithmOid];
                if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                  var error = new Error("Unsupported MGF function.");
                  error.oid = child.signatureParameters.mgf.algorithmOid;
                  error.name = mgf;
                  throw error;
                }
                mgf = forge.mgf[mgf].create(forge.md[hash].create());
                hash = oids[child.signatureParameters.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  throw {
                    message: "Unsupported RSASSA-PSS hash function.",
                    oid: child.signatureParameters.hash.algorithmOid,
                    name: hash
                  };
                }
                scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
                break;
            }
            rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
          }
          return rval;
        };
        cert.isIssuer = function(parent) {
          var rval = false;
          var i = cert.issuer;
          var s = parent.subject;
          if (i.hash && s.hash) {
            rval = i.hash === s.hash;
          } else if (i.attributes.length === s.attributes.length) {
            rval = true;
            var iattr, sattr;
            for (var n = 0; rval && n < i.attributes.length; ++n) {
              iattr = i.attributes[n];
              sattr = s.attributes[n];
              if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
                rval = false;
              }
            }
          }
          return rval;
        };
        cert.issued = function(child) {
          return child.isIssuer(cert);
        };
        cert.generateSubjectKeyIdentifier = function() {
          return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
        };
        cert.verifySubjectKeyIdentifier = function() {
          var oid = oids["subjectKeyIdentifier"];
          for (var i = 0; i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.id === oid) {
              var ski = cert.generateSubjectKeyIdentifier().getBytes();
              return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
            }
          }
          return false;
        };
        return cert;
      };
      pki.certificateFromAsn1 = function(obj, computeHash) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
          var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          throw new Error("Cannot read public key. OID is not RSA.");
        }
        var cert = pki.createCertificate();
        cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
        var serial = forge.util.createBuffer(capture.certSerialNumber);
        cert.serialNumber = serial.toHex();
        cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
        cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
        cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
        cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
        cert.signature = capture.certSignature;
        var validity = [];
        if (capture.certValidity1UTCTime !== void 0) {
          validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
        }
        if (capture.certValidity2GeneralizedTime !== void 0) {
          validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
        }
        if (capture.certValidity3UTCTime !== void 0) {
          validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
        }
        if (capture.certValidity4GeneralizedTime !== void 0) {
          validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
        }
        if (validity.length > 2) {
          throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
        }
        if (validity.length < 2) {
          throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
        }
        cert.validity.notBefore = validity[0];
        cert.validity.notAfter = validity[1];
        cert.tbsCertificate = capture.tbsCertificate;
        if (computeHash) {
          cert.md = null;
          if (cert.signatureOid in oids) {
            var oid = oids[cert.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                cert.md = forge.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                cert.md = forge.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                cert.md = forge.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                cert.md = forge.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                cert.md = forge.md.sha512.create();
                break;
              case "RSASSA-PSS":
                cert.md = forge.md.sha256.create();
                break;
            }
          }
          if (cert.md === null) {
            var error = new Error("Could not compute certificate digest. Unknown signature OID.");
            error.signatureOid = cert.signatureOid;
            throw error;
          }
          var bytes = asn1.toDer(cert.tbsCertificate);
          cert.md.update(bytes.getBytes());
        }
        var imd = forge.md.sha1.create();
        cert.issuer.getField = function(sn) {
          return _getAttribute(cert.issuer, sn);
        };
        cert.issuer.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.issuer.attributes.push(attr);
        };
        cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
        if (capture.certIssuerUniqueId) {
          cert.issuer.uniqueId = capture.certIssuerUniqueId;
        }
        cert.issuer.hash = imd.digest().toHex();
        var smd = forge.md.sha1.create();
        cert.subject.getField = function(sn) {
          return _getAttribute(cert.subject, sn);
        };
        cert.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          cert.subject.attributes.push(attr);
        };
        cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
        if (capture.certSubjectUniqueId) {
          cert.subject.uniqueId = capture.certSubjectUniqueId;
        }
        cert.subject.hash = smd.digest().toHex();
        if (capture.certExtensions) {
          cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
        } else {
          cert.extensions = [];
        }
        cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
        return cert;
      };
      pki.certificateExtensionsFromAsn1 = function(exts) {
        var rval = [];
        for (var i = 0; i < exts.value.length; ++i) {
          var extseq = exts.value[i];
          for (var ei = 0; ei < extseq.value.length; ++ei) {
            rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
          }
        }
        return rval;
      };
      pki.certificateExtensionFromAsn1 = function(ext) {
        var e = {};
        e.id = asn1.derToOid(ext.value[0].value);
        e.critical = false;
        if (ext.value[1].type === asn1.Type.BOOLEAN) {
          e.critical = ext.value[1].value.charCodeAt(0) !== 0;
          e.value = ext.value[2].value;
        } else {
          e.value = ext.value[1].value;
        }
        if (e.id in oids) {
          e.name = oids[e.id];
          if (e.name === "keyUsage") {
            var ev = asn1.fromDer(e.value);
            var b2 = 0;
            var b3 = 0;
            if (ev.value.length > 1) {
              b2 = ev.value.charCodeAt(1);
              b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
            }
            e.digitalSignature = (b2 & 128) === 128;
            e.nonRepudiation = (b2 & 64) === 64;
            e.keyEncipherment = (b2 & 32) === 32;
            e.dataEncipherment = (b2 & 16) === 16;
            e.keyAgreement = (b2 & 8) === 8;
            e.keyCertSign = (b2 & 4) === 4;
            e.cRLSign = (b2 & 2) === 2;
            e.encipherOnly = (b2 & 1) === 1;
            e.decipherOnly = (b3 & 128) === 128;
          } else if (e.name === "basicConstraints") {
            var ev = asn1.fromDer(e.value);
            if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
              e.cA = ev.value[0].value.charCodeAt(0) !== 0;
            } else {
              e.cA = false;
            }
            var value = null;
            if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
              value = ev.value[0].value;
            } else if (ev.value.length > 1) {
              value = ev.value[1].value;
            }
            if (value !== null) {
              e.pathLenConstraint = asn1.derToInteger(value);
            }
          } else if (e.name === "extKeyUsage") {
            var ev = asn1.fromDer(e.value);
            for (var vi = 0; vi < ev.value.length; ++vi) {
              var oid = asn1.derToOid(ev.value[vi].value);
              if (oid in oids) {
                e[oids[oid]] = true;
              } else {
                e[oid] = true;
              }
            }
          } else if (e.name === "nsCertType") {
            var ev = asn1.fromDer(e.value);
            var b2 = 0;
            if (ev.value.length > 1) {
              b2 = ev.value.charCodeAt(1);
            }
            e.client = (b2 & 128) === 128;
            e.server = (b2 & 64) === 64;
            e.email = (b2 & 32) === 32;
            e.objsign = (b2 & 16) === 16;
            e.reserved = (b2 & 8) === 8;
            e.sslCA = (b2 & 4) === 4;
            e.emailCA = (b2 & 2) === 2;
            e.objCA = (b2 & 1) === 1;
          } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
            e.altNames = [];
            var gn;
            var ev = asn1.fromDer(e.value);
            for (var n = 0; n < ev.value.length; ++n) {
              gn = ev.value[n];
              var altName = {
                type: gn.type,
                value: gn.value
              };
              e.altNames.push(altName);
              switch (gn.type) {
                case 1:
                case 2:
                case 6:
                  break;
                case 7:
                  altName.ip = forge.util.bytesToIP(gn.value);
                  break;
                case 8:
                  altName.oid = asn1.derToOid(gn.value);
                  break;
                default:
              }
            }
          } else if (e.name === "subjectKeyIdentifier") {
            var ev = asn1.fromDer(e.value);
            e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
          }
        }
        return e;
      };
      pki.certificationRequestFromAsn1 = function(obj, computeHash) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          throw new Error("Cannot read public key. OID is not RSA.");
        }
        var csr = pki.createCertificationRequest();
        csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
        csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
        csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
        csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
        csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
        csr.signature = capture.csrSignature;
        csr.certificationRequestInfo = capture.certificationRequestInfo;
        if (computeHash) {
          csr.md = null;
          if (csr.signatureOid in oids) {
            var oid = oids[csr.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                csr.md = forge.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                csr.md = forge.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                csr.md = forge.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                csr.md = forge.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                csr.md = forge.md.sha512.create();
                break;
              case "RSASSA-PSS":
                csr.md = forge.md.sha256.create();
                break;
            }
          }
          if (csr.md === null) {
            var error = new Error("Could not compute certification request digest. Unknown signature OID.");
            error.signatureOid = csr.signatureOid;
            throw error;
          }
          var bytes = asn1.toDer(csr.certificationRequestInfo);
          csr.md.update(bytes.getBytes());
        }
        var smd = forge.md.sha1.create();
        csr.subject.getField = function(sn) {
          return _getAttribute(csr.subject, sn);
        };
        csr.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          csr.subject.attributes.push(attr);
        };
        csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
        csr.subject.hash = smd.digest().toHex();
        csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
        csr.getAttribute = function(sn) {
          return _getAttribute(csr, sn);
        };
        csr.addAttribute = function(attr) {
          _fillMissingFields([attr]);
          csr.attributes.push(attr);
        };
        csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
        return csr;
      };
      pki.createCertificationRequest = function() {
        var csr = {};
        csr.version = 0;
        csr.signatureOid = null;
        csr.signature = null;
        csr.siginfo = {};
        csr.siginfo.algorithmOid = null;
        csr.subject = {};
        csr.subject.getField = function(sn) {
          return _getAttribute(csr.subject, sn);
        };
        csr.subject.addField = function(attr) {
          _fillMissingFields([attr]);
          csr.subject.attributes.push(attr);
        };
        csr.subject.attributes = [];
        csr.subject.hash = null;
        csr.publicKey = null;
        csr.attributes = [];
        csr.getAttribute = function(sn) {
          return _getAttribute(csr, sn);
        };
        csr.addAttribute = function(attr) {
          _fillMissingFields([attr]);
          csr.attributes.push(attr);
        };
        csr.md = null;
        csr.setSubject = function(attrs) {
          _fillMissingFields(attrs);
          csr.subject.attributes = attrs;
          csr.subject.hash = null;
        };
        csr.setAttributes = function(attrs) {
          _fillMissingFields(attrs);
          csr.attributes = attrs;
        };
        csr.sign = function(key, md) {
          csr.md = md || forge.md.sha1.create();
          var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
          if (!algorithmOid) {
            var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
            error.algorithm = csr.md.algorithm;
            throw error;
          }
          csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
          csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(csr.certificationRequestInfo);
          csr.md.update(bytes.getBytes());
          csr.signature = key.sign(csr.md);
        };
        csr.verify = function() {
          var rval = false;
          var md = csr.md;
          if (md === null) {
            if (csr.signatureOid in oids) {
              var oid = oids[csr.signatureOid];
              switch (oid) {
                case "sha1WithRSAEncryption":
                  md = forge.md.sha1.create();
                  break;
                case "md5WithRSAEncryption":
                  md = forge.md.md5.create();
                  break;
                case "sha256WithRSAEncryption":
                  md = forge.md.sha256.create();
                  break;
                case "sha384WithRSAEncryption":
                  md = forge.md.sha384.create();
                  break;
                case "sha512WithRSAEncryption":
                  md = forge.md.sha512.create();
                  break;
                case "RSASSA-PSS":
                  md = forge.md.sha256.create();
                  break;
              }
            }
            if (md === null) {
              var error = new Error("Could not compute certification request digest. Unknown signature OID.");
              error.signatureOid = csr.signatureOid;
              throw error;
            }
            var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
            var bytes = asn1.toDer(cri);
            md.update(bytes.getBytes());
          }
          if (md !== null) {
            var scheme;
            switch (csr.signatureOid) {
              case oids.sha1WithRSAEncryption:
                break;
              case oids["RSASSA-PSS"]:
                var hash, mgf;
                hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  var error = new Error("Unsupported MGF hash function.");
                  error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
                  error.name = hash;
                  throw error;
                }
                mgf = oids[csr.signatureParameters.mgf.algorithmOid];
                if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                  var error = new Error("Unsupported MGF function.");
                  error.oid = csr.signatureParameters.mgf.algorithmOid;
                  error.name = mgf;
                  throw error;
                }
                mgf = forge.mgf[mgf].create(forge.md[hash].create());
                hash = oids[csr.signatureParameters.hash.algorithmOid];
                if (hash === void 0 || forge.md[hash] === void 0) {
                  var error = new Error("Unsupported RSASSA-PSS hash function.");
                  error.oid = csr.signatureParameters.hash.algorithmOid;
                  error.name = hash;
                  throw error;
                }
                scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
                break;
            }
            rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
          }
          return rval;
        };
        return csr;
      };
      function _dnToAsn1(obj) {
        var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var attr, set;
        var attrs = obj.attributes;
        for (var i = 0; i < attrs.length; ++i) {
          attr = attrs[i];
          var value = attr.value;
          var valueTagClass = asn1.Type.PRINTABLESTRING;
          if ("valueTagClass" in attr) {
            valueTagClass = attr.valueTagClass;
            if (valueTagClass === asn1.Type.UTF8) {
              value = forge.util.encodeUtf8(value);
            }
          }
          set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
            ])
          ]);
          rval.value.push(set);
        }
        return rval;
      }
      function _fillMissingFields(attrs) {
        var attr;
        for (var i = 0; i < attrs.length; ++i) {
          attr = attrs[i];
          if (typeof attr.name === "undefined") {
            if (attr.type && attr.type in pki.oids) {
              attr.name = pki.oids[attr.type];
            } else if (attr.shortName && attr.shortName in _shortNames) {
              attr.name = pki.oids[_shortNames[attr.shortName]];
            }
          }
          if (typeof attr.type === "undefined") {
            if (attr.name && attr.name in pki.oids) {
              attr.type = pki.oids[attr.name];
            } else {
              var error = new Error("Attribute type not specified.");
              error.attribute = attr;
              throw error;
            }
          }
          if (typeof attr.shortName === "undefined") {
            if (attr.name && attr.name in _shortNames) {
              attr.shortName = _shortNames[attr.name];
            }
          }
          if (attr.type === oids.extensionRequest) {
            attr.valueConstructed = true;
            attr.valueTagClass = asn1.Type.SEQUENCE;
            if (!attr.value && attr.extensions) {
              attr.value = [];
              for (var ei = 0; ei < attr.extensions.length; ++ei) {
                attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
              }
            }
          }
          if (typeof attr.value === "undefined") {
            var error = new Error("Attribute value not specified.");
            error.attribute = attr;
            throw error;
          }
        }
      }
      function _fillMissingExtensionFields(e, options) {
        options = options || {};
        if (typeof e.name === "undefined") {
          if (e.id && e.id in pki.oids) {
            e.name = pki.oids[e.id];
          }
        }
        if (typeof e.id === "undefined") {
          if (e.name && e.name in pki.oids) {
            e.id = pki.oids[e.name];
          } else {
            var error = new Error("Extension ID not specified.");
            error.extension = e;
            throw error;
          }
        }
        if (typeof e.value !== "undefined") {
          return e;
        }
        if (e.name === "keyUsage") {
          var unused = 0;
          var b2 = 0;
          var b3 = 0;
          if (e.digitalSignature) {
            b2 |= 128;
            unused = 7;
          }
          if (e.nonRepudiation) {
            b2 |= 64;
            unused = 6;
          }
          if (e.keyEncipherment) {
            b2 |= 32;
            unused = 5;
          }
          if (e.dataEncipherment) {
            b2 |= 16;
            unused = 4;
          }
          if (e.keyAgreement) {
            b2 |= 8;
            unused = 3;
          }
          if (e.keyCertSign) {
            b2 |= 4;
            unused = 2;
          }
          if (e.cRLSign) {
            b2 |= 2;
            unused = 1;
          }
          if (e.encipherOnly) {
            b2 |= 1;
            unused = 0;
          }
          if (e.decipherOnly) {
            b3 |= 128;
            unused = 7;
          }
          var value = String.fromCharCode(unused);
          if (b3 !== 0) {
            value += String.fromCharCode(b2) + String.fromCharCode(b3);
          } else if (b2 !== 0) {
            value += String.fromCharCode(b2);
          }
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
        } else if (e.name === "basicConstraints") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          if (e.cA) {
            e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
          }
          if ("pathLenConstraint" in e) {
            e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
          }
        } else if (e.name === "extKeyUsage") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var seq = e.value.value;
          for (var key in e) {
            if (e[key] !== true) {
              continue;
            }
            if (key in oids) {
              seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
            } else if (key.indexOf(".") !== -1) {
              seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
            }
          }
        } else if (e.name === "nsCertType") {
          var unused = 0;
          var b2 = 0;
          if (e.client) {
            b2 |= 128;
            unused = 7;
          }
          if (e.server) {
            b2 |= 64;
            unused = 6;
          }
          if (e.email) {
            b2 |= 32;
            unused = 5;
          }
          if (e.objsign) {
            b2 |= 16;
            unused = 4;
          }
          if (e.reserved) {
            b2 |= 8;
            unused = 3;
          }
          if (e.sslCA) {
            b2 |= 4;
            unused = 2;
          }
          if (e.emailCA) {
            b2 |= 2;
            unused = 1;
          }
          if (e.objCA) {
            b2 |= 1;
            unused = 0;
          }
          var value = String.fromCharCode(unused);
          if (b2 !== 0) {
            value += String.fromCharCode(b2);
          }
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var altName;
          for (var n = 0; n < e.altNames.length; ++n) {
            altName = e.altNames[n];
            var value = altName.value;
            if (altName.type === 7 && altName.ip) {
              value = forge.util.bytesFromIP(altName.ip);
              if (value === null) {
                var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                error.extension = e;
                throw error;
              }
            } else if (altName.type === 8) {
              if (altName.oid) {
                value = asn1.oidToDer(asn1.oidToDer(altName.oid));
              } else {
                value = asn1.oidToDer(value);
              }
            }
            e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
          }
        } else if (e.name === "nsComment" && options.cert) {
          if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
            throw new Error('Invalid "nsComment" content.');
          }
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
        } else if (e.name === "subjectKeyIdentifier" && options.cert) {
          var ski = options.cert.generateSubjectKeyIdentifier();
          e.subjectKeyIdentifier = ski.toHex();
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
        } else if (e.name === "authorityKeyIdentifier" && options.cert) {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var seq = e.value.value;
          if (e.keyIdentifier) {
            var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
          }
          if (e.authorityCertIssuer) {
            var authorityCertIssuer = [
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
                _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
              ])
            ];
            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
          }
          if (e.serialNumber) {
            var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
            seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
          }
        } else if (e.name === "cRLDistributionPoints") {
          e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var seq = e.value.value;
          var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
          var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
          var altName;
          for (var n = 0; n < e.altNames.length; ++n) {
            altName = e.altNames[n];
            var value = altName.value;
            if (altName.type === 7 && altName.ip) {
              value = forge.util.bytesFromIP(altName.ip);
              if (value === null) {
                var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
                error.extension = e;
                throw error;
              }
            } else if (altName.type === 8) {
              if (altName.oid) {
                value = asn1.oidToDer(asn1.oidToDer(altName.oid));
              } else {
                value = asn1.oidToDer(value);
              }
            }
            fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
          }
          subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
          seq.push(subSeq);
        }
        if (typeof e.value === "undefined") {
          var error = new Error("Extension value not specified.");
          error.extension = e;
          throw error;
        }
        return e;
      }
      function _signatureParametersToAsn1(oid, params) {
        switch (oid) {
          case oids["RSASSA-PSS"]:
            var parts = [];
            if (params.hash.algorithmOid !== void 0) {
              parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ]));
            }
            if (params.mgf.algorithmOid !== void 0) {
              parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                  ])
                ])
              ]));
            }
            if (params.saltLength !== void 0) {
              parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())
              ]));
            }
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
          default:
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
        }
      }
      function _CRIAttributesToAsn1(csr) {
        var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
        if (csr.attributes.length === 0) {
          return rval;
        }
        var attrs = csr.attributes;
        for (var i = 0; i < attrs.length; ++i) {
          var attr = attrs[i];
          var value = attr.value;
          var valueTagClass = asn1.Type.UTF8;
          if ("valueTagClass" in attr) {
            valueTagClass = attr.valueTagClass;
          }
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
          var valueConstructed = false;
          if ("valueConstructed" in attr) {
            valueConstructed = attr.valueConstructed;
          }
          var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
            ])
          ]);
          rval.value.push(seq);
        }
        return rval;
      }
      var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
      var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
      function _dateToAsn1(date) {
        if (date >= jan_1_1950 && date < jan_1_2050) {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
        } else {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
        }
      }
      pki.getTBSCertificate = function(cert) {
        var notBefore = _dateToAsn1(cert.validity.notBefore);
        var notAfter = _dateToAsn1(cert.validity.notAfter);
        var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
            _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
          ]),
          _dnToAsn1(cert.issuer),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            notBefore,
            notAfter
          ]),
          _dnToAsn1(cert.subject),
          pki.publicKeyToAsn1(cert.publicKey)
        ]);
        if (cert.issuer.uniqueId) {
          tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
          ]));
        }
        if (cert.subject.uniqueId) {
          tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
          ]));
        }
        if (cert.extensions.length > 0) {
          tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
        }
        return tbs;
      };
      pki.getCertificationRequestInfo = function(csr) {
        var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
          _dnToAsn1(csr.subject),
          pki.publicKeyToAsn1(csr.publicKey),
          _CRIAttributesToAsn1(csr)
        ]);
        return cri;
      };
      pki.distinguishedNameToAsn1 = function(dn) {
        return _dnToAsn1(dn);
      };
      pki.certificateToAsn1 = function(cert) {
        var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          tbsCertificate,
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),
            _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
        ]);
      };
      pki.certificateExtensionsToAsn1 = function(exts) {
        var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        rval.value.push(seq);
        for (var i = 0; i < exts.length; ++i) {
          seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
        }
        return rval;
      };
      pki.certificateExtensionToAsn1 = function(ext) {
        var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
        if (ext.critical) {
          extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
        }
        var value = ext.value;
        if (typeof ext.value !== "string") {
          value = asn1.toDer(value).getBytes();
        }
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
        return extseq;
      };
      pki.certificationRequestToAsn1 = function(csr) {
        var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          cri,
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),
            _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
        ]);
      };
      pki.createCaStore = function(certs) {
        var caStore = {
          certs: {}
        };
        caStore.getIssuer = function(cert2) {
          var rval = getBySubject(cert2.issuer);
          return rval;
        };
        caStore.addCertificate = function(cert2) {
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          ensureSubjectHasHash(cert2.subject);
          if (!caStore.hasCertificate(cert2)) {
            if (cert2.subject.hash in caStore.certs) {
              var tmp = caStore.certs[cert2.subject.hash];
              if (!forge.util.isArray(tmp)) {
                tmp = [tmp];
              }
              tmp.push(cert2);
              caStore.certs[cert2.subject.hash] = tmp;
            } else {
              caStore.certs[cert2.subject.hash] = cert2;
            }
          }
        };
        caStore.hasCertificate = function(cert2) {
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          var match = getBySubject(cert2.subject);
          if (!match) {
            return false;
          }
          if (!forge.util.isArray(match)) {
            match = [match];
          }
          var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
          for (var i2 = 0; i2 < match.length; ++i2) {
            var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
            if (der1 === der2) {
              return true;
            }
          }
          return false;
        };
        caStore.listAllCertificates = function() {
          var certList = [];
          for (var hash in caStore.certs) {
            if (caStore.certs.hasOwnProperty(hash)) {
              var value = caStore.certs[hash];
              if (!forge.util.isArray(value)) {
                certList.push(value);
              } else {
                for (var i2 = 0; i2 < value.length; ++i2) {
                  certList.push(value[i2]);
                }
              }
            }
          }
          return certList;
        };
        caStore.removeCertificate = function(cert2) {
          var result;
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          ensureSubjectHasHash(cert2.subject);
          if (!caStore.hasCertificate(cert2)) {
            return null;
          }
          var match = getBySubject(cert2.subject);
          if (!forge.util.isArray(match)) {
            result = caStore.certs[cert2.subject.hash];
            delete caStore.certs[cert2.subject.hash];
            return result;
          }
          var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
          for (var i2 = 0; i2 < match.length; ++i2) {
            var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
            if (der1 === der2) {
              result = match[i2];
              match.splice(i2, 1);
            }
          }
          if (match.length === 0) {
            delete caStore.certs[cert2.subject.hash];
          }
          return result;
        };
        function getBySubject(subject) {
          ensureSubjectHasHash(subject);
          return caStore.certs[subject.hash] || null;
        }
        function ensureSubjectHasHash(subject) {
          if (!subject.hash) {
            var md = forge.md.sha1.create();
            subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
            subject.hash = md.digest().toHex();
          }
        }
        if (certs) {
          for (var i = 0; i < certs.length; ++i) {
            var cert = certs[i];
            caStore.addCertificate(cert);
          }
        }
        return caStore;
      };
      pki.certificateError = {
        bad_certificate: "forge.pki.BadCertificate",
        unsupported_certificate: "forge.pki.UnsupportedCertificate",
        certificate_revoked: "forge.pki.CertificateRevoked",
        certificate_expired: "forge.pki.CertificateExpired",
        certificate_unknown: "forge.pki.CertificateUnknown",
        unknown_ca: "forge.pki.UnknownCertificateAuthority"
      };
      pki.verifyCertificateChain = function(caStore, chain, options) {
        if (typeof options === "function") {
          options = { verify: options };
        }
        options = options || {};
        chain = chain.slice(0);
        var certs = chain.slice(0);
        var validityCheckDate = options.validityCheckDate;
        if (typeof validityCheckDate === "undefined") {
          validityCheckDate = new Date();
        }
        var first = true;
        var error = null;
        var depth = 0;
        do {
          var cert = chain.shift();
          var parent = null;
          var selfSigned = false;
          if (validityCheckDate) {
            if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
              error = {
                message: "Certificate is not valid yet or has expired.",
                error: pki.certificateError.certificate_expired,
                notBefore: cert.validity.notBefore,
                notAfter: cert.validity.notAfter,
                now: validityCheckDate
              };
            }
          }
          if (error === null) {
            parent = chain[0] || caStore.getIssuer(cert);
            if (parent === null) {
              if (cert.isIssuer(cert)) {
                selfSigned = true;
                parent = cert;
              }
            }
            if (parent) {
              var parents = parent;
              if (!forge.util.isArray(parents)) {
                parents = [parents];
              }
              var verified = false;
              while (!verified && parents.length > 0) {
                parent = parents.shift();
                try {
                  verified = parent.verify(cert);
                } catch (ex) {
                }
              }
              if (!verified) {
                error = {
                  message: "Certificate signature is invalid.",
                  error: pki.certificateError.bad_certificate
                };
              }
            }
            if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
              error = {
                message: "Certificate is not trusted.",
                error: pki.certificateError.unknown_ca
              };
            }
          }
          if (error === null && parent && !cert.isIssuer(parent)) {
            error = {
              message: "Certificate issuer is invalid.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null) {
            var se = {
              keyUsage: true,
              basicConstraints: true
            };
            for (var i = 0; error === null && i < cert.extensions.length; ++i) {
              var ext = cert.extensions[i];
              if (ext.critical && !(ext.name in se)) {
                error = {
                  message: "Certificate has an unsupported critical extension.",
                  error: pki.certificateError.unsupported_certificate
                };
              }
            }
          }
          if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
            var bcExt = cert.getExtension("basicConstraints");
            var keyUsageExt = cert.getExtension("keyUsage");
            if (keyUsageExt !== null) {
              if (!keyUsageExt.keyCertSign || bcExt === null) {
                error = {
                  message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                  error: pki.certificateError.bad_certificate
                };
              }
            }
            if (error === null && bcExt !== null && !bcExt.cA) {
              error = {
                message: "Certificate basicConstraints indicates the certificate is not a CA.",
                error: pki.certificateError.bad_certificate
              };
            }
            if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
              var pathLen = depth - 1;
              if (pathLen > bcExt.pathLenConstraint) {
                error = {
                  message: "Certificate basicConstraints pathLenConstraint violated.",
                  error: pki.certificateError.bad_certificate
                };
              }
            }
          }
          var vfd = error === null ? true : error.error;
          var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
          if (ret === true) {
            error = null;
          } else {
            if (vfd === true) {
              error = {
                message: "The application rejected the certificate.",
                error: pki.certificateError.bad_certificate
              };
            }
            if (ret || ret === 0) {
              if (typeof ret === "object" && !forge.util.isArray(ret)) {
                if (ret.message) {
                  error.message = ret.message;
                }
                if (ret.error) {
                  error.error = ret.error;
                }
              } else if (typeof ret === "string") {
                error.error = ret;
              }
            }
            throw error;
          }
          first = false;
          ++depth;
        } while (chain.length > 0);
        return true;
      };
    }
  });

  // node_modules/node-forge/lib/pkcs12.js
  var require_pkcs12 = __commonJS({
    "node_modules/node-forge/lib/pkcs12.js"(exports, module) {
      var forge = require_forge();
      require_asn1();
      require_hmac();
      require_oids();
      require_pkcs7asn1();
      require_pbe();
      require_random();
      require_rsa();
      require_sha1();
      require_util4();
      require_x509();
      var asn1 = forge.asn1;
      var pki = forge.pki;
      var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};
      var contentInfoValidator = {
        name: "ContentInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "ContentInfo.contentType",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "contentType"
        }, {
          name: "ContentInfo.content",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          constructed: true,
          captureAsn1: "content"
        }]
      };
      var pfxValidator = {
        name: "PFX",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [
          {
            name: "PFX.version",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "version"
          },
          contentInfoValidator,
          {
            name: "PFX.macData",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: "mac",
            value: [{
              name: "PFX.macData.mac",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.SEQUENCE,
                constructed: true,
                value: [{
                  name: "PFX.macData.mac.digestAlgorithm.algorithm",
                  tagClass: asn1.Class.UNIVERSAL,
                  type: asn1.Type.OID,
                  constructed: false,
                  capture: "macAlgorithm"
                }, {
                  name: "PFX.macData.mac.digestAlgorithm.parameters",
                  tagClass: asn1.Class.UNIVERSAL,
                  captureAsn1: "macAlgorithmParameters"
                }]
              }, {
                name: "PFX.macData.mac.digest",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OCTETSTRING,
                constructed: false,
                capture: "macDigest"
              }]
            }, {
              name: "PFX.macData.macSalt",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macSalt"
            }, {
              name: "PFX.macData.iterations",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              optional: true,
              capture: "macIterations"
            }]
          }
        ]
      };
      var safeBagValidator = {
        name: "SafeBag",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SafeBag.bagId",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "bagId"
        }, {
          name: "SafeBag.bagValue",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          constructed: true,
          captureAsn1: "bagValue"
        }, {
          name: "SafeBag.bagAttributes",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          optional: true,
          capture: "bagAttributes"
        }]
      };
      var attributeValidator = {
        name: "Attribute",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Attribute.attrId",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "oid"
        }, {
          name: "Attribute.attrValues",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          capture: "values"
        }]
      };
      var certBagValidator = {
        name: "CertBag",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "CertBag.certId",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certId"
        }, {
          name: "CertBag.certValue",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          constructed: true,
          value: [{
            name: "CertBag.certValue[0]",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Class.OCTETSTRING,
            constructed: false,
            capture: "cert"
          }]
        }]
      };
      function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
        var result = [];
        for (var i = 0; i < safeContents.length; i++) {
          for (var j = 0; j < safeContents[i].safeBags.length; j++) {
            var bag = safeContents[i].safeBags[j];
            if (bagType !== void 0 && bag.type !== bagType) {
              continue;
            }
            if (attrName === null) {
              result.push(bag);
              continue;
            }
            if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
              result.push(bag);
            }
          }
        }
        return result;
      }
      p12.pkcs12FromAsn1 = function(obj, strict, password) {
        if (typeof strict === "string") {
          password = strict;
          strict = true;
        } else if (strict === void 0) {
          strict = true;
        }
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, pfxValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
          error.errors = error;
          throw error;
        }
        var pfx = {
          version: capture.version.charCodeAt(0),
          safeContents: [],
          getBags: function(filter) {
            var rval = {};
            var localKeyId;
            if ("localKeyId" in filter) {
              localKeyId = filter.localKeyId;
            } else if ("localKeyIdHex" in filter) {
              localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
            }
            if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
              rval[filter.bagType] = _getBagsByAttribute(pfx.safeContents, null, null, filter.bagType);
            }
            if (localKeyId !== void 0) {
              rval.localKeyId = _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, filter.bagType);
            }
            if ("friendlyName" in filter) {
              rval.friendlyName = _getBagsByAttribute(pfx.safeContents, "friendlyName", filter.friendlyName, filter.bagType);
            }
            return rval;
          },
          getBagsByFriendlyName: function(friendlyName, bagType) {
            return _getBagsByAttribute(pfx.safeContents, "friendlyName", friendlyName, bagType);
          },
          getBagsByLocalKeyId: function(localKeyId, bagType) {
            return _getBagsByAttribute(pfx.safeContents, "localKeyId", localKeyId, bagType);
          }
        };
        if (capture.version.charCodeAt(0) !== 3) {
          var error = new Error("PKCS#12 PFX of version other than 3 not supported.");
          error.version = capture.version.charCodeAt(0);
          throw error;
        }
        if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
          var error = new Error("Only PKCS#12 PFX in password integrity mode supported.");
          error.oid = asn1.derToOid(capture.contentType);
          throw error;
        }
        var data = capture.content.value[0];
        if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
          throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
        }
        data = _decodePkcs7Data(data);
        if (capture.mac) {
          var md = null;
          var macKeyBytes = 0;
          var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
          switch (macAlgorithm) {
            case pki.oids.sha1:
              md = forge.md.sha1.create();
              macKeyBytes = 20;
              break;
            case pki.oids.sha256:
              md = forge.md.sha256.create();
              macKeyBytes = 32;
              break;
            case pki.oids.sha384:
              md = forge.md.sha384.create();
              macKeyBytes = 48;
              break;
            case pki.oids.sha512:
              md = forge.md.sha512.create();
              macKeyBytes = 64;
              break;
            case pki.oids.md5:
              md = forge.md.md5.create();
              macKeyBytes = 16;
              break;
          }
          if (md === null) {
            throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
          }
          var macSalt = new forge.util.ByteBuffer(capture.macSalt);
          var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
          var macKey = p12.generateKey(password, macSalt, 3, macIterations, macKeyBytes, md);
          var mac = forge.hmac.create();
          mac.start(md, macKey);
          mac.update(data.value);
          var macValue = mac.getMac();
          if (macValue.getBytes() !== capture.macDigest) {
            throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
          }
        }
        _decodeAuthenticatedSafe(pfx, data.value, strict, password);
        return pfx;
      };
      function _decodePkcs7Data(data) {
        if (data.composed || data.constructed) {
          var value = forge.util.createBuffer();
          for (var i = 0; i < data.value.length; ++i) {
            value.putBytes(data.value[i].value);
          }
          data.composed = data.constructed = false;
          data.value = value.getBytes();
        }
        return data;
      }
      function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
        authSafe = asn1.fromDer(authSafe, strict);
        if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
          throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
        }
        for (var i = 0; i < authSafe.value.length; i++) {
          var contentInfo = authSafe.value[i];
          var capture = {};
          var errors = [];
          if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
            var error = new Error("Cannot read ContentInfo.");
            error.errors = errors;
            throw error;
          }
          var obj = {
            encrypted: false
          };
          var safeContents = null;
          var data = capture.content.value[0];
          switch (asn1.derToOid(capture.contentType)) {
            case pki.oids.data:
              if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
                throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
              }
              safeContents = _decodePkcs7Data(data).value;
              break;
            case pki.oids.encryptedData:
              safeContents = _decryptSafeContents(data, password);
              obj.encrypted = true;
              break;
            default:
              var error = new Error("Unsupported PKCS#12 contentType.");
              error.contentType = asn1.derToOid(capture.contentType);
              throw error;
          }
          obj.safeBags = _decodeSafeContents(safeContents, strict, password);
          pfx.safeContents.push(obj);
        }
      }
      function _decryptSafeContents(data, password) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(data, forge.pkcs7.asn1.encryptedDataValidator, capture, errors)) {
          var error = new Error("Cannot read EncryptedContentInfo.");
          error.errors = errors;
          throw error;
        }
        var oid = asn1.derToOid(capture.contentType);
        if (oid !== pki.oids.data) {
          var error = new Error("PKCS#12 EncryptedContentInfo ContentType is not Data.");
          error.oid = oid;
          throw error;
        }
        oid = asn1.derToOid(capture.encAlgorithm);
        var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
        var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
        var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
        cipher.update(encrypted);
        if (!cipher.finish()) {
          throw new Error("Failed to decrypt PKCS#12 SafeContents.");
        }
        return cipher.output.getBytes();
      }
      function _decodeSafeContents(safeContents, strict, password) {
        if (!strict && safeContents.length === 0) {
          return [];
        }
        safeContents = asn1.fromDer(safeContents, strict);
        if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
          throw new Error("PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag.");
        }
        var res = [];
        for (var i = 0; i < safeContents.value.length; i++) {
          var safeBag = safeContents.value[i];
          var capture = {};
          var errors = [];
          if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
            var error = new Error("Cannot read SafeBag.");
            error.errors = errors;
            throw error;
          }
          var bag = {
            type: asn1.derToOid(capture.bagId),
            attributes: _decodeBagAttributes(capture.bagAttributes)
          };
          res.push(bag);
          var validator, decoder;
          var bagAsn1 = capture.bagValue.value[0];
          switch (bag.type) {
            case pki.oids.pkcs8ShroudedKeyBag:
              bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
              if (bagAsn1 === null) {
                throw new Error("Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?");
              }
            case pki.oids.keyBag:
              try {
                bag.key = pki.privateKeyFromAsn1(bagAsn1);
              } catch (e) {
                bag.key = null;
                bag.asn1 = bagAsn1;
              }
              continue;
            case pki.oids.certBag:
              validator = certBagValidator;
              decoder = function() {
                if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                  var error2 = new Error("Unsupported certificate type, only X.509 supported.");
                  error2.oid = asn1.derToOid(capture.certId);
                  throw error2;
                }
                var certAsn1 = asn1.fromDer(capture.cert, strict);
                try {
                  bag.cert = pki.certificateFromAsn1(certAsn1, true);
                } catch (e) {
                  bag.cert = null;
                  bag.asn1 = certAsn1;
                }
              };
              break;
            default:
              var error = new Error("Unsupported PKCS#12 SafeBag type.");
              error.oid = bag.type;
              throw error;
          }
          if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
            var error = new Error("Cannot read PKCS#12 " + validator.name);
            error.errors = errors;
            throw error;
          }
          decoder();
        }
        return res;
      }
      function _decodeBagAttributes(attributes) {
        var decodedAttrs = {};
        if (attributes !== void 0) {
          for (var i = 0; i < attributes.length; ++i) {
            var capture = {};
            var errors = [];
            if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
              var error = new Error("Cannot read PKCS#12 BagAttribute.");
              error.errors = errors;
              throw error;
            }
            var oid = asn1.derToOid(capture.oid);
            if (pki.oids[oid] === void 0) {
              continue;
            }
            decodedAttrs[pki.oids[oid]] = [];
            for (var j = 0; j < capture.values.length; ++j) {
              decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
            }
          }
        }
        return decodedAttrs;
      }
      p12.toPkcs12Asn1 = function(key, cert, password, options) {
        options = options || {};
        options.saltSize = options.saltSize || 8;
        options.count = options.count || 2048;
        options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
        if (!("useMac" in options)) {
          options.useMac = true;
        }
        if (!("localKeyId" in options)) {
          options.localKeyId = null;
        }
        if (!("generateLocalKeyId" in options)) {
          options.generateLocalKeyId = true;
        }
        var localKeyId = options.localKeyId;
        var bagAttrs;
        if (localKeyId !== null) {
          localKeyId = forge.util.hexToBytes(localKeyId);
        } else if (options.generateLocalKeyId) {
          if (cert) {
            var pairedCert = forge.util.isArray(cert) ? cert[0] : cert;
            if (typeof pairedCert === "string") {
              pairedCert = pki.certificateFromPem(pairedCert);
            }
            var sha1 = forge.md.sha1.create();
            sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
            localKeyId = sha1.digest().getBytes();
          } else {
            localKeyId = forge.random.getBytes(20);
          }
        }
        var attrs = [];
        if (localKeyId !== null) {
          attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.localKeyId).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, localKeyId)
            ])
          ]));
        }
        if ("friendlyName" in options) {
          attrs.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.friendlyName).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BMPSTRING, false, options.friendlyName)
            ])
          ]));
        }
        if (attrs.length > 0) {
          bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
        }
        var contents = [];
        var chain = [];
        if (cert !== null) {
          if (forge.util.isArray(cert)) {
            chain = cert;
          } else {
            chain = [cert];
          }
        }
        var certSafeBags = [];
        for (var i = 0; i < chain.length; ++i) {
          cert = chain[i];
          if (typeof cert === "string") {
            cert = pki.certificateFromPem(cert);
          }
          var certBagAttrs = i === 0 ? bagAttrs : void 0;
          var certAsn1 = pki.certificateToAsn1(cert);
          var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.certBag).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.x509Certificate).getBytes()),
                asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certAsn1).getBytes())
                ])
              ])
            ]),
            certBagAttrs
          ]);
          certSafeBags.push(certSafeBag);
        }
        if (certSafeBags.length > 0) {
          var certSafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, certSafeBags);
          var certCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(certSafeContents).getBytes())
            ])
          ]);
          contents.push(certCI);
        }
        var keyBag = null;
        if (key !== null) {
          var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
          if (password === null) {
            keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.keyBag).getBytes()),
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                pkAsn1
              ]),
              bagAttrs
            ]);
          } else {
            keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()),
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                pki.encryptPrivateKeyInfo(pkAsn1, password, options)
              ]),
              bagAttrs
            ]);
          }
          var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
          var keyCI = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(keySafeContents).getBytes())
            ])
          ]);
          contents.push(keyCI);
        }
        var safe = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, contents);
        var macData;
        if (options.useMac) {
          var sha1 = forge.md.sha1.create();
          var macSalt = new forge.util.ByteBuffer(forge.random.getBytes(options.saltSize));
          var count = options.count;
          var key = p12.generateKey(password, macSalt, 3, count, 20);
          var mac = forge.hmac.create();
          mac.start(sha1, key);
          mac.update(asn1.toDer(safe).getBytes());
          var macValue = mac.getMac();
          macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.sha1).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ]),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macValue.getBytes())
            ]),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, macSalt.getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(count).getBytes())
          ]);
        }
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(3).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.data).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(safe).getBytes())
            ])
          ]),
          macData
        ]);
      };
      p12.generateKey = forge.pbe.generatePkcs12Key;
    }
  });

  // node_modules/node-forge/lib/pki.js
  var require_pki = __commonJS({
    "node_modules/node-forge/lib/pki.js"(exports, module) {
      var forge = require_forge();
      require_asn1();
      require_oids();
      require_pbe();
      require_pem();
      require_pbkdf2();
      require_pkcs12();
      require_pss();
      require_rsa();
      require_util4();
      require_x509();
      var asn1 = forge.asn1;
      var pki = module.exports = forge.pki = forge.pki || {};
      pki.pemToDer = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert PEM to DER; PEM is encrypted.");
        }
        return forge.util.createBuffer(msg.body);
      };
      pki.privateKeyFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
          var error = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert private key from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body);
        return pki.privateKeyFromAsn1(obj);
      };
      pki.privateKeyToPem = function(key, maxline) {
        var msg = {
          type: "RSA PRIVATE KEY",
          body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
      pki.privateKeyInfoToPem = function(pki2, maxline) {
        var msg = {
          type: "PRIVATE KEY",
          body: asn1.toDer(pki2).getBytes()
        };
        return forge.pem.encode(msg, { maxline });
      };
    }
  });

  // node_modules/node-forge/lib/tls.js
  var require_tls = __commonJS({
    "node_modules/node-forge/lib/tls.js"(exports, module) {
      var forge = require_forge();
      require_asn1();
      require_hmac();
      require_md5();
      require_pem();
      require_pki();
      require_random();
      require_sha1();
      require_util4();
      var prf_TLS1 = function(secret, label, seed, length) {
        var rval = forge.util.createBuffer();
        var idx = secret.length >> 1;
        var slen = idx + (secret.length & 1);
        var s1 = secret.substr(0, slen);
        var s2 = secret.substr(idx, slen);
        var ai = forge.util.createBuffer();
        var hmac = forge.hmac.create();
        seed = label + seed;
        var md5itr = Math.ceil(length / 16);
        var sha1itr = Math.ceil(length / 20);
        hmac.start("MD5", s1);
        var md5bytes = forge.util.createBuffer();
        ai.putBytes(seed);
        for (var i = 0; i < md5itr; ++i) {
          hmac.start(null, null);
          hmac.update(ai.getBytes());
          ai.putBuffer(hmac.digest());
          hmac.start(null, null);
          hmac.update(ai.bytes() + seed);
          md5bytes.putBuffer(hmac.digest());
        }
        hmac.start("SHA1", s2);
        var sha1bytes = forge.util.createBuffer();
        ai.clear();
        ai.putBytes(seed);
        for (var i = 0; i < sha1itr; ++i) {
          hmac.start(null, null);
          hmac.update(ai.getBytes());
          ai.putBuffer(hmac.digest());
          hmac.start(null, null);
          hmac.update(ai.bytes() + seed);
          sha1bytes.putBuffer(hmac.digest());
        }
        rval.putBytes(forge.util.xorBytes(md5bytes.getBytes(), sha1bytes.getBytes(), length));
        return rval;
      };
      var hmac_sha1 = function(key2, seqNum, record) {
        var hmac = forge.hmac.create();
        hmac.start("SHA1", key2);
        var b = forge.util.createBuffer();
        b.putInt32(seqNum[0]);
        b.putInt32(seqNum[1]);
        b.putByte(record.type);
        b.putByte(record.version.major);
        b.putByte(record.version.minor);
        b.putInt16(record.length);
        b.putBytes(record.fragment.bytes());
        hmac.update(b.getBytes());
        return hmac.digest().getBytes();
      };
      var deflate = function(c, record, s) {
        var rval = false;
        try {
          var bytes = c.deflate(record.fragment.getBytes());
          record.fragment = forge.util.createBuffer(bytes);
          record.length = bytes.length;
          rval = true;
        } catch (ex) {
        }
        return rval;
      };
      var inflate = function(c, record, s) {
        var rval = false;
        try {
          var bytes = c.inflate(record.fragment.getBytes());
          record.fragment = forge.util.createBuffer(bytes);
          record.length = bytes.length;
          rval = true;
        } catch (ex) {
        }
        return rval;
      };
      var readVector = function(b, lenBytes) {
        var len = 0;
        switch (lenBytes) {
          case 1:
            len = b.getByte();
            break;
          case 2:
            len = b.getInt16();
            break;
          case 3:
            len = b.getInt24();
            break;
          case 4:
            len = b.getInt32();
            break;
        }
        return forge.util.createBuffer(b.getBytes(len));
      };
      var writeVector = function(b, lenBytes, v) {
        b.putInt(v.length(), lenBytes << 3);
        b.putBuffer(v);
      };
      var tls = {};
      tls.Versions = {
        TLS_1_0: { major: 3, minor: 1 },
        TLS_1_1: { major: 3, minor: 2 },
        TLS_1_2: { major: 3, minor: 3 }
      };
      tls.SupportedVersions = [
        tls.Versions.TLS_1_1,
        tls.Versions.TLS_1_0
      ];
      tls.Version = tls.SupportedVersions[0];
      tls.MaxFragment = 16384 - 1024;
      tls.ConnectionEnd = {
        server: 0,
        client: 1
      };
      tls.PRFAlgorithm = {
        tls_prf_sha256: 0
      };
      tls.BulkCipherAlgorithm = {
        none: null,
        rc4: 0,
        des3: 1,
        aes: 2
      };
      tls.CipherType = {
        stream: 0,
        block: 1,
        aead: 2
      };
      tls.MACAlgorithm = {
        none: null,
        hmac_md5: 0,
        hmac_sha1: 1,
        hmac_sha256: 2,
        hmac_sha384: 3,
        hmac_sha512: 4
      };
      tls.CompressionMethod = {
        none: 0,
        deflate: 1
      };
      tls.ContentType = {
        change_cipher_spec: 20,
        alert: 21,
        handshake: 22,
        application_data: 23,
        heartbeat: 24
      };
      tls.HandshakeType = {
        hello_request: 0,
        client_hello: 1,
        server_hello: 2,
        certificate: 11,
        server_key_exchange: 12,
        certificate_request: 13,
        server_hello_done: 14,
        certificate_verify: 15,
        client_key_exchange: 16,
        finished: 20
      };
      tls.Alert = {};
      tls.Alert.Level = {
        warning: 1,
        fatal: 2
      };
      tls.Alert.Description = {
        close_notify: 0,
        unexpected_message: 10,
        bad_record_mac: 20,
        decryption_failed: 21,
        record_overflow: 22,
        decompression_failure: 30,
        handshake_failure: 40,
        bad_certificate: 42,
        unsupported_certificate: 43,
        certificate_revoked: 44,
        certificate_expired: 45,
        certificate_unknown: 46,
        illegal_parameter: 47,
        unknown_ca: 48,
        access_denied: 49,
        decode_error: 50,
        decrypt_error: 51,
        export_restriction: 60,
        protocol_version: 70,
        insufficient_security: 71,
        internal_error: 80,
        user_canceled: 90,
        no_renegotiation: 100
      };
      tls.HeartbeatMessageType = {
        heartbeat_request: 1,
        heartbeat_response: 2
      };
      tls.CipherSuites = {};
      tls.getCipherSuite = function(twoBytes) {
        var rval = null;
        for (var key2 in tls.CipherSuites) {
          var cs = tls.CipherSuites[key2];
          if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
            rval = cs;
            break;
          }
        }
        return rval;
      };
      tls.handleUnexpected = function(c, record) {
        var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
        if (!ignore) {
          c.error(c, {
            message: "Unexpected message. Received TLS record out of order.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.unexpected_message
            }
          });
        }
      };
      tls.handleHelloRequest = function(c, record, length) {
        if (!c.handshaking && c.handshakes > 0) {
          tls.queue(c, tls.createAlert(c, {
            level: tls.Alert.Level.warning,
            description: tls.Alert.Description.no_renegotiation
          }));
          tls.flush(c);
        }
        c.process();
      };
      tls.parseHelloMessage = function(c, record, length) {
        var msg = null;
        var client = c.entity === tls.ConnectionEnd.client;
        if (length < 38) {
          c.error(c, {
            message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.illegal_parameter
            }
          });
        } else {
          var b = record.fragment;
          var remaining = b.length();
          msg = {
            version: {
              major: b.getByte(),
              minor: b.getByte()
            },
            random: forge.util.createBuffer(b.getBytes(32)),
            session_id: readVector(b, 1),
            extensions: []
          };
          if (client) {
            msg.cipher_suite = b.getBytes(2);
            msg.compression_method = b.getByte();
          } else {
            msg.cipher_suites = readVector(b, 2);
            msg.compression_methods = readVector(b, 1);
          }
          remaining = length - (remaining - b.length());
          if (remaining > 0) {
            var exts = readVector(b, 2);
            while (exts.length() > 0) {
              msg.extensions.push({
                type: [exts.getByte(), exts.getByte()],
                data: readVector(exts, 2)
              });
            }
            if (!client) {
              for (var i = 0; i < msg.extensions.length; ++i) {
                var ext = msg.extensions[i];
                if (ext.type[0] === 0 && ext.type[1] === 0) {
                  var snl = readVector(ext.data, 2);
                  while (snl.length() > 0) {
                    var snType = snl.getByte();
                    if (snType !== 0) {
                      break;
                    }
                    c.session.extensions.server_name.serverNameList.push(readVector(snl, 2).getBytes());
                  }
                }
              }
            }
          }
          if (c.session.version) {
            if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
              return c.error(c, {
                message: "TLS version change is disallowed during renegotiation.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.protocol_version
                }
              });
            }
          }
          if (client) {
            c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
          } else {
            var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
            while (tmp.length() > 0) {
              c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
              if (c.session.cipherSuite !== null) {
                break;
              }
            }
          }
          if (c.session.cipherSuite === null) {
            return c.error(c, {
              message: "No cipher suites in common.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.handshake_failure
              },
              cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
            });
          }
          if (client) {
            c.session.compressionMethod = msg.compression_method;
          } else {
            c.session.compressionMethod = tls.CompressionMethod.none;
          }
        }
        return msg;
      };
      tls.createSecurityParameters = function(c, msg) {
        var client = c.entity === tls.ConnectionEnd.client;
        var msgRandom = msg.random.bytes();
        var cRandom = client ? c.session.sp.client_random : msgRandom;
        var sRandom = client ? msgRandom : tls.createRandom().getBytes();
        c.session.sp = {
          entity: c.entity,
          prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
          bulk_cipher_algorithm: null,
          cipher_type: null,
          enc_key_length: null,
          block_length: null,
          fixed_iv_length: null,
          record_iv_length: null,
          mac_algorithm: null,
          mac_length: null,
          mac_key_length: null,
          compression_algorithm: c.session.compressionMethod,
          pre_master_secret: null,
          master_secret: null,
          client_random: cRandom,
          server_random: sRandom
        };
      };
      tls.handleServerHello = function(c, record, length) {
        var msg = tls.parseHelloMessage(c, record, length);
        if (c.fail) {
          return;
        }
        if (msg.version.minor <= c.version.minor) {
          c.version.minor = msg.version.minor;
        } else {
          return c.error(c, {
            message: "Incompatible TLS version.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.protocol_version
            }
          });
        }
        c.session.version = c.version;
        var sessionId = msg.session_id.bytes();
        if (sessionId.length > 0 && sessionId === c.session.id) {
          c.expect = SCC;
          c.session.resuming = true;
          c.session.sp.server_random = msg.random.bytes();
        } else {
          c.expect = SCE;
          c.session.resuming = false;
          tls.createSecurityParameters(c, msg);
        }
        c.session.id = sessionId;
        c.process();
      };
      tls.handleClientHello = function(c, record, length) {
        var msg = tls.parseHelloMessage(c, record, length);
        if (c.fail) {
          return;
        }
        var sessionId = msg.session_id.bytes();
        var session = null;
        if (c.sessionCache) {
          session = c.sessionCache.getSession(sessionId);
          if (session === null) {
            sessionId = "";
          } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
            session = null;
            sessionId = "";
          }
        }
        if (sessionId.length === 0) {
          sessionId = forge.random.getBytes(32);
        }
        c.session.id = sessionId;
        c.session.clientHelloVersion = msg.version;
        c.session.sp = {};
        if (session) {
          c.version = c.session.version = session.version;
          c.session.sp = session.sp;
        } else {
          var version;
          for (var i = 1; i < tls.SupportedVersions.length; ++i) {
            version = tls.SupportedVersions[i];
            if (version.minor <= msg.version.minor) {
              break;
            }
          }
          c.version = { major: version.major, minor: version.minor };
          c.session.version = c.version;
        }
        if (session !== null) {
          c.expect = CCC;
          c.session.resuming = true;
          c.session.sp.client_random = msg.random.bytes();
        } else {
          c.expect = c.verifyClient !== false ? CCE : CKE;
          c.session.resuming = false;
          tls.createSecurityParameters(c, msg);
        }
        c.open = true;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createServerHello(c)
        }));
        if (c.session.resuming) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.change_cipher_spec,
            data: tls.createChangeCipherSpec()
          }));
          c.state.pending = tls.createConnectionState(c);
          c.state.current.write = c.state.pending.write;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createFinished(c)
          }));
        } else {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createCertificate(c)
          }));
          if (!c.fail) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createServerKeyExchange(c)
            }));
            if (c.verifyClient !== false) {
              tls.queue(c, tls.createRecord(c, {
                type: tls.ContentType.handshake,
                data: tls.createCertificateRequest(c)
              }));
            }
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createServerHelloDone(c)
            }));
          }
        }
        tls.flush(c);
        c.process();
      };
      tls.handleCertificate = function(c, record, length) {
        if (length < 3) {
          return c.error(c, {
            message: "Invalid Certificate message. Message too short.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.illegal_parameter
            }
          });
        }
        var b = record.fragment;
        var msg = {
          certificate_list: readVector(b, 3)
        };
        var cert, asn1;
        var certs = [];
        try {
          while (msg.certificate_list.length() > 0) {
            cert = readVector(msg.certificate_list, 3);
            asn1 = forge.asn1.fromDer(cert);
            cert = forge.pki.certificateFromAsn1(asn1, true);
            certs.push(cert);
          }
        } catch (ex) {
          return c.error(c, {
            message: "Could not parse certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
        var client = c.entity === tls.ConnectionEnd.client;
        if ((client || c.verifyClient === true) && certs.length === 0) {
          c.error(c, {
            message: client ? "No server certificate provided." : "No client certificate provided.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.illegal_parameter
            }
          });
        } else if (certs.length === 0) {
          c.expect = client ? SKE : CKE;
        } else {
          if (client) {
            c.session.serverCertificate = certs[0];
          } else {
            c.session.clientCertificate = certs[0];
          }
          if (tls.verifyCertificateChain(c, certs)) {
            c.expect = client ? SKE : CKE;
          }
        }
        c.process();
      };
      tls.handleServerKeyExchange = function(c, record, length) {
        if (length > 0) {
          return c.error(c, {
            message: "Invalid key parameters. Only RSA is supported.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.unsupported_certificate
            }
          });
        }
        c.expect = SCR;
        c.process();
      };
      tls.handleClientKeyExchange = function(c, record, length) {
        if (length < 48) {
          return c.error(c, {
            message: "Invalid key parameters. Only RSA is supported.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.unsupported_certificate
            }
          });
        }
        var b = record.fragment;
        var msg = {
          enc_pre_master_secret: readVector(b, 2).getBytes()
        };
        var privateKey = null;
        if (c.getPrivateKey) {
          try {
            privateKey = c.getPrivateKey(c, c.session.serverCertificate);
            privateKey = forge.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c.error(c, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          return c.error(c, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        try {
          var sp = c.session.sp;
          sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
          var version = c.session.clientHelloVersion;
          if (version.major !== sp.pre_master_secret.charCodeAt(0) || version.minor !== sp.pre_master_secret.charCodeAt(1)) {
            throw new Error("TLS version rollback attack detected.");
          }
        } catch (ex) {
          sp.pre_master_secret = forge.random.getBytes(48);
        }
        c.expect = CCC;
        if (c.session.clientCertificate !== null) {
          c.expect = CCV;
        }
        c.process();
      };
      tls.handleCertificateRequest = function(c, record, length) {
        if (length < 3) {
          return c.error(c, {
            message: "Invalid CertificateRequest. Message too short.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.illegal_parameter
            }
          });
        }
        var b = record.fragment;
        var msg = {
          certificate_types: readVector(b, 1),
          certificate_authorities: readVector(b, 2)
        };
        c.session.certificateRequest = msg;
        c.expect = SHD;
        c.process();
      };
      tls.handleCertificateVerify = function(c, record, length) {
        if (length < 2) {
          return c.error(c, {
            message: "Invalid CertificateVerify. Message too short.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.illegal_parameter
            }
          });
        }
        var b = record.fragment;
        b.read -= 4;
        var msgBytes = b.bytes();
        b.read += 4;
        var msg = {
          signature: readVector(b, 2).getBytes()
        };
        var verify = forge.util.createBuffer();
        verify.putBuffer(c.session.md5.digest());
        verify.putBuffer(c.session.sha1.digest());
        verify = verify.getBytes();
        try {
          var cert = c.session.clientCertificate;
          if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
            throw new Error("CertificateVerify signature does not match.");
          }
          c.session.md5.update(msgBytes);
          c.session.sha1.update(msgBytes);
        } catch (ex) {
          return c.error(c, {
            message: "Bad signature in CertificateVerify.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            }
          });
        }
        c.expect = CCC;
        c.process();
      };
      tls.handleServerHelloDone = function(c, record, length) {
        if (length > 0) {
          return c.error(c, {
            message: "Invalid ServerHelloDone message. Invalid length.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.record_overflow
            }
          });
        }
        if (c.serverCertificate === null) {
          var error = {
            message: "No server certificate provided. Not enough security.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.insufficient_security
            }
          };
          var depth = 0;
          var ret = c.verify(c, error.alert.description, depth, []);
          if (ret !== true) {
            if (ret || ret === 0) {
              if (typeof ret === "object" && !forge.util.isArray(ret)) {
                if (ret.message) {
                  error.message = ret.message;
                }
                if (ret.alert) {
                  error.alert.description = ret.alert;
                }
              } else if (typeof ret === "number") {
                error.alert.description = ret;
              }
            }
            return c.error(c, error);
          }
        }
        if (c.session.certificateRequest !== null) {
          record = tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createCertificate(c)
          });
          tls.queue(c, record);
        }
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createClientKeyExchange(c)
        });
        tls.queue(c, record);
        c.expect = SER;
        var callback = function(c2, signature) {
          if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
            tls.queue(c2, tls.createRecord(c2, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateVerify(c2, signature)
            }));
          }
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.change_cipher_spec,
            data: tls.createChangeCipherSpec()
          }));
          c2.state.pending = tls.createConnectionState(c2);
          c2.state.current.write = c2.state.pending.write;
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createFinished(c2)
          }));
          c2.expect = SCC;
          tls.flush(c2);
          c2.process();
        };
        if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
          return callback(c, null);
        }
        tls.getClientSignature(c, callback);
      };
      tls.handleChangeCipherSpec = function(c, record) {
        if (record.fragment.getByte() !== 1) {
          return c.error(c, {
            message: "Invalid ChangeCipherSpec message received.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.illegal_parameter
            }
          });
        }
        var client = c.entity === tls.ConnectionEnd.client;
        if (c.session.resuming && client || !c.session.resuming && !client) {
          c.state.pending = tls.createConnectionState(c);
        }
        c.state.current.read = c.state.pending.read;
        if (!c.session.resuming && client || c.session.resuming && !client) {
          c.state.pending = null;
        }
        c.expect = client ? SFI : CFI;
        c.process();
      };
      tls.handleFinished = function(c, record, length) {
        var b = record.fragment;
        b.read -= 4;
        var msgBytes = b.bytes();
        b.read += 4;
        var vd = record.fragment.getBytes();
        b = forge.util.createBuffer();
        b.putBuffer(c.session.md5.digest());
        b.putBuffer(c.session.sha1.digest());
        var client = c.entity === tls.ConnectionEnd.client;
        var label = client ? "server finished" : "client finished";
        var sp = c.session.sp;
        var vdl = 12;
        var prf = prf_TLS1;
        b = prf(sp.master_secret, label, b.getBytes(), vdl);
        if (b.getBytes() !== vd) {
          return c.error(c, {
            message: "Invalid verify_data in Finished message.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decrypt_error
            }
          });
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
        if (c.session.resuming && client || !c.session.resuming && !client) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.change_cipher_spec,
            data: tls.createChangeCipherSpec()
          }));
          c.state.current.write = c.state.pending.write;
          c.state.pending = null;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createFinished(c)
          }));
        }
        c.expect = client ? SAD : CAD;
        c.handshaking = false;
        ++c.handshakes;
        c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
        tls.flush(c);
        c.isConnected = true;
        c.connected(c);
        c.process();
      };
      tls.handleAlert = function(c, record) {
        var b = record.fragment;
        var alert = {
          level: b.getByte(),
          description: b.getByte()
        };
        var msg;
        switch (alert.description) {
          case tls.Alert.Description.close_notify:
            msg = "Connection closed.";
            break;
          case tls.Alert.Description.unexpected_message:
            msg = "Unexpected message.";
            break;
          case tls.Alert.Description.bad_record_mac:
            msg = "Bad record MAC.";
            break;
          case tls.Alert.Description.decryption_failed:
            msg = "Decryption failed.";
            break;
          case tls.Alert.Description.record_overflow:
            msg = "Record overflow.";
            break;
          case tls.Alert.Description.decompression_failure:
            msg = "Decompression failed.";
            break;
          case tls.Alert.Description.handshake_failure:
            msg = "Handshake failure.";
            break;
          case tls.Alert.Description.bad_certificate:
            msg = "Bad certificate.";
            break;
          case tls.Alert.Description.unsupported_certificate:
            msg = "Unsupported certificate.";
            break;
          case tls.Alert.Description.certificate_revoked:
            msg = "Certificate revoked.";
            break;
          case tls.Alert.Description.certificate_expired:
            msg = "Certificate expired.";
            break;
          case tls.Alert.Description.certificate_unknown:
            msg = "Certificate unknown.";
            break;
          case tls.Alert.Description.illegal_parameter:
            msg = "Illegal parameter.";
            break;
          case tls.Alert.Description.unknown_ca:
            msg = "Unknown certificate authority.";
            break;
          case tls.Alert.Description.access_denied:
            msg = "Access denied.";
            break;
          case tls.Alert.Description.decode_error:
            msg = "Decode error.";
            break;
          case tls.Alert.Description.decrypt_error:
            msg = "Decrypt error.";
            break;
          case tls.Alert.Description.export_restriction:
            msg = "Export restriction.";
            break;
          case tls.Alert.Description.protocol_version:
            msg = "Unsupported protocol version.";
            break;
          case tls.Alert.Description.insufficient_security:
            msg = "Insufficient security.";
            break;
          case tls.Alert.Description.internal_error:
            msg = "Internal error.";
            break;
          case tls.Alert.Description.user_canceled:
            msg = "User canceled.";
            break;
          case tls.Alert.Description.no_renegotiation:
            msg = "Renegotiation not supported.";
            break;
          default:
            msg = "Unknown error.";
            break;
        }
        if (alert.description === tls.Alert.Description.close_notify) {
          return c.close();
        }
        c.error(c, {
          message: msg,
          send: false,
          origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
          alert
        });
        c.process();
      };
      tls.handleHandshake = function(c, record) {
        var b = record.fragment;
        var type = b.getByte();
        var length = b.getInt24();
        if (length > b.length()) {
          c.fragmented = record;
          record.fragment = forge.util.createBuffer();
          b.read -= 4;
          return c.process();
        }
        c.fragmented = null;
        b.read -= 4;
        var bytes = b.bytes(length + 4);
        b.read += 4;
        if (type in hsTable[c.entity][c.expect]) {
          if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
            c.handshaking = true;
            c.session = {
              version: null,
              extensions: {
                server_name: {
                  serverNameList: []
                }
              },
              cipherSuite: null,
              compressionMethod: null,
              serverCertificate: null,
              clientCertificate: null,
              md5: forge.md.md5.create(),
              sha1: forge.md.sha1.create()
            };
          }
          if (type !== tls.HandshakeType.hello_request && type !== tls.HandshakeType.certificate_verify && type !== tls.HandshakeType.finished) {
            c.session.md5.update(bytes);
            c.session.sha1.update(bytes);
          }
          hsTable[c.entity][c.expect][type](c, record, length);
        } else {
          tls.handleUnexpected(c, record);
        }
      };
      tls.handleApplicationData = function(c, record) {
        c.data.putBuffer(record.fragment);
        c.dataReady(c);
        c.process();
      };
      tls.handleHeartbeat = function(c, record) {
        var b = record.fragment;
        var type = b.getByte();
        var length = b.getInt16();
        var payload = b.getBytes(length);
        if (type === tls.HeartbeatMessageType.heartbeat_request) {
          if (c.handshaking || length > payload.length) {
            return c.process();
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.heartbeat,
            data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_response, payload)
          }));
          tls.flush(c);
        } else if (type === tls.HeartbeatMessageType.heartbeat_response) {
          if (payload !== c.expectedHeartbeatPayload) {
            return c.process();
          }
          if (c.heartbeatReceived) {
            c.heartbeatReceived(c, forge.util.createBuffer(payload));
          }
        }
        c.process();
      };
      var SHE = 0;
      var SCE = 1;
      var SKE = 2;
      var SCR = 3;
      var SHD = 4;
      var SCC = 5;
      var SFI = 6;
      var SAD = 7;
      var SER = 8;
      var CHE = 0;
      var CCE = 1;
      var CKE = 2;
      var CCV = 3;
      var CCC = 4;
      var CFI = 5;
      var CAD = 6;
      var __ = tls.handleUnexpected;
      var R0 = tls.handleChangeCipherSpec;
      var R1 = tls.handleAlert;
      var R2 = tls.handleHandshake;
      var R3 = tls.handleApplicationData;
      var R4 = tls.handleHeartbeat;
      var ctTable = [];
      ctTable[tls.ConnectionEnd.client] = [
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [R0, R1, __, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, R3, R4],
        [__, R1, R2, __, R4]
      ];
      ctTable[tls.ConnectionEnd.server] = [
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, __, R4],
        [R0, R1, __, __, R4],
        [__, R1, R2, __, R4],
        [__, R1, R2, R3, R4],
        [__, R1, R2, __, R4]
      ];
      var H0 = tls.handleHelloRequest;
      var H1 = tls.handleServerHello;
      var H2 = tls.handleCertificate;
      var H3 = tls.handleServerKeyExchange;
      var H4 = tls.handleCertificateRequest;
      var H5 = tls.handleServerHelloDone;
      var H6 = tls.handleFinished;
      var hsTable = [];
      hsTable[tls.ConnectionEnd.client] = [
        [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
        [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
        [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
      ];
      var H7 = tls.handleClientHello;
      var H8 = tls.handleClientKeyExchange;
      var H9 = tls.handleCertificateVerify;
      hsTable[tls.ConnectionEnd.server] = [
        [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
        [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
        [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
        [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
        [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
        [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
        [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
        [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
      ];
      tls.generateKeys = function(c, sp) {
        var prf = prf_TLS1;
        var random = sp.client_random + sp.server_random;
        if (!c.session.resuming) {
          sp.master_secret = prf(sp.pre_master_secret, "master secret", random, 48).bytes();
          sp.pre_master_secret = null;
        }
        random = sp.server_random + sp.client_random;
        var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
        var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
        if (tls10) {
          length += 2 * sp.fixed_iv_length;
        }
        var km = prf(sp.master_secret, "key expansion", random, length);
        var rval = {
          client_write_MAC_key: km.getBytes(sp.mac_key_length),
          server_write_MAC_key: km.getBytes(sp.mac_key_length),
          client_write_key: km.getBytes(sp.enc_key_length),
          server_write_key: km.getBytes(sp.enc_key_length)
        };
        if (tls10) {
          rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
          rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
        }
        return rval;
      };
      tls.createConnectionState = function(c) {
        var client = c.entity === tls.ConnectionEnd.client;
        var createMode = function() {
          var mode = {
            sequenceNumber: [0, 0],
            macKey: null,
            macLength: 0,
            macFunction: null,
            cipherState: null,
            cipherFunction: function(record) {
              return true;
            },
            compressionState: null,
            compressFunction: function(record) {
              return true;
            },
            updateSequenceNumber: function() {
              if (mode.sequenceNumber[1] === 4294967295) {
                mode.sequenceNumber[1] = 0;
                ++mode.sequenceNumber[0];
              } else {
                ++mode.sequenceNumber[1];
              }
            }
          };
          return mode;
        };
        var state = {
          read: createMode(),
          write: createMode()
        };
        state.read.update = function(c2, record) {
          if (!state.read.cipherFunction(record, state.read)) {
            c2.error(c2, {
              message: "Could not decrypt record or bad MAC.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_record_mac
              }
            });
          } else if (!state.read.compressFunction(c2, record, state.read)) {
            c2.error(c2, {
              message: "Could not decompress record.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.decompression_failure
              }
            });
          }
          return !c2.fail;
        };
        state.write.update = function(c2, record) {
          if (!state.write.compressFunction(c2, record, state.write)) {
            c2.error(c2, {
              message: "Could not compress record.",
              send: false,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          } else if (!state.write.cipherFunction(record, state.write)) {
            c2.error(c2, {
              message: "Could not encrypt record.",
              send: false,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
          return !c2.fail;
        };
        if (c.session) {
          var sp = c.session.sp;
          c.session.cipherSuite.initSecurityParameters(sp);
          sp.keys = tls.generateKeys(c, sp);
          state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
          state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
          c.session.cipherSuite.initConnectionState(state, c, sp);
          switch (sp.compression_algorithm) {
            case tls.CompressionMethod.none:
              break;
            case tls.CompressionMethod.deflate:
              state.read.compressFunction = inflate;
              state.write.compressFunction = deflate;
              break;
            default:
              throw new Error("Unsupported compression algorithm.");
          }
        }
        return state;
      };
      tls.createRandom = function() {
        var d = new Date();
        var utc = +d + d.getTimezoneOffset() * 6e4;
        var rval = forge.util.createBuffer();
        rval.putInt32(utc);
        rval.putBytes(forge.random.getBytes(28));
        return rval;
      };
      tls.createRecord = function(c, options) {
        if (!options.data) {
          return null;
        }
        var record = {
          type: options.type,
          version: {
            major: c.version.major,
            minor: c.version.minor
          },
          length: options.data.length(),
          fragment: options.data
        };
        return record;
      };
      tls.createAlert = function(c, alert) {
        var b = forge.util.createBuffer();
        b.putByte(alert.level);
        b.putByte(alert.description);
        return tls.createRecord(c, {
          type: tls.ContentType.alert,
          data: b
        });
      };
      tls.createClientHello = function(c) {
        c.session.clientHelloVersion = {
          major: c.version.major,
          minor: c.version.minor
        };
        var cipherSuites = forge.util.createBuffer();
        for (var i = 0; i < c.cipherSuites.length; ++i) {
          var cs = c.cipherSuites[i];
          cipherSuites.putByte(cs.id[0]);
          cipherSuites.putByte(cs.id[1]);
        }
        var cSuites = cipherSuites.length();
        var compressionMethods = forge.util.createBuffer();
        compressionMethods.putByte(tls.CompressionMethod.none);
        var cMethods = compressionMethods.length();
        var extensions = forge.util.createBuffer();
        if (c.virtualHost) {
          var ext = forge.util.createBuffer();
          ext.putByte(0);
          ext.putByte(0);
          var serverName = forge.util.createBuffer();
          serverName.putByte(0);
          writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
          var snList = forge.util.createBuffer();
          writeVector(snList, 2, serverName);
          writeVector(ext, 2, snList);
          extensions.putBuffer(ext);
        }
        var extLength = extensions.length();
        if (extLength > 0) {
          extLength += 2;
        }
        var sessionId = c.session.id;
        var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + cSuites + 1 + cMethods + extLength;
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.client_hello);
        rval.putInt24(length);
        rval.putByte(c.version.major);
        rval.putByte(c.version.minor);
        rval.putBytes(c.session.sp.client_random);
        writeVector(rval, 1, forge.util.createBuffer(sessionId));
        writeVector(rval, 2, cipherSuites);
        writeVector(rval, 1, compressionMethods);
        if (extLength > 0) {
          writeVector(rval, 2, extensions);
        }
        return rval;
      };
      tls.createServerHello = function(c) {
        var sessionId = c.session.id;
        var length = sessionId.length + 1 + 2 + 4 + 28 + 2 + 1;
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.server_hello);
        rval.putInt24(length);
        rval.putByte(c.version.major);
        rval.putByte(c.version.minor);
        rval.putBytes(c.session.sp.server_random);
        writeVector(rval, 1, forge.util.createBuffer(sessionId));
        rval.putByte(c.session.cipherSuite.id[0]);
        rval.putByte(c.session.cipherSuite.id[1]);
        rval.putByte(c.session.compressionMethod);
        return rval;
      };
      tls.createCertificate = function(c) {
        var client = c.entity === tls.ConnectionEnd.client;
        var cert = null;
        if (c.getCertificate) {
          var hint;
          if (client) {
            hint = c.session.certificateRequest;
          } else {
            hint = c.session.extensions.server_name.serverNameList;
          }
          cert = c.getCertificate(c, hint);
        }
        var certList = forge.util.createBuffer();
        if (cert !== null) {
          try {
            if (!forge.util.isArray(cert)) {
              cert = [cert];
            }
            var asn1 = null;
            for (var i = 0; i < cert.length; ++i) {
              var msg = forge.pem.decode(cert[i])[0];
              if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
                var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
                error.headerType = msg.type;
                throw error;
              }
              if (msg.procType && msg.procType.type === "ENCRYPTED") {
                throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
              }
              var der = forge.util.createBuffer(msg.body);
              if (asn1 === null) {
                asn1 = forge.asn1.fromDer(der.bytes(), false);
              }
              var certBuffer = forge.util.createBuffer();
              writeVector(certBuffer, 3, der);
              certList.putBuffer(certBuffer);
            }
            cert = forge.pki.certificateFromAsn1(asn1);
            if (client) {
              c.session.clientCertificate = cert;
            } else {
              c.session.serverCertificate = cert;
            }
          } catch (ex) {
            return c.error(c, {
              message: "Could not send certificate list.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              }
            });
          }
        }
        var length = 3 + certList.length();
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.certificate);
        rval.putInt24(length);
        writeVector(rval, 3, certList);
        return rval;
      };
      tls.createClientKeyExchange = function(c) {
        var b = forge.util.createBuffer();
        b.putByte(c.session.clientHelloVersion.major);
        b.putByte(c.session.clientHelloVersion.minor);
        b.putBytes(forge.random.getBytes(46));
        var sp = c.session.sp;
        sp.pre_master_secret = b.getBytes();
        var key2 = c.session.serverCertificate.publicKey;
        b = key2.encrypt(sp.pre_master_secret);
        var length = b.length + 2;
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.client_key_exchange);
        rval.putInt24(length);
        rval.putInt16(b.length);
        rval.putBytes(b);
        return rval;
      };
      tls.createServerKeyExchange = function(c) {
        var length = 0;
        var rval = forge.util.createBuffer();
        if (length > 0) {
          rval.putByte(tls.HandshakeType.server_key_exchange);
          rval.putInt24(length);
        }
        return rval;
      };
      tls.getClientSignature = function(c, callback) {
        var b = forge.util.createBuffer();
        b.putBuffer(c.session.md5.digest());
        b.putBuffer(c.session.sha1.digest());
        b = b.getBytes();
        c.getSignature = c.getSignature || function(c2, b2, callback2) {
          var privateKey = null;
          if (c2.getPrivateKey) {
            try {
              privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
              privateKey = forge.pki.privateKeyFromPem(privateKey);
            } catch (ex) {
              c2.error(c2, {
                message: "Could not get private key.",
                cause: ex,
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.internal_error
                }
              });
            }
          }
          if (privateKey === null) {
            c2.error(c2, {
              message: "No private key set.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          } else {
            b2 = privateKey.sign(b2, null);
          }
          callback2(c2, b2);
        };
        c.getSignature(c, b, callback);
      };
      tls.createCertificateVerify = function(c, signature) {
        var length = signature.length + 2;
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.certificate_verify);
        rval.putInt24(length);
        rval.putInt16(signature.length);
        rval.putBytes(signature);
        return rval;
      };
      tls.createCertificateRequest = function(c) {
        var certTypes = forge.util.createBuffer();
        certTypes.putByte(1);
        var cAs = forge.util.createBuffer();
        for (var key2 in c.caStore.certs) {
          var cert = c.caStore.certs[key2];
          var dn = forge.pki.distinguishedNameToAsn1(cert.subject);
          var byteBuffer = forge.asn1.toDer(dn);
          cAs.putInt16(byteBuffer.length());
          cAs.putBuffer(byteBuffer);
        }
        var length = 1 + certTypes.length() + 2 + cAs.length();
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.certificate_request);
        rval.putInt24(length);
        writeVector(rval, 1, certTypes);
        writeVector(rval, 2, cAs);
        return rval;
      };
      tls.createServerHelloDone = function(c) {
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.server_hello_done);
        rval.putInt24(0);
        return rval;
      };
      tls.createChangeCipherSpec = function() {
        var rval = forge.util.createBuffer();
        rval.putByte(1);
        return rval;
      };
      tls.createFinished = function(c) {
        var b = forge.util.createBuffer();
        b.putBuffer(c.session.md5.digest());
        b.putBuffer(c.session.sha1.digest());
        var client = c.entity === tls.ConnectionEnd.client;
        var sp = c.session.sp;
        var vdl = 12;
        var prf = prf_TLS1;
        var label = client ? "client finished" : "server finished";
        b = prf(sp.master_secret, label, b.getBytes(), vdl);
        var rval = forge.util.createBuffer();
        rval.putByte(tls.HandshakeType.finished);
        rval.putInt24(b.length());
        rval.putBuffer(b);
        return rval;
      };
      tls.createHeartbeat = function(type, payload, payloadLength) {
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        var rval = forge.util.createBuffer();
        rval.putByte(type);
        rval.putInt16(payloadLength);
        rval.putBytes(payload);
        var plaintextLength = rval.length();
        var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
        rval.putBytes(forge.random.getBytes(paddingLength));
        return rval;
      };
      tls.queue = function(c, record) {
        if (!record) {
          return;
        }
        if (record.fragment.length() === 0) {
          if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
            return;
          }
        }
        if (record.type === tls.ContentType.handshake) {
          var bytes = record.fragment.bytes();
          c.session.md5.update(bytes);
          c.session.sha1.update(bytes);
          bytes = null;
        }
        var records;
        if (record.fragment.length() <= tls.MaxFragment) {
          records = [record];
        } else {
          records = [];
          var data = record.fragment.bytes();
          while (data.length > tls.MaxFragment) {
            records.push(tls.createRecord(c, {
              type: record.type,
              data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
            }));
            data = data.slice(tls.MaxFragment);
          }
          if (data.length > 0) {
            records.push(tls.createRecord(c, {
              type: record.type,
              data: forge.util.createBuffer(data)
            }));
          }
        }
        for (var i = 0; i < records.length && !c.fail; ++i) {
          var rec = records[i];
          var s = c.state.current.write;
          if (s.update(c, rec)) {
            c.records.push(rec);
          }
        }
      };
      tls.flush = function(c) {
        for (var i = 0; i < c.records.length; ++i) {
          var record = c.records[i];
          c.tlsData.putByte(record.type);
          c.tlsData.putByte(record.version.major);
          c.tlsData.putByte(record.version.minor);
          c.tlsData.putInt16(record.fragment.length());
          c.tlsData.putBuffer(c.records[i].fragment);
        }
        c.records = [];
        return c.tlsDataReady(c);
      };
      var _certErrorToAlertDesc = function(error) {
        switch (error) {
          case true:
            return true;
          case forge.pki.certificateError.bad_certificate:
            return tls.Alert.Description.bad_certificate;
          case forge.pki.certificateError.unsupported_certificate:
            return tls.Alert.Description.unsupported_certificate;
          case forge.pki.certificateError.certificate_revoked:
            return tls.Alert.Description.certificate_revoked;
          case forge.pki.certificateError.certificate_expired:
            return tls.Alert.Description.certificate_expired;
          case forge.pki.certificateError.certificate_unknown:
            return tls.Alert.Description.certificate_unknown;
          case forge.pki.certificateError.unknown_ca:
            return tls.Alert.Description.unknown_ca;
          default:
            return tls.Alert.Description.bad_certificate;
        }
      };
      var _alertDescToCertError = function(desc) {
        switch (desc) {
          case true:
            return true;
          case tls.Alert.Description.bad_certificate:
            return forge.pki.certificateError.bad_certificate;
          case tls.Alert.Description.unsupported_certificate:
            return forge.pki.certificateError.unsupported_certificate;
          case tls.Alert.Description.certificate_revoked:
            return forge.pki.certificateError.certificate_revoked;
          case tls.Alert.Description.certificate_expired:
            return forge.pki.certificateError.certificate_expired;
          case tls.Alert.Description.certificate_unknown:
            return forge.pki.certificateError.certificate_unknown;
          case tls.Alert.Description.unknown_ca:
            return forge.pki.certificateError.unknown_ca;
          default:
            return forge.pki.certificateError.bad_certificate;
        }
      };
      tls.verifyCertificateChain = function(c, chain) {
        try {
          var options = {};
          for (var key2 in c.verifyOptions) {
            options[key2] = c.verifyOptions[key2];
          }
          options.verify = function(vfd, depth, chain2) {
            var desc = _certErrorToAlertDesc(vfd);
            var ret = c.verify(c, vfd, depth, chain2);
            if (ret !== true) {
              if (typeof ret === "object" && !forge.util.isArray(ret)) {
                var error = new Error("The application rejected the certificate.");
                error.send = true;
                error.alert = {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.bad_certificate
                };
                if (ret.message) {
                  error.message = ret.message;
                }
                if (ret.alert) {
                  error.alert.description = ret.alert;
                }
                throw error;
              }
              if (ret !== vfd) {
                ret = _alertDescToCertError(ret);
              }
            }
            return ret;
          };
          forge.pki.verifyCertificateChain(c.caStore, chain, options);
        } catch (ex) {
          var err = ex;
          if (typeof err !== "object" || forge.util.isArray(err)) {
            err = {
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: _certErrorToAlertDesc(ex)
              }
            };
          }
          if (!("send" in err)) {
            err.send = true;
          }
          if (!("alert" in err)) {
            err.alert = {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(err.error)
            };
          }
          c.error(c, err);
        }
        return !c.fail;
      };
      tls.createSessionCache = function(cache, capacity) {
        var rval = null;
        if (cache && cache.getSession && cache.setSession && cache.order) {
          rval = cache;
        } else {
          rval = {};
          rval.cache = cache || {};
          rval.capacity = Math.max(capacity || 100, 1);
          rval.order = [];
          for (var key2 in cache) {
            if (rval.order.length <= capacity) {
              rval.order.push(key2);
            } else {
              delete cache[key2];
            }
          }
          rval.getSession = function(sessionId) {
            var session = null;
            var key3 = null;
            if (sessionId) {
              key3 = forge.util.bytesToHex(sessionId);
            } else if (rval.order.length > 0) {
              key3 = rval.order[0];
            }
            if (key3 !== null && key3 in rval.cache) {
              session = rval.cache[key3];
              delete rval.cache[key3];
              for (var i in rval.order) {
                if (rval.order[i] === key3) {
                  rval.order.splice(i, 1);
                  break;
                }
              }
            }
            return session;
          };
          rval.setSession = function(sessionId, session) {
            if (rval.order.length === rval.capacity) {
              var key3 = rval.order.shift();
              delete rval.cache[key3];
            }
            var key3 = forge.util.bytesToHex(sessionId);
            rval.order.push(key3);
            rval.cache[key3] = session;
          };
        }
        return rval;
      };
      tls.createConnection = function(options) {
        var caStore = null;
        if (options.caStore) {
          if (forge.util.isArray(options.caStore)) {
            caStore = forge.pki.createCaStore(options.caStore);
          } else {
            caStore = options.caStore;
          }
        } else {
          caStore = forge.pki.createCaStore();
        }
        var cipherSuites = options.cipherSuites || null;
        if (cipherSuites === null) {
          cipherSuites = [];
          for (var key2 in tls.CipherSuites) {
            cipherSuites.push(tls.CipherSuites[key2]);
          }
        }
        var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
        var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
        var c = {
          version: { major: tls.Version.major, minor: tls.Version.minor },
          entity,
          sessionId: options.sessionId,
          caStore,
          sessionCache,
          cipherSuites,
          connected: options.connected,
          virtualHost: options.virtualHost || null,
          verifyClient: options.verifyClient || false,
          verify: options.verify || function(cn, vfd, dpth, cts) {
            return vfd;
          },
          verifyOptions: options.verifyOptions || {},
          getCertificate: options.getCertificate || null,
          getPrivateKey: options.getPrivateKey || null,
          getSignature: options.getSignature || null,
          input: forge.util.createBuffer(),
          tlsData: forge.util.createBuffer(),
          data: forge.util.createBuffer(),
          tlsDataReady: options.tlsDataReady,
          dataReady: options.dataReady,
          heartbeatReceived: options.heartbeatReceived,
          closed: options.closed,
          error: function(c2, ex) {
            ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
            if (ex.send) {
              tls.queue(c2, tls.createAlert(c2, ex.alert));
              tls.flush(c2);
            }
            var fatal = ex.fatal !== false;
            if (fatal) {
              c2.fail = true;
            }
            options.error(c2, ex);
            if (fatal) {
              c2.close(false);
            }
          },
          deflate: options.deflate || null,
          inflate: options.inflate || null
        };
        c.reset = function(clearFail) {
          c.version = { major: tls.Version.major, minor: tls.Version.minor };
          c.record = null;
          c.session = null;
          c.peerCertificate = null;
          c.state = {
            pending: null,
            current: null
          };
          c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
          c.fragmented = null;
          c.records = [];
          c.open = false;
          c.handshakes = 0;
          c.handshaking = false;
          c.isConnected = false;
          c.fail = !(clearFail || typeof clearFail === "undefined");
          c.input.clear();
          c.tlsData.clear();
          c.data.clear();
          c.state.current = tls.createConnectionState(c);
        };
        c.reset();
        var _update = function(c2, record) {
          var aligned = record.type - tls.ContentType.change_cipher_spec;
          var handlers = ctTable[c2.entity][c2.expect];
          if (aligned in handlers) {
            handlers[aligned](c2, record);
          } else {
            tls.handleUnexpected(c2, record);
          }
        };
        var _readRecordHeader = function(c2) {
          var rval = 0;
          var b = c2.input;
          var len = b.length();
          if (len < 5) {
            rval = 5 - len;
          } else {
            c2.record = {
              type: b.getByte(),
              version: {
                major: b.getByte(),
                minor: b.getByte()
              },
              length: b.getInt16(),
              fragment: forge.util.createBuffer(),
              ready: false
            };
            var compatibleVersion = c2.record.version.major === c2.version.major;
            if (compatibleVersion && c2.session && c2.session.version) {
              compatibleVersion = c2.record.version.minor === c2.version.minor;
            }
            if (!compatibleVersion) {
              c2.error(c2, {
                message: "Incompatible TLS version.",
                send: true,
                alert: {
                  level: tls.Alert.Level.fatal,
                  description: tls.Alert.Description.protocol_version
                }
              });
            }
          }
          return rval;
        };
        var _readRecord = function(c2) {
          var rval = 0;
          var b = c2.input;
          var len = b.length();
          if (len < c2.record.length) {
            rval = c2.record.length - len;
          } else {
            c2.record.fragment.putBytes(b.getBytes(c2.record.length));
            b.compact();
            var s = c2.state.current.read;
            if (s.update(c2, c2.record)) {
              if (c2.fragmented !== null) {
                if (c2.fragmented.type === c2.record.type) {
                  c2.fragmented.fragment.putBuffer(c2.record.fragment);
                  c2.record = c2.fragmented;
                } else {
                  c2.error(c2, {
                    message: "Invalid fragmented record.",
                    send: true,
                    alert: {
                      level: tls.Alert.Level.fatal,
                      description: tls.Alert.Description.unexpected_message
                    }
                  });
                }
              }
              c2.record.ready = true;
            }
          }
          return rval;
        };
        c.handshake = function(sessionId) {
          if (c.entity !== tls.ConnectionEnd.client) {
            c.error(c, {
              message: "Cannot initiate handshake as a server.",
              fatal: false
            });
          } else if (c.handshaking) {
            c.error(c, {
              message: "Handshake already in progress.",
              fatal: false
            });
          } else {
            if (c.fail && !c.open && c.handshakes === 0) {
              c.fail = false;
            }
            c.handshaking = true;
            sessionId = sessionId || "";
            var session = null;
            if (sessionId.length > 0) {
              if (c.sessionCache) {
                session = c.sessionCache.getSession(sessionId);
              }
              if (session === null) {
                sessionId = "";
              }
            }
            if (sessionId.length === 0 && c.sessionCache) {
              session = c.sessionCache.getSession();
              if (session !== null) {
                sessionId = session.id;
              }
            }
            c.session = {
              id: sessionId,
              version: null,
              cipherSuite: null,
              compressionMethod: null,
              serverCertificate: null,
              certificateRequest: null,
              clientCertificate: null,
              sp: {},
              md5: forge.md.md5.create(),
              sha1: forge.md.sha1.create()
            };
            if (session) {
              c.version = session.version;
              c.session.sp = session.sp;
            }
            c.session.sp.client_random = tls.createRandom().getBytes();
            c.open = true;
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createClientHello(c)
            }));
            tls.flush(c);
          }
        };
        c.process = function(data) {
          var rval = 0;
          if (data) {
            c.input.putBytes(data);
          }
          if (!c.fail) {
            if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
              c.record = null;
            }
            if (c.record === null) {
              rval = _readRecordHeader(c);
            }
            if (!c.fail && c.record !== null && !c.record.ready) {
              rval = _readRecord(c);
            }
            if (!c.fail && c.record !== null && c.record.ready) {
              _update(c, c.record);
            }
          }
          return rval;
        };
        c.prepare = function(data) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.application_data,
            data: forge.util.createBuffer(data)
          }));
          return tls.flush(c);
        };
        c.prepareHeartbeatRequest = function(payload, payloadLength) {
          if (payload instanceof forge.util.ByteBuffer) {
            payload = payload.bytes();
          }
          if (typeof payloadLength === "undefined") {
            payloadLength = payload.length;
          }
          c.expectedHeartbeatPayload = payload;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.heartbeat,
            data: tls.createHeartbeat(tls.HeartbeatMessageType.heartbeat_request, payload, payloadLength)
          }));
          return tls.flush(c);
        };
        c.close = function(clearFail) {
          if (!c.fail && c.sessionCache && c.session) {
            var session = {
              id: c.session.id,
              version: c.session.version,
              sp: c.session.sp
            };
            session.sp.keys = null;
            c.sessionCache.setSession(session.id, session);
          }
          if (c.open) {
            c.open = false;
            c.input.clear();
            if (c.isConnected || c.handshaking) {
              c.isConnected = c.handshaking = false;
              tls.queue(c, tls.createAlert(c, {
                level: tls.Alert.Level.warning,
                description: tls.Alert.Description.close_notify
              }));
              tls.flush(c);
            }
            c.closed(c);
          }
          c.reset(clearFail);
        };
        return c;
      };
      module.exports = forge.tls = forge.tls || {};
      for (key in tls) {
        if (typeof tls[key] !== "function") {
          forge.tls[key] = tls[key];
        }
      }
      var key;
      forge.tls.prf_tls1 = prf_TLS1;
      forge.tls.hmac_sha1 = hmac_sha1;
      forge.tls.createSessionCache = tls.createSessionCache;
      forge.tls.createConnection = tls.createConnection;
    }
  });

  // node_modules/node-forge/lib/aesCipherSuites.js
  var require_aesCipherSuites = __commonJS({
    "node_modules/node-forge/lib/aesCipherSuites.js"(exports, module) {
      var forge = require_forge();
      require_aes();
      require_tls();
      var tls = module.exports = forge.tls;
      tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
        id: [0, 47],
        name: "TLS_RSA_WITH_AES_128_CBC_SHA",
        initSecurityParameters: function(sp) {
          sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
          sp.cipher_type = tls.CipherType.block;
          sp.enc_key_length = 16;
          sp.block_length = 16;
          sp.fixed_iv_length = 16;
          sp.record_iv_length = 16;
          sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
          sp.mac_length = 20;
          sp.mac_key_length = 20;
        },
        initConnectionState
      };
      tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
        id: [0, 53],
        name: "TLS_RSA_WITH_AES_256_CBC_SHA",
        initSecurityParameters: function(sp) {
          sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
          sp.cipher_type = tls.CipherType.block;
          sp.enc_key_length = 32;
          sp.block_length = 16;
          sp.fixed_iv_length = 16;
          sp.record_iv_length = 16;
          sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
          sp.mac_length = 20;
          sp.mac_key_length = 20;
        },
        initConnectionState
      };
      function initConnectionState(state, c, sp) {
        var client = c.entity === forge.tls.ConnectionEnd.client;
        state.read.cipherState = {
          init: false,
          cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
          iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
        };
        state.write.cipherState = {
          init: false,
          cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
          iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
        };
        state.read.cipherFunction = decrypt_aes_cbc_sha1;
        state.write.cipherFunction = encrypt_aes_cbc_sha1;
        state.read.macLength = state.write.macLength = sp.mac_length;
        state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
      }
      function encrypt_aes_cbc_sha1(record, s) {
        var rval = false;
        var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
        record.fragment.putBytes(mac);
        s.updateSequenceNumber();
        var iv;
        if (record.version.minor === tls.Versions.TLS_1_0.minor) {
          iv = s.cipherState.init ? null : s.cipherState.iv;
        } else {
          iv = forge.random.getBytesSync(16);
        }
        s.cipherState.init = true;
        var cipher = s.cipherState.cipher;
        cipher.start({ iv });
        if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
          cipher.output.putBytes(iv);
        }
        cipher.update(record.fragment);
        if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
          record.fragment = cipher.output;
          record.length = record.fragment.length();
          rval = true;
        }
        return rval;
      }
      function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt) {
        if (!decrypt) {
          var padding = blockSize - input.length() % blockSize;
          input.fillWithByte(padding - 1, padding);
        }
        return true;
      }
      function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt) {
        var rval = true;
        if (decrypt) {
          var len = output.length();
          var paddingLength = output.last();
          for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
            rval = rval && output.at(i) == paddingLength;
          }
          if (rval) {
            output.truncate(paddingLength + 1);
          }
        }
        return rval;
      }
      function decrypt_aes_cbc_sha1(record, s) {
        var rval = false;
        var iv;
        if (record.version.minor === tls.Versions.TLS_1_0.minor) {
          iv = s.cipherState.init ? null : s.cipherState.iv;
        } else {
          iv = record.fragment.getBytes(16);
        }
        s.cipherState.init = true;
        var cipher = s.cipherState.cipher;
        cipher.start({ iv });
        cipher.update(record.fragment);
        rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
        var macLen = s.macLength;
        var mac = forge.random.getBytesSync(macLen);
        var len = cipher.output.length();
        if (len >= macLen) {
          record.fragment = cipher.output.getBytes(len - macLen);
          mac = cipher.output.getBytes(macLen);
        } else {
          record.fragment = cipher.output.getBytes();
        }
        record.fragment = forge.util.createBuffer(record.fragment);
        record.length = record.fragment.length();
        var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
        s.updateSequenceNumber();
        rval = compareMacs(s.macKey, mac, mac2) && rval;
        return rval;
      }
      function compareMacs(key, mac1, mac2) {
        var hmac = forge.hmac.create();
        hmac.start("SHA1", key);
        hmac.update(mac1);
        mac1 = hmac.digest().getBytes();
        hmac.start(null, null);
        hmac.update(mac2);
        mac2 = hmac.digest().getBytes();
        return mac1 === mac2;
      }
    }
  });

  // node_modules/node-forge/lib/debug.js
  var require_debug = __commonJS({
    "node_modules/node-forge/lib/debug.js"(exports, module) {
      var forge = require_forge();
      module.exports = forge.debug = forge.debug || {};
      forge.debug.storage = {};
      forge.debug.get = function(cat, name) {
        var rval;
        if (typeof cat === "undefined") {
          rval = forge.debug.storage;
        } else if (cat in forge.debug.storage) {
          if (typeof name === "undefined") {
            rval = forge.debug.storage[cat];
          } else {
            rval = forge.debug.storage[cat][name];
          }
        }
        return rval;
      };
      forge.debug.set = function(cat, name, data) {
        if (!(cat in forge.debug.storage)) {
          forge.debug.storage[cat] = {};
        }
        forge.debug.storage[cat][name] = data;
      };
      forge.debug.clear = function(cat, name) {
        if (typeof cat === "undefined") {
          forge.debug.storage = {};
        } else if (cat in forge.debug.storage) {
          if (typeof name === "undefined") {
            delete forge.debug.storage[cat];
          } else {
            delete forge.debug.storage[cat][name];
          }
        }
      };
    }
  });

  // node_modules/node-forge/lib/sha512.js
  var require_sha512 = __commonJS({
    "node_modules/node-forge/lib/sha512.js"(exports, module) {
      var forge = require_forge();
      require_md();
      require_util4();
      var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
      forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
      var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
      sha384.create = function() {
        return sha512.create("SHA-384");
      };
      forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
      forge.sha512.sha256 = forge.sha512.sha256 || {
        create: function() {
          return sha512.create("SHA-512/256");
        }
      };
      forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
      forge.sha512.sha224 = forge.sha512.sha224 || {
        create: function() {
          return sha512.create("SHA-512/224");
        }
      };
      forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
      sha512.create = function(algorithm) {
        if (!_initialized) {
          _init();
        }
        if (typeof algorithm === "undefined") {
          algorithm = "SHA-512";
        }
        if (!(algorithm in _states)) {
          throw new Error("Invalid SHA-512 algorithm: " + algorithm);
        }
        var _state = _states[algorithm];
        var _h = null;
        var _input = forge.util.createBuffer();
        var _w = new Array(80);
        for (var wi = 0; wi < 80; ++wi) {
          _w[wi] = new Array(2);
        }
        var digestLength = 64;
        switch (algorithm) {
          case "SHA-384":
            digestLength = 48;
            break;
          case "SHA-512/256":
            digestLength = 32;
            break;
          case "SHA-512/224":
            digestLength = 28;
            break;
        }
        var md = {
          algorithm: algorithm.replace("-", "").toLowerCase(),
          blockLength: 128,
          digestLength,
          messageLength: 0,
          fullMessageLength: null,
          messageLengthSize: 16
        };
        md.start = function() {
          md.messageLength = 0;
          md.fullMessageLength = md.messageLength128 = [];
          var int32s = md.messageLengthSize / 4;
          for (var i = 0; i < int32s; ++i) {
            md.fullMessageLength.push(0);
          }
          _input = forge.util.createBuffer();
          _h = new Array(_state.length);
          for (var i = 0; i < _state.length; ++i) {
            _h[i] = _state[i].slice(0);
          }
          return md;
        };
        md.start();
        md.update = function(msg, encoding) {
          if (encoding === "utf8") {
            msg = forge.util.encodeUtf8(msg);
          }
          var len = msg.length;
          md.messageLength += len;
          len = [len / 4294967296 >>> 0, len >>> 0];
          for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
            md.fullMessageLength[i] += len[1];
            len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
            md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
            len[0] = len[1] / 4294967296 >>> 0;
          }
          _input.putBytes(msg);
          _update(_h, _w, _input);
          if (_input.read > 2048 || _input.length() === 0) {
            _input.compact();
          }
          return md;
        };
        md.digest = function() {
          var finalBlock = forge.util.createBuffer();
          finalBlock.putBytes(_input.bytes());
          var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
          var overflow = remaining & md.blockLength - 1;
          finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
          var next, carry;
          var bits = md.fullMessageLength[0] * 8;
          for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
            next = md.fullMessageLength[i + 1] * 8;
            carry = next / 4294967296 >>> 0;
            bits += carry;
            finalBlock.putInt32(bits >>> 0);
            bits = next >>> 0;
          }
          finalBlock.putInt32(bits);
          var h = new Array(_h.length);
          for (var i = 0; i < _h.length; ++i) {
            h[i] = _h[i].slice(0);
          }
          _update(h, _w, finalBlock);
          var rval = forge.util.createBuffer();
          var hlen;
          if (algorithm === "SHA-512") {
            hlen = h.length;
          } else if (algorithm === "SHA-384") {
            hlen = h.length - 2;
          } else {
            hlen = h.length - 4;
          }
          for (var i = 0; i < hlen; ++i) {
            rval.putInt32(h[i][0]);
            if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
              rval.putInt32(h[i][1]);
            }
          }
          return rval;
        };
        return md;
      };
      var _padding = null;
      var _initialized = false;
      var _k = null;
      var _states = null;
      function _init() {
        _padding = String.fromCharCode(128);
        _padding += forge.util.fillString(String.fromCharCode(0), 128);
        _k = [
          [1116352408, 3609767458],
          [1899447441, 602891725],
          [3049323471, 3964484399],
          [3921009573, 2173295548],
          [961987163, 4081628472],
          [1508970993, 3053834265],
          [2453635748, 2937671579],
          [2870763221, 3664609560],
          [3624381080, 2734883394],
          [310598401, 1164996542],
          [607225278, 1323610764],
          [1426881987, 3590304994],
          [1925078388, 4068182383],
          [2162078206, 991336113],
          [2614888103, 633803317],
          [3248222580, 3479774868],
          [3835390401, 2666613458],
          [4022224774, 944711139],
          [264347078, 2341262773],
          [604807628, 2007800933],
          [770255983, 1495990901],
          [1249150122, 1856431235],
          [1555081692, 3175218132],
          [1996064986, 2198950837],
          [2554220882, 3999719339],
          [2821834349, 766784016],
          [2952996808, 2566594879],
          [3210313671, 3203337956],
          [3336571891, 1034457026],
          [3584528711, 2466948901],
          [113926993, 3758326383],
          [338241895, 168717936],
          [666307205, 1188179964],
          [773529912, 1546045734],
          [1294757372, 1522805485],
          [1396182291, 2643833823],
          [1695183700, 2343527390],
          [1986661051, 1014477480],
          [2177026350, 1206759142],
          [2456956037, 344077627],
          [2730485921, 1290863460],
          [2820302411, 3158454273],
          [3259730800, 3505952657],
          [3345764771, 106217008],
          [3516065817, 3606008344],
          [3600352804, 1432725776],
          [4094571909, 1467031594],
          [275423344, 851169720],
          [430227734, 3100823752],
          [506948616, 1363258195],
          [659060556, 3750685593],
          [883997877, 3785050280],
          [958139571, 3318307427],
          [1322822218, 3812723403],
          [1537002063, 2003034995],
          [1747873779, 3602036899],
          [1955562222, 1575990012],
          [2024104815, 1125592928],
          [2227730452, 2716904306],
          [2361852424, 442776044],
          [2428436474, 593698344],
          [2756734187, 3733110249],
          [3204031479, 2999351573],
          [3329325298, 3815920427],
          [3391569614, 3928383900],
          [3515267271, 566280711],
          [3940187606, 3454069534],
          [4118630271, 4000239992],
          [116418474, 1914138554],
          [174292421, 2731055270],
          [289380356, 3203993006],
          [460393269, 320620315],
          [685471733, 587496836],
          [852142971, 1086792851],
          [1017036298, 365543100],
          [1126000580, 2618297676],
          [1288033470, 3409855158],
          [1501505948, 4234509866],
          [1607167915, 987167468],
          [1816402316, 1246189591]
        ];
        _states = {};
        _states["SHA-512"] = [
          [1779033703, 4089235720],
          [3144134277, 2227873595],
          [1013904242, 4271175723],
          [2773480762, 1595750129],
          [1359893119, 2917565137],
          [2600822924, 725511199],
          [528734635, 4215389547],
          [1541459225, 327033209]
        ];
        _states["SHA-384"] = [
          [3418070365, 3238371032],
          [1654270250, 914150663],
          [2438529370, 812702999],
          [355462360, 4144912697],
          [1731405415, 4290775857],
          [2394180231, 1750603025],
          [3675008525, 1694076839],
          [1203062813, 3204075428]
        ];
        _states["SHA-512/256"] = [
          [573645204, 4230739756],
          [2673172387, 3360449730],
          [596883563, 1867755857],
          [2520282905, 1497426621],
          [2519219938, 2827943907],
          [3193839141, 1401305490],
          [721525244, 746961066],
          [246885852, 2177182882]
        ];
        _states["SHA-512/224"] = [
          [2352822216, 424955298],
          [1944164710, 2312950998],
          [502970286, 855612546],
          [1738396948, 1479516111],
          [258812777, 2077511080],
          [2011393907, 79989058],
          [1067287976, 1780299464],
          [286451373, 2446758561]
        ];
        _initialized = true;
      }
      function _update(s, w, bytes) {
        var t1_hi, t1_lo;
        var t2_hi, t2_lo;
        var s0_hi, s0_lo;
        var s1_hi, s1_lo;
        var ch_hi, ch_lo;
        var maj_hi, maj_lo;
        var a_hi, a_lo;
        var b_hi, b_lo;
        var c_hi, c_lo;
        var d_hi, d_lo;
        var e_hi, e_lo;
        var f_hi, f_lo;
        var g_hi, g_lo;
        var h_hi, h_lo;
        var i, hi, lo, w2, w7, w15, w16;
        var len = bytes.length();
        while (len >= 128) {
          for (i = 0; i < 16; ++i) {
            w[i][0] = bytes.getInt32() >>> 0;
            w[i][1] = bytes.getInt32() >>> 0;
          }
          for (; i < 80; ++i) {
            w2 = w[i - 2];
            hi = w2[0];
            lo = w2[1];
            t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
            t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
            w15 = w[i - 15];
            hi = w15[0];
            lo = w15[1];
            t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
            t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
            w7 = w[i - 7];
            w16 = w[i - 16];
            lo = t1_lo + w7[1] + t2_lo + w16[1];
            w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
            w[i][1] = lo >>> 0;
          }
          a_hi = s[0][0];
          a_lo = s[0][1];
          b_hi = s[1][0];
          b_lo = s[1][1];
          c_hi = s[2][0];
          c_lo = s[2][1];
          d_hi = s[3][0];
          d_lo = s[3][1];
          e_hi = s[4][0];
          e_lo = s[4][1];
          f_hi = s[5][0];
          f_lo = s[5][1];
          g_hi = s[6][0];
          g_lo = s[6][1];
          h_hi = s[7][0];
          h_lo = s[7][1];
          for (i = 0; i < 80; ++i) {
            s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
            s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
            ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
            ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
            s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
            s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
            maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
            maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
            lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
            t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
            t1_lo = lo >>> 0;
            lo = s0_lo + maj_lo;
            t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
            t2_lo = lo >>> 0;
            h_hi = g_hi;
            h_lo = g_lo;
            g_hi = f_hi;
            g_lo = f_lo;
            f_hi = e_hi;
            f_lo = e_lo;
            lo = d_lo + t1_lo;
            e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
            e_lo = lo >>> 0;
            d_hi = c_hi;
            d_lo = c_lo;
            c_hi = b_hi;
            c_lo = b_lo;
            b_hi = a_hi;
            b_lo = a_lo;
            lo = t1_lo + t2_lo;
            a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
            a_lo = lo >>> 0;
          }
          lo = s[0][1] + a_lo;
          s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[0][1] = lo >>> 0;
          lo = s[1][1] + b_lo;
          s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[1][1] = lo >>> 0;
          lo = s[2][1] + c_lo;
          s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[2][1] = lo >>> 0;
          lo = s[3][1] + d_lo;
          s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[3][1] = lo >>> 0;
          lo = s[4][1] + e_lo;
          s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[4][1] = lo >>> 0;
          lo = s[5][1] + f_lo;
          s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[5][1] = lo >>> 0;
          lo = s[6][1] + g_lo;
          s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[6][1] = lo >>> 0;
          lo = s[7][1] + h_lo;
          s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
          s[7][1] = lo >>> 0;
          len -= 128;
        }
      }
    }
  });

  // node_modules/node-forge/lib/asn1-validator.js
  var require_asn1_validator = __commonJS({
    "node_modules/node-forge/lib/asn1-validator.js"(exports) {
      var forge = require_forge();
      require_asn1();
      var asn1 = forge.asn1;
      exports.privateKeyValidator = {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PrivateKeyInfo.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "privateKeyVersion"
        }, {
          name: "PrivateKeyInfo.privateKeyAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "privateKeyOid"
          }]
        }, {
          name: "PrivateKeyInfo",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "privateKey"
        }]
      };
      exports.publicKeyValidator = {
        name: "SubjectPublicKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "subjectPublicKeyInfo",
        value: [
          {
            name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "AlgorithmIdentifier.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "publicKeyOid"
            }]
          },
          {
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            composed: true,
            captureBitStringValue: "ed25519PublicKey"
          }
        ]
      };
    }
  });

  // node_modules/node-forge/lib/ed25519.js
  var require_ed25519 = __commonJS({
    "node_modules/node-forge/lib/ed25519.js"(exports, module) {
      var forge = require_forge();
      require_jsbn();
      require_random();
      require_sha512();
      require_util4();
      var asn1Validator = require_asn1_validator();
      var publicKeyValidator = asn1Validator.publicKeyValidator;
      var privateKeyValidator = asn1Validator.privateKeyValidator;
      if (typeof BigInteger === "undefined") {
        BigInteger = forge.jsbn.BigInteger;
      }
      var BigInteger;
      var ByteBuffer = forge.util.ByteBuffer;
      var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
      forge.pki = forge.pki || {};
      module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
      var ed25519 = forge.ed25519;
      ed25519.constants = {};
      ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
      ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
      ed25519.constants.SEED_BYTE_LENGTH = 32;
      ed25519.constants.SIGN_BYTE_LENGTH = 64;
      ed25519.constants.HASH_BYTE_LENGTH = 64;
      ed25519.generateKeyPair = function(options) {
        options = options || {};
        var seed = options.seed;
        if (seed === void 0) {
          seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
        } else if (typeof seed === "string") {
          if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
            throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
          }
        } else if (!(seed instanceof Uint8Array)) {
          throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
        }
        seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
        var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
        var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
        for (var i = 0; i < 32; ++i) {
          sk[i] = seed[i];
        }
        crypto_sign_keypair(pk, sk);
        return { publicKey: pk, privateKey: sk };
      };
      ed25519.privateKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
        if (!valid) {
          var error = new Error("Invalid Key.");
          error.errors = errors;
          throw error;
        }
        var oid = forge.asn1.derToOid(capture.privateKeyOid);
        var ed25519Oid = forge.oids.EdDSA25519;
        if (oid !== ed25519Oid) {
          throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
        }
        var privateKey = capture.privateKey;
        var privateKeyBytes = messageToNativeBuffer({
          message: forge.asn1.fromDer(privateKey).value,
          encoding: "binary"
        });
        return { privateKeyBytes };
      };
      ed25519.publicKeyFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
        if (!valid) {
          var error = new Error("Invalid Key.");
          error.errors = errors;
          throw error;
        }
        var oid = forge.asn1.derToOid(capture.publicKeyOid);
        var ed25519Oid = forge.oids.EdDSA25519;
        if (oid !== ed25519Oid) {
          throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
        }
        var publicKeyBytes = capture.ed25519PublicKey;
        if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
          throw new Error("Key length is invalid.");
        }
        return messageToNativeBuffer({
          message: publicKeyBytes,
          encoding: "binary"
        });
      };
      ed25519.publicKeyFromPrivateKey = function(options) {
        options = options || {};
        var privateKey = messageToNativeBuffer({
          message: options.privateKey,
          encoding: "binary"
        });
        if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
          throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
        }
        var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
        for (var i = 0; i < pk.length; ++i) {
          pk[i] = privateKey[32 + i];
        }
        return pk;
      };
      ed25519.sign = function(options) {
        options = options || {};
        var msg = messageToNativeBuffer(options);
        var privateKey = messageToNativeBuffer({
          message: options.privateKey,
          encoding: "binary"
        });
        if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
          var keyPair = ed25519.generateKeyPair({ seed: privateKey });
          privateKey = keyPair.privateKey;
        } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
          throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
        }
        var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
        crypto_sign(signedMsg, msg, msg.length, privateKey);
        var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
        for (var i = 0; i < sig.length; ++i) {
          sig[i] = signedMsg[i];
        }
        return sig;
      };
      ed25519.verify = function(options) {
        options = options || {};
        var msg = messageToNativeBuffer(options);
        if (options.signature === void 0) {
          throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
        }
        var sig = messageToNativeBuffer({
          message: options.signature,
          encoding: "binary"
        });
        if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
          throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
        }
        var publicKey = messageToNativeBuffer({
          message: options.publicKey,
          encoding: "binary"
        });
        if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
          throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
        }
        var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
        var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
        var i;
        for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
          sm[i] = sig[i];
        }
        for (i = 0; i < msg.length; ++i) {
          sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
        }
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      function messageToNativeBuffer(options) {
        var message = options.message;
        if (message instanceof Uint8Array || message instanceof NativeBuffer) {
          return message;
        }
        var encoding = options.encoding;
        if (message === void 0) {
          if (options.md) {
            message = options.md.digest().getBytes();
            encoding = "binary";
          } else {
            throw new TypeError('"options.message" or "options.md" not specified.');
          }
        }
        if (typeof message === "string" && !encoding) {
          throw new TypeError('"options.encoding" must be "binary" or "utf8".');
        }
        if (typeof message === "string") {
          if (typeof Buffer !== "undefined") {
            return Buffer.from(message, encoding);
          }
          message = new ByteBuffer(message, encoding);
        } else if (!(message instanceof ByteBuffer)) {
          throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
        }
        var buffer = new NativeBuffer(message.length());
        for (var i = 0; i < buffer.length; ++i) {
          buffer[i] = message.at(i);
        }
        return buffer;
      }
      var gf0 = gf();
      var gf1 = gf([1]);
      var D = gf([
        30883,
        4953,
        19914,
        30187,
        55467,
        16705,
        2637,
        112,
        59544,
        30585,
        16505,
        36039,
        65139,
        11119,
        27886,
        20995
      ]);
      var D2 = gf([
        61785,
        9906,
        39828,
        60374,
        45398,
        33411,
        5274,
        224,
        53552,
        61171,
        33010,
        6542,
        64743,
        22239,
        55772,
        9222
      ]);
      var X = gf([
        54554,
        36645,
        11616,
        51542,
        42930,
        38181,
        51040,
        26924,
        56412,
        64982,
        57905,
        49316,
        21502,
        52590,
        14035,
        8553
      ]);
      var Y = gf([
        26200,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214
      ]);
      var L = new Float64Array([
        237,
        211,
        245,
        92,
        26,
        99,
        18,
        88,
        214,
        156,
        247,
        162,
        222,
        249,
        222,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16
      ]);
      var I = gf([
        41136,
        18958,
        6951,
        50414,
        58488,
        44335,
        6150,
        12099,
        55207,
        15867,
        153,
        11085,
        57099,
        20417,
        9344,
        11139
      ]);
      function sha512(msg, msgLen) {
        var md = forge.md.sha512.create();
        var buffer = new ByteBuffer(msg);
        md.update(buffer.getBytes(msgLen), "binary");
        var hash = md.digest().getBytes();
        if (typeof Buffer !== "undefined") {
          return Buffer.from(hash, "binary");
        }
        var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
        for (var i = 0; i < 64; ++i) {
          out[i] = hash.charCodeAt(i);
        }
        return out;
      }
      function crypto_sign_keypair(pk, sk) {
        var p = [gf(), gf(), gf(), gf()];
        var i;
        var d = sha512(sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; ++i) {
          sk[i + 32] = pk[i];
        }
        return 0;
      }
      function crypto_sign(sm, m, n, sk) {
        var i, j, x = new Float64Array(64);
        var p = [gf(), gf(), gf(), gf()];
        var d = sha512(sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; ++i) {
          sm[64 + i] = m[i];
        }
        for (i = 0; i < 32; ++i) {
          sm[32 + i] = d[32 + i];
        }
        var r = sha512(sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; ++i) {
          sm[i] = sk[i];
        }
        var h = sha512(sm, n + 64);
        reduce(h);
        for (i = 32; i < 64; ++i) {
          x[i] = 0;
        }
        for (i = 0; i < 32; ++i) {
          x[i] = r[i];
        }
        for (i = 0; i < 32; ++i) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new NativeBuffer(32);
        var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
        mlen = -1;
        if (n < 64) {
          return -1;
        }
        if (unpackneg(q, pk)) {
          return -1;
        }
        for (i = 0; i < n; ++i) {
          m[i] = sm[i];
        }
        for (i = 0; i < 32; ++i) {
          m[i + 32] = pk[i];
        }
        var h = sha512(m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; ++i) {
            m[i] = 0;
          }
          return -1;
        }
        for (i = 0; i < n; ++i) {
          m[i] = sm[i + 64];
        }
        mlen = n;
        return mlen;
      }
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; ++j) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; ++j) {
          x[j] -= carry * L[j];
        }
        for (i = 0; i < 32; ++i) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      function reduce(r) {
        var x = new Float64Array(64);
        for (var i = 0; i < 64; ++i) {
          x[i] = r[i];
          r[i] = 0;
        }
        modL(r, x);
      }
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      function cswap(p, q, b) {
        for (var i = 0; i < 4; ++i) {
          sel25519(p[i], q[i], b);
        }
      }
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; ++i) {
          t[i] = n[i];
        }
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; ++j) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; ++i) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) {
          M(r[0], r[0], I);
        }
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) {
          return -1;
        }
        if (par25519(r[0]) === p[31] >> 7) {
          Z(r[0], gf0, r[0]);
        }
        M(r[3], r[0], r[1]);
        return 0;
      }
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; ++i) {
          o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        }
        o[15] &= 32767;
      }
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; ++a) {
          c[a] = i[a];
        }
        for (a = 250; a >= 0; --a) {
          S(c, c);
          if (a !== 1) {
            M(c, c, i);
          }
        }
        for (a = 0; a < 16; ++a) {
          o[a] = c[a];
        }
      }
      function neq25519(a, b) {
        var c = new NativeBuffer(32);
        var d = new NativeBuffer(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; ++i) {
          d |= x[xi + i] ^ y[yi + i];
        }
        return (1 & d - 1 >>> 8) - 1;
      }
      function par25519(a) {
        var d = new NativeBuffer(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      function scalarbase(p, s) {
        var q = [gf(), gf(), gf(), gf()];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) {
          r[i] = a[i] | 0;
        }
      }
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; ++a) {
          c[a] = i[a];
        }
        for (a = 253; a >= 0; --a) {
          S(c, c);
          if (a !== 2 && a !== 4) {
            M(c, c, i);
          }
        }
        for (a = 0; a < 16; ++a) {
          o[a] = c[a];
        }
      }
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; ++i) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; ++i) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      function gf(init) {
        var i, r = new Float64Array(16);
        if (init) {
          for (i = 0; i < init.length; ++i) {
            r[i] = init[i];
          }
        }
        return r;
      }
      function A(o, a, b) {
        for (var i = 0; i < 16; ++i) {
          o[i] = a[i] + b[i];
        }
      }
      function Z(o, a, b) {
        for (var i = 0; i < 16; ++i) {
          o[i] = a[i] - b[i];
        }
      }
      function S(o, a) {
        M(o, a, a);
      }
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
    }
  });

  // node_modules/node-forge/lib/kem.js
  var require_kem = __commonJS({
    "node_modules/node-forge/lib/kem.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      require_random();
      require_jsbn();
      module.exports = forge.kem = forge.kem || {};
      var BigInteger = forge.jsbn.BigInteger;
      forge.kem.rsa = {};
      forge.kem.rsa.create = function(kdf, options) {
        options = options || {};
        var prng = options.prng || forge.random;
        var kem = {};
        kem.encrypt = function(publicKey, keyLength) {
          var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
          var r;
          do {
            r = new BigInteger(forge.util.bytesToHex(prng.getBytesSync(byteLength)), 16).mod(publicKey.n);
          } while (r.compareTo(BigInteger.ONE) <= 0);
          r = forge.util.hexToBytes(r.toString(16));
          var zeros = byteLength - r.length;
          if (zeros > 0) {
            r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
          }
          var encapsulation = publicKey.encrypt(r, "NONE");
          var key = kdf.generate(r, keyLength);
          return { encapsulation, key };
        };
        kem.decrypt = function(privateKey, encapsulation, keyLength) {
          var r = privateKey.decrypt(encapsulation, "NONE");
          return kdf.generate(r, keyLength);
        };
        return kem;
      };
      forge.kem.kdf1 = function(md, digestLength) {
        _createKDF(this, md, 0, digestLength || md.digestLength);
      };
      forge.kem.kdf2 = function(md, digestLength) {
        _createKDF(this, md, 1, digestLength || md.digestLength);
      };
      function _createKDF(kdf, md, counterStart, digestLength) {
        kdf.generate = function(x, length) {
          var key = new forge.util.ByteBuffer();
          var k = Math.ceil(length / digestLength) + counterStart;
          var c = new forge.util.ByteBuffer();
          for (var i = counterStart; i < k; ++i) {
            c.putInt32(i);
            md.start();
            md.update(x + c.getBytes());
            var hash = md.digest();
            key.putBytes(hash.getBytes(digestLength));
          }
          key.truncate(key.length() - length);
          return key.getBytes();
        };
      }
    }
  });

  // node_modules/node-forge/lib/log.js
  var require_log = __commonJS({
    "node_modules/node-forge/lib/log.js"(exports, module) {
      var forge = require_forge();
      require_util4();
      module.exports = forge.log = forge.log || {};
      forge.log.levels = [
        "none",
        "error",
        "warning",
        "info",
        "debug",
        "verbose",
        "max"
      ];
      var sLevelInfo = {};
      var sLoggers = [];
      var sConsoleLogger = null;
      forge.log.LEVEL_LOCKED = 1 << 1;
      forge.log.NO_LEVEL_CHECK = 1 << 2;
      forge.log.INTERPOLATE = 1 << 3;
      for (i = 0; i < forge.log.levels.length; ++i) {
        level = forge.log.levels[i];
        sLevelInfo[level] = {
          index: i,
          name: level.toUpperCase()
        };
      }
      var level;
      var i;
      forge.log.logMessage = function(message) {
        var messageLevelIndex = sLevelInfo[message.level].index;
        for (var i2 = 0; i2 < sLoggers.length; ++i2) {
          var logger2 = sLoggers[i2];
          if (logger2.flags & forge.log.NO_LEVEL_CHECK) {
            logger2.f(message);
          } else {
            var loggerLevelIndex = sLevelInfo[logger2.level].index;
            if (messageLevelIndex <= loggerLevelIndex) {
              logger2.f(logger2, message);
            }
          }
        }
      };
      forge.log.prepareStandard = function(message) {
        if (!("standard" in message)) {
          message.standard = sLevelInfo[message.level].name + " [" + message.category + "] " + message.message;
        }
      };
      forge.log.prepareFull = function(message) {
        if (!("full" in message)) {
          var args = [message.message];
          args = args.concat([]);
          message.full = forge.util.format.apply(this, args);
        }
      };
      forge.log.prepareStandardFull = function(message) {
        if (!("standardFull" in message)) {
          forge.log.prepareStandard(message);
          message.standardFull = message.standard;
        }
      };
      if (true) {
        levels = ["error", "warning", "info", "debug", "verbose"];
        for (i = 0; i < levels.length; ++i) {
          (function(level2) {
            forge.log[level2] = function(category, message) {
              var args = Array.prototype.slice.call(arguments).slice(2);
              var msg = {
                timestamp: new Date(),
                level: level2,
                category,
                message,
                "arguments": args
              };
              forge.log.logMessage(msg);
            };
          })(levels[i]);
        }
      }
      var levels;
      var i;
      forge.log.makeLogger = function(logFunction) {
        var logger2 = {
          flags: 0,
          f: logFunction
        };
        forge.log.setLevel(logger2, "none");
        return logger2;
      };
      forge.log.setLevel = function(logger2, level2) {
        var rval = false;
        if (logger2 && !(logger2.flags & forge.log.LEVEL_LOCKED)) {
          for (var i2 = 0; i2 < forge.log.levels.length; ++i2) {
            var aValidLevel = forge.log.levels[i2];
            if (level2 == aValidLevel) {
              logger2.level = level2;
              rval = true;
              break;
            }
          }
        }
        return rval;
      };
      forge.log.lock = function(logger2, lock2) {
        if (typeof lock2 === "undefined" || lock2) {
          logger2.flags |= forge.log.LEVEL_LOCKED;
        } else {
          logger2.flags &= ~forge.log.LEVEL_LOCKED;
        }
      };
      forge.log.addLogger = function(logger2) {
        sLoggers.push(logger2);
      };
      if (typeof console !== "undefined" && "log" in console) {
        if (console.error && console.warn && console.info && console.debug) {
          levelHandlers = {
            error: console.error,
            warning: console.warn,
            info: console.info,
            debug: console.debug,
            verbose: console.debug
          };
          f = function(logger2, message) {
            forge.log.prepareStandard(message);
            var handler = levelHandlers[message.level];
            var args = [message.standard];
            args = args.concat(message["arguments"].slice());
            handler.apply(console, args);
          };
          logger = forge.log.makeLogger(f);
        } else {
          f = function(logger2, message) {
            forge.log.prepareStandardFull(message);
            console.log(message.standardFull);
          };
          logger = forge.log.makeLogger(f);
        }
        forge.log.setLevel(logger, "debug");
        forge.log.addLogger(logger);
        sConsoleLogger = logger;
      } else {
        console = {
          log: function() {
          }
        };
      }
      var logger;
      var levelHandlers;
      var f;
      if (sConsoleLogger !== null) {
        query = forge.util.getQueryVariables();
        if ("console.level" in query) {
          forge.log.setLevel(sConsoleLogger, query["console.level"].slice(-1)[0]);
        }
        if ("console.lock" in query) {
          lock = query["console.lock"].slice(-1)[0];
          if (lock == "true") {
            forge.log.lock(sConsoleLogger);
          }
        }
      }
      var query;
      var lock;
      forge.log.consoleLogger = sConsoleLogger;
    }
  });

  // node_modules/node-forge/lib/md.all.js
  var require_md_all = __commonJS({
    "node_modules/node-forge/lib/md.all.js"(exports, module) {
      module.exports = require_md();
      require_md5();
      require_sha1();
      require_sha256();
      require_sha512();
    }
  });

  // node_modules/node-forge/lib/pkcs7.js
  var require_pkcs7 = __commonJS({
    "node_modules/node-forge/lib/pkcs7.js"(exports, module) {
      var forge = require_forge();
      require_aes();
      require_asn1();
      require_des();
      require_oids();
      require_pem();
      require_pkcs7asn1();
      require_random();
      require_util4();
      require_x509();
      var asn1 = forge.asn1;
      var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
      p7.messageFromPem = function(pem) {
        var msg = forge.pem.decode(pem)[0];
        if (msg.type !== "PKCS7") {
          var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
          error.headerType = msg.type;
          throw error;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
        }
        var obj = asn1.fromDer(msg.body);
        return p7.messageFromAsn1(obj);
      };
      p7.messageToPem = function(msg, maxline) {
        var pemObj = {
          type: "PKCS7",
          body: asn1.toDer(msg.toAsn1()).getBytes()
        };
        return forge.pem.encode(pemObj, { maxline });
      };
      p7.messageFromAsn1 = function(obj) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
          error.errors = errors;
          throw error;
        }
        var contentType = asn1.derToOid(capture.contentType);
        var msg;
        switch (contentType) {
          case forge.pki.oids.envelopedData:
            msg = p7.createEnvelopedData();
            break;
          case forge.pki.oids.encryptedData:
            msg = p7.createEncryptedData();
            break;
          case forge.pki.oids.signedData:
            msg = p7.createSignedData();
            break;
          default:
            throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
        }
        msg.fromAsn1(capture.content.value[0]);
        return msg;
      };
      p7.createSignedData = function() {
        var msg = null;
        msg = {
          type: forge.pki.oids.signedData,
          version: 1,
          certificates: [],
          crls: [],
          signers: [],
          digestAlgorithmIdentifiers: [],
          contentInfo: null,
          signerInfos: [],
          fromAsn1: function(obj) {
            _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
            msg.certificates = [];
            msg.crls = [];
            msg.digestAlgorithmIdentifiers = [];
            msg.contentInfo = null;
            msg.signerInfos = [];
            if (msg.rawCapture.certificates) {
              var certs = msg.rawCapture.certificates.value;
              for (var i = 0; i < certs.length; ++i) {
                msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
              }
            }
          },
          toAsn1: function() {
            if (!msg.contentInfo) {
              msg.sign();
            }
            var certs = [];
            for (var i = 0; i < msg.certificates.length; ++i) {
              certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
            }
            var crls = [];
            var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
                msg.contentInfo
              ])
            ]);
            if (certs.length > 0) {
              signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
            }
            if (crls.length > 0) {
              signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
            }
            signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
              signedData
            ]);
          },
          addSigner: function(signer) {
            var issuer = signer.issuer;
            var serialNumber = signer.serialNumber;
            if (signer.certificate) {
              var cert = signer.certificate;
              if (typeof cert === "string") {
                cert = forge.pki.certificateFromPem(cert);
              }
              issuer = cert.issuer.attributes;
              serialNumber = cert.serialNumber;
            }
            var key = signer.key;
            if (!key) {
              throw new Error("Could not add PKCS#7 signer; no private key specified.");
            }
            if (typeof key === "string") {
              key = forge.pki.privateKeyFromPem(key);
            }
            var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
            switch (digestAlgorithm) {
              case forge.pki.oids.sha1:
              case forge.pki.oids.sha256:
              case forge.pki.oids.sha384:
              case forge.pki.oids.sha512:
              case forge.pki.oids.md5:
                break;
              default:
                throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
            }
            var authenticatedAttributes = signer.authenticatedAttributes || [];
            if (authenticatedAttributes.length > 0) {
              var contentType = false;
              var messageDigest = false;
              for (var i = 0; i < authenticatedAttributes.length; ++i) {
                var attr = authenticatedAttributes[i];
                if (!contentType && attr.type === forge.pki.oids.contentType) {
                  contentType = true;
                  if (messageDigest) {
                    break;
                  }
                  continue;
                }
                if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                  messageDigest = true;
                  if (contentType) {
                    break;
                  }
                  continue;
                }
              }
              if (!contentType || !messageDigest) {
                throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
              }
            }
            msg.signers.push({
              key,
              version: 1,
              issuer,
              serialNumber,
              digestAlgorithm,
              signatureAlgorithm: forge.pki.oids.rsaEncryption,
              signature: null,
              authenticatedAttributes,
              unauthenticatedAttributes: []
            });
          },
          sign: function(options) {
            options = options || {};
            if (typeof msg.content !== "object" || msg.contentInfo === null) {
              msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())
              ]);
              if ("content" in msg) {
                var content;
                if (msg.content instanceof forge.util.ByteBuffer) {
                  content = msg.content.bytes();
                } else if (typeof msg.content === "string") {
                  content = forge.util.encodeUtf8(msg.content);
                }
                if (options.detached) {
                  msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
                } else {
                  msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)
                  ]));
                }
              }
            }
            if (msg.signers.length === 0) {
              return;
            }
            var mds = addDigestAlgorithmIds();
            addSignerInfos(mds);
          },
          verify: function() {
            throw new Error("PKCS#7 signature verification not yet implemented.");
          },
          addCertificate: function(cert) {
            if (typeof cert === "string") {
              cert = forge.pki.certificateFromPem(cert);
            }
            msg.certificates.push(cert);
          },
          addCertificateRevokationList: function(crl) {
            throw new Error("PKCS#7 CRL support not yet implemented.");
          }
        };
        return msg;
        function addDigestAlgorithmIds() {
          var mds = {};
          for (var i = 0; i < msg.signers.length; ++i) {
            var signer = msg.signers[i];
            var oid = signer.digestAlgorithm;
            if (!(oid in mds)) {
              mds[oid] = forge.md[forge.pki.oids[oid]].create();
            }
            if (signer.authenticatedAttributes.length === 0) {
              signer.md = mds[oid];
            } else {
              signer.md = forge.md[forge.pki.oids[oid]].create();
            }
          }
          msg.digestAlgorithmIdentifiers = [];
          for (var oid in mds) {
            msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]));
          }
          return mds;
        }
        function addSignerInfos(mds) {
          var content;
          if (msg.detachedContent) {
            content = msg.detachedContent;
          } else {
            content = msg.contentInfo.value[1];
            content = content.value[0];
          }
          if (!content) {
            throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
          }
          var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
          var bytes = asn1.toDer(content);
          bytes.getByte();
          asn1.getBerValueLength(bytes);
          bytes = bytes.getBytes();
          for (var oid in mds) {
            mds[oid].start().update(bytes);
          }
          var signingTime = new Date();
          for (var i = 0; i < msg.signers.length; ++i) {
            var signer = msg.signers[i];
            if (signer.authenticatedAttributes.length === 0) {
              if (contentType !== forge.pki.oids.data) {
                throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
              }
            } else {
              signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
              var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
              for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
                var attr = signer.authenticatedAttributes[ai];
                if (attr.type === forge.pki.oids.messageDigest) {
                  attr.value = mds[signer.digestAlgorithm].digest();
                } else if (attr.type === forge.pki.oids.signingTime) {
                  if (!attr.value) {
                    attr.value = signingTime;
                  }
                }
                attrsAsn1.value.push(_attributeToAsn1(attr));
                signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
              }
              bytes = asn1.toDer(attrsAsn1).getBytes();
              signer.md.start().update(bytes);
            }
            signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
          }
          msg.signerInfos = _signersToAsn1(msg.signers);
        }
      };
      p7.createEncryptedData = function() {
        var msg = null;
        msg = {
          type: forge.pki.oids.encryptedData,
          version: 0,
          encryptedContent: {
            algorithm: forge.pki.oids["aes256-CBC"]
          },
          fromAsn1: function(obj) {
            _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
          },
          decrypt: function(key) {
            if (key !== void 0) {
              msg.encryptedContent.key = key;
            }
            _decryptContent(msg);
          }
        };
        return msg;
      };
      p7.createEnvelopedData = function() {
        var msg = null;
        msg = {
          type: forge.pki.oids.envelopedData,
          version: 0,
          recipients: [],
          encryptedContent: {
            algorithm: forge.pki.oids["aes256-CBC"]
          },
          fromAsn1: function(obj) {
            var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
            msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
          },
          toAsn1: function() {
            return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
                ])
              ])
            ]);
          },
          findRecipient: function(cert) {
            var sAttr = cert.issuer.attributes;
            for (var i = 0; i < msg.recipients.length; ++i) {
              var r = msg.recipients[i];
              var rAttr = r.issuer;
              if (r.serialNumber !== cert.serialNumber) {
                continue;
              }
              if (rAttr.length !== sAttr.length) {
                continue;
              }
              var match = true;
              for (var j = 0; j < sAttr.length; ++j) {
                if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                  match = false;
                  break;
                }
              }
              if (match) {
                return r;
              }
            }
            return null;
          },
          decrypt: function(recipient, privKey) {
            if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
              switch (recipient.encryptedContent.algorithm) {
                case forge.pki.oids.rsaEncryption:
                case forge.pki.oids.desCBC:
                  var key = privKey.decrypt(recipient.encryptedContent.content);
                  msg.encryptedContent.key = forge.util.createBuffer(key);
                  break;
                default:
                  throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
              }
            }
            _decryptContent(msg);
          },
          addRecipient: function(cert) {
            msg.recipients.push({
              version: 0,
              issuer: cert.issuer.attributes,
              serialNumber: cert.serialNumber,
              encryptedContent: {
                algorithm: forge.pki.oids.rsaEncryption,
                key: cert.publicKey
              }
            });
          },
          encrypt: function(key, cipher) {
            if (msg.encryptedContent.content === void 0) {
              cipher = cipher || msg.encryptedContent.algorithm;
              key = key || msg.encryptedContent.key;
              var keyLen, ivLen, ciphFn;
              switch (cipher) {
                case forge.pki.oids["aes128-CBC"]:
                  keyLen = 16;
                  ivLen = 16;
                  ciphFn = forge.aes.createEncryptionCipher;
                  break;
                case forge.pki.oids["aes192-CBC"]:
                  keyLen = 24;
                  ivLen = 16;
                  ciphFn = forge.aes.createEncryptionCipher;
                  break;
                case forge.pki.oids["aes256-CBC"]:
                  keyLen = 32;
                  ivLen = 16;
                  ciphFn = forge.aes.createEncryptionCipher;
                  break;
                case forge.pki.oids["des-EDE3-CBC"]:
                  keyLen = 24;
                  ivLen = 8;
                  ciphFn = forge.des.createEncryptionCipher;
                  break;
                default:
                  throw new Error("Unsupported symmetric cipher, OID " + cipher);
              }
              if (key === void 0) {
                key = forge.util.createBuffer(forge.random.getBytes(keyLen));
              } else if (key.length() != keyLen) {
                throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
              }
              msg.encryptedContent.algorithm = cipher;
              msg.encryptedContent.key = key;
              msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
              var ciph = ciphFn(key);
              ciph.start(msg.encryptedContent.parameter.copy());
              ciph.update(msg.content);
              if (!ciph.finish()) {
                throw new Error("Symmetric encryption failed.");
              }
              msg.encryptedContent.content = ciph.output;
            }
            for (var i = 0; i < msg.recipients.length; ++i) {
              var recipient = msg.recipients[i];
              if (recipient.encryptedContent.content !== void 0) {
                continue;
              }
              switch (recipient.encryptedContent.algorithm) {
                case forge.pki.oids.rsaEncryption:
                  recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                  break;
                default:
                  throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
              }
            }
          }
        };
        return msg;
      };
      function _recipientFromAsn1(obj) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
          var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
          error.errors = errors;
          throw error;
        }
        return {
          version: capture.version.charCodeAt(0),
          issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
          serialNumber: forge.util.createBuffer(capture.serial).toHex(),
          encryptedContent: {
            algorithm: asn1.derToOid(capture.encAlgorithm),
            parameter: capture.encParameter.value,
            content: capture.encKey
          }
        };
      }
      function _recipientToAsn1(obj) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
        ]);
      }
      function _recipientsFromAsn1(infos) {
        var ret = [];
        for (var i = 0; i < infos.length; ++i) {
          ret.push(_recipientFromAsn1(infos[i]));
        }
        return ret;
      }
      function _recipientsToAsn1(recipients) {
        var ret = [];
        for (var i = 0; i < recipients.length; ++i) {
          ret.push(_recipientToAsn1(recipients[i]));
        }
        return ret;
      }
      function _signerToAsn1(obj) {
        var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        ]);
        if (obj.authenticatedAttributesAsn1) {
          rval.value.push(obj.authenticatedAttributesAsn1);
        }
        rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]));
        rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
        if (obj.unauthenticatedAttributes.length > 0) {
          var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
          for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
            var attr = obj.unauthenticatedAttributes[i];
            attrsAsn1.values.push(_attributeToAsn1(attr));
          }
          rval.value.push(attrsAsn1);
        }
        return rval;
      }
      function _signersToAsn1(signers) {
        var ret = [];
        for (var i = 0; i < signers.length; ++i) {
          ret.push(_signerToAsn1(signers[i]));
        }
        return ret;
      }
      function _attributeToAsn1(attr) {
        var value;
        if (attr.type === forge.pki.oids.contentType) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
        } else if (attr.type === forge.pki.oids.messageDigest) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
        } else if (attr.type === forge.pki.oids.signingTime) {
          var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
          var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
          var date = attr.value;
          if (typeof date === "string") {
            var timestamp = Date.parse(date);
            if (!isNaN(timestamp)) {
              date = new Date(timestamp);
            } else if (date.length === 13) {
              date = asn1.utcTimeToDate(date);
            } else {
              date = asn1.generalizedTimeToDate(date);
            }
          }
          if (date >= jan_1_1950 && date < jan_1_2050) {
            value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
          } else {
            value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
          }
        }
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            value
          ])
        ]);
      }
      function _encryptedContentToAsn1(ec) {
        return [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
          ]),
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
          ])
        ];
      }
      function _fromAsn1(msg, obj, validator) {
        var capture = {};
        var errors = [];
        if (!asn1.validate(obj, validator, capture, errors)) {
          var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
          error.errors = error;
          throw error;
        }
        var contentType = asn1.derToOid(capture.contentType);
        if (contentType !== forge.pki.oids.data) {
          throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
        }
        if (capture.encryptedContent) {
          var content = "";
          if (forge.util.isArray(capture.encryptedContent)) {
            for (var i = 0; i < capture.encryptedContent.length; ++i) {
              if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
                throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
              }
              content += capture.encryptedContent[i].value;
            }
          } else {
            content = capture.encryptedContent;
          }
          msg.encryptedContent = {
            algorithm: asn1.derToOid(capture.encAlgorithm),
            parameter: forge.util.createBuffer(capture.encParameter.value),
            content: forge.util.createBuffer(content)
          };
        }
        if (capture.content) {
          var content = "";
          if (forge.util.isArray(capture.content)) {
            for (var i = 0; i < capture.content.length; ++i) {
              if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
                throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
              }
              content += capture.content[i].value;
            }
          } else {
            content = capture.content;
          }
          msg.content = forge.util.createBuffer(content);
        }
        msg.version = capture.version.charCodeAt(0);
        msg.rawCapture = capture;
        return capture;
      }
      function _decryptContent(msg) {
        if (msg.encryptedContent.key === void 0) {
          throw new Error("Symmetric key not available.");
        }
        if (msg.content === void 0) {
          var ciph;
          switch (msg.encryptedContent.algorithm) {
            case forge.pki.oids["aes128-CBC"]:
            case forge.pki.oids["aes192-CBC"]:
            case forge.pki.oids["aes256-CBC"]:
              ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
              break;
            case forge.pki.oids["desCBC"]:
            case forge.pki.oids["des-EDE3-CBC"]:
              ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
          }
          ciph.start(msg.encryptedContent.parameter);
          ciph.update(msg.encryptedContent.content);
          if (!ciph.finish()) {
            throw new Error("Symmetric decryption failed.");
          }
          msg.content = ciph.output;
        }
      }
    }
  });

  // node_modules/node-forge/lib/ssh.js
  var require_ssh = __commonJS({
    "node_modules/node-forge/lib/ssh.js"(exports, module) {
      var forge = require_forge();
      require_aes();
      require_hmac();
      require_md5();
      require_sha1();
      require_util4();
      var ssh = module.exports = forge.ssh = forge.ssh || {};
      ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
        comment = comment || "";
        passphrase = passphrase || "";
        var algorithm = "ssh-rsa";
        var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
        var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
        ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
        ppk += "Comment: " + comment + "\r\n";
        var pubbuffer = forge.util.createBuffer();
        _addStringToBuffer(pubbuffer, algorithm);
        _addBigIntegerToBuffer(pubbuffer, privateKey.e);
        _addBigIntegerToBuffer(pubbuffer, privateKey.n);
        var pub = forge.util.encode64(pubbuffer.bytes(), 64);
        var length = Math.floor(pub.length / 66) + 1;
        ppk += "Public-Lines: " + length + "\r\n";
        ppk += pub;
        var privbuffer = forge.util.createBuffer();
        _addBigIntegerToBuffer(privbuffer, privateKey.d);
        _addBigIntegerToBuffer(privbuffer, privateKey.p);
        _addBigIntegerToBuffer(privbuffer, privateKey.q);
        _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
        var priv;
        if (!passphrase) {
          priv = forge.util.encode64(privbuffer.bytes(), 64);
        } else {
          var encLen = privbuffer.length() + 16 - 1;
          encLen -= encLen % 16;
          var padding = _sha1(privbuffer.bytes());
          padding.truncate(padding.length() - encLen + privbuffer.length());
          privbuffer.putBuffer(padding);
          var aeskey = forge.util.createBuffer();
          aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
          aeskey.putBuffer(_sha1("\0\0\0", passphrase));
          var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
          cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
          cipher.update(privbuffer.copy());
          cipher.finish();
          var encrypted = cipher.output;
          encrypted.truncate(16);
          priv = forge.util.encode64(encrypted.bytes(), 64);
        }
        length = Math.floor(priv.length / 66) + 1;
        ppk += "\r\nPrivate-Lines: " + length + "\r\n";
        ppk += priv;
        var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
        var macbuffer = forge.util.createBuffer();
        _addStringToBuffer(macbuffer, algorithm);
        _addStringToBuffer(macbuffer, encryptionAlgorithm);
        _addStringToBuffer(macbuffer, comment);
        macbuffer.putInt32(pubbuffer.length());
        macbuffer.putBuffer(pubbuffer);
        macbuffer.putInt32(privbuffer.length());
        macbuffer.putBuffer(privbuffer);
        var hmac = forge.hmac.create();
        hmac.start("sha1", mackey);
        hmac.update(macbuffer.bytes());
        ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
        return ppk;
      };
      ssh.publicKeyToOpenSSH = function(key, comment) {
        var type = "ssh-rsa";
        comment = comment || "";
        var buffer = forge.util.createBuffer();
        _addStringToBuffer(buffer, type);
        _addBigIntegerToBuffer(buffer, key.e);
        _addBigIntegerToBuffer(buffer, key.n);
        return type + " " + forge.util.encode64(buffer.bytes()) + " " + comment;
      };
      ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
        if (!passphrase) {
          return forge.pki.privateKeyToPem(privateKey);
        }
        return forge.pki.encryptRsaPrivateKey(privateKey, passphrase, { legacy: true, algorithm: "aes128" });
      };
      ssh.getPublicKeyFingerprint = function(key, options) {
        options = options || {};
        var md = options.md || forge.md.md5.create();
        var type = "ssh-rsa";
        var buffer = forge.util.createBuffer();
        _addStringToBuffer(buffer, type);
        _addBigIntegerToBuffer(buffer, key.e);
        _addBigIntegerToBuffer(buffer, key.n);
        md.start();
        md.update(buffer.getBytes());
        var digest = md.digest();
        if (options.encoding === "hex") {
          var hex = digest.toHex();
          if (options.delimiter) {
            return hex.match(/.{2}/g).join(options.delimiter);
          }
          return hex;
        } else if (options.encoding === "binary") {
          return digest.getBytes();
        } else if (options.encoding) {
          throw new Error('Unknown encoding "' + options.encoding + '".');
        }
        return digest;
      };
      function _addBigIntegerToBuffer(buffer, val) {
        var hexVal = val.toString(16);
        if (hexVal[0] >= "8") {
          hexVal = "00" + hexVal;
        }
        var bytes = forge.util.hexToBytes(hexVal);
        buffer.putInt32(bytes.length);
        buffer.putBytes(bytes);
      }
      function _addStringToBuffer(buffer, val) {
        buffer.putInt32(val.length);
        buffer.putString(val);
      }
      function _sha1() {
        var sha = forge.md.sha1.create();
        var num = arguments.length;
        for (var i = 0; i < num; ++i) {
          sha.update(arguments[i]);
        }
        return sha.digest();
      }
    }
  });

  // node_modules/node-forge/lib/task.js
  var require_task = __commonJS({
    "node_modules/node-forge/lib/task.js"(exports, module) {
      var forge = require_forge();
      require_debug();
      require_log();
      require_util4();
      var cat = "forge.task";
      var sVL = 0;
      var sTasks = {};
      var sNextTaskId = 0;
      forge.debug.set(cat, "tasks", sTasks);
      var sTaskQueues = {};
      forge.debug.set(cat, "queues", sTaskQueues);
      var sNoTaskName = "?";
      var sMaxRecursions = 30;
      var sTimeSlice = 20;
      var READY = "ready";
      var RUNNING = "running";
      var BLOCKED = "blocked";
      var SLEEPING = "sleeping";
      var DONE = "done";
      var ERROR = "error";
      var STOP = "stop";
      var START = "start";
      var BLOCK = "block";
      var UNBLOCK = "unblock";
      var SLEEP = "sleep";
      var WAKEUP = "wakeup";
      var CANCEL = "cancel";
      var FAIL = "fail";
      var sStateTable = {};
      sStateTable[READY] = {};
      sStateTable[READY][STOP] = READY;
      sStateTable[READY][START] = RUNNING;
      sStateTable[READY][CANCEL] = DONE;
      sStateTable[READY][FAIL] = ERROR;
      sStateTable[RUNNING] = {};
      sStateTable[RUNNING][STOP] = READY;
      sStateTable[RUNNING][START] = RUNNING;
      sStateTable[RUNNING][BLOCK] = BLOCKED;
      sStateTable[RUNNING][UNBLOCK] = RUNNING;
      sStateTable[RUNNING][SLEEP] = SLEEPING;
      sStateTable[RUNNING][WAKEUP] = RUNNING;
      sStateTable[RUNNING][CANCEL] = DONE;
      sStateTable[RUNNING][FAIL] = ERROR;
      sStateTable[BLOCKED] = {};
      sStateTable[BLOCKED][STOP] = BLOCKED;
      sStateTable[BLOCKED][START] = BLOCKED;
      sStateTable[BLOCKED][BLOCK] = BLOCKED;
      sStateTable[BLOCKED][UNBLOCK] = BLOCKED;
      sStateTable[BLOCKED][SLEEP] = BLOCKED;
      sStateTable[BLOCKED][WAKEUP] = BLOCKED;
      sStateTable[BLOCKED][CANCEL] = DONE;
      sStateTable[BLOCKED][FAIL] = ERROR;
      sStateTable[SLEEPING] = {};
      sStateTable[SLEEPING][STOP] = SLEEPING;
      sStateTable[SLEEPING][START] = SLEEPING;
      sStateTable[SLEEPING][BLOCK] = SLEEPING;
      sStateTable[SLEEPING][UNBLOCK] = SLEEPING;
      sStateTable[SLEEPING][SLEEP] = SLEEPING;
      sStateTable[SLEEPING][WAKEUP] = SLEEPING;
      sStateTable[SLEEPING][CANCEL] = DONE;
      sStateTable[SLEEPING][FAIL] = ERROR;
      sStateTable[DONE] = {};
      sStateTable[DONE][STOP] = DONE;
      sStateTable[DONE][START] = DONE;
      sStateTable[DONE][BLOCK] = DONE;
      sStateTable[DONE][UNBLOCK] = DONE;
      sStateTable[DONE][SLEEP] = DONE;
      sStateTable[DONE][WAKEUP] = DONE;
      sStateTable[DONE][CANCEL] = DONE;
      sStateTable[DONE][FAIL] = ERROR;
      sStateTable[ERROR] = {};
      sStateTable[ERROR][STOP] = ERROR;
      sStateTable[ERROR][START] = ERROR;
      sStateTable[ERROR][BLOCK] = ERROR;
      sStateTable[ERROR][UNBLOCK] = ERROR;
      sStateTable[ERROR][SLEEP] = ERROR;
      sStateTable[ERROR][WAKEUP] = ERROR;
      sStateTable[ERROR][CANCEL] = ERROR;
      sStateTable[ERROR][FAIL] = ERROR;
      var Task = function(options) {
        this.id = -1;
        this.name = options.name || sNoTaskName;
        this.parent = options.parent || null;
        this.run = options.run;
        this.subtasks = [];
        this.error = false;
        this.state = READY;
        this.blocks = 0;
        this.timeoutId = null;
        this.swapTime = null;
        this.userData = null;
        this.id = sNextTaskId++;
        sTasks[this.id] = this;
        if (sVL >= 1) {
          forge.log.verbose(cat, "[%s][%s] init", this.id, this.name, this);
        }
      };
      Task.prototype.debug = function(msg) {
        msg = msg || "";
        forge.log.debug(cat, msg, "[%s][%s] task:", this.id, this.name, this, "subtasks:", this.subtasks.length, "queue:", sTaskQueues);
      };
      Task.prototype.next = function(name, subrun) {
        if (typeof name === "function") {
          subrun = name;
          name = this.name;
        }
        var subtask = new Task({
          run: subrun,
          name,
          parent: this
        });
        subtask.state = RUNNING;
        subtask.type = this.type;
        subtask.successCallback = this.successCallback || null;
        subtask.failureCallback = this.failureCallback || null;
        this.subtasks.push(subtask);
        return this;
      };
      Task.prototype.parallel = function(name, subrun) {
        if (forge.util.isArray(name)) {
          subrun = name;
          name = this.name;
        }
        return this.next(name, function(task) {
          var ptask = task;
          ptask.block(subrun.length);
          var startParallelTask = function(pname2, pi2) {
            forge.task.start({
              type: pname2,
              run: function(task2) {
                subrun[pi2](task2);
              },
              success: function(task2) {
                ptask.unblock();
              },
              failure: function(task2) {
                ptask.unblock();
              }
            });
          };
          for (var i = 0; i < subrun.length; i++) {
            var pname = name + "__parallel-" + task.id + "-" + i;
            var pi = i;
            startParallelTask(pname, pi);
          }
        });
      };
      Task.prototype.stop = function() {
        this.state = sStateTable[this.state][STOP];
      };
      Task.prototype.start = function() {
        this.error = false;
        this.state = sStateTable[this.state][START];
        if (this.state === RUNNING) {
          this.start = new Date();
          this.run(this);
          runNext(this, 0);
        }
      };
      Task.prototype.block = function(n) {
        n = typeof n === "undefined" ? 1 : n;
        this.blocks += n;
        if (this.blocks > 0) {
          this.state = sStateTable[this.state][BLOCK];
        }
      };
      Task.prototype.unblock = function(n) {
        n = typeof n === "undefined" ? 1 : n;
        this.blocks -= n;
        if (this.blocks === 0 && this.state !== DONE) {
          this.state = RUNNING;
          runNext(this, 0);
        }
        return this.blocks;
      };
      Task.prototype.sleep = function(n) {
        n = typeof n === "undefined" ? 0 : n;
        this.state = sStateTable[this.state][SLEEP];
        var self2 = this;
        this.timeoutId = setTimeout(function() {
          self2.timeoutId = null;
          self2.state = RUNNING;
          runNext(self2, 0);
        }, n);
      };
      Task.prototype.wait = function(cond) {
        cond.wait(this);
      };
      Task.prototype.wakeup = function() {
        if (this.state === SLEEPING) {
          cancelTimeout(this.timeoutId);
          this.timeoutId = null;
          this.state = RUNNING;
          runNext(this, 0);
        }
      };
      Task.prototype.cancel = function() {
        this.state = sStateTable[this.state][CANCEL];
        this.permitsNeeded = 0;
        if (this.timeoutId !== null) {
          cancelTimeout(this.timeoutId);
          this.timeoutId = null;
        }
        this.subtasks = [];
      };
      Task.prototype.fail = function(next) {
        this.error = true;
        finish(this, true);
        if (next) {
          next.error = this.error;
          next.swapTime = this.swapTime;
          next.userData = this.userData;
          runNext(next, 0);
        } else {
          if (this.parent !== null) {
            var parent = this.parent;
            while (parent.parent !== null) {
              parent.error = this.error;
              parent.swapTime = this.swapTime;
              parent.userData = this.userData;
              parent = parent.parent;
            }
            finish(parent, true);
          }
          if (this.failureCallback) {
            this.failureCallback(this);
          }
        }
      };
      var start = function(task) {
        task.error = false;
        task.state = sStateTable[task.state][START];
        setTimeout(function() {
          if (task.state === RUNNING) {
            task.swapTime = +new Date();
            task.run(task);
            runNext(task, 0);
          }
        }, 0);
      };
      var runNext = function(task, recurse) {
        var swap = recurse > sMaxRecursions || +new Date() - task.swapTime > sTimeSlice;
        var doNext = function(recurse2) {
          recurse2++;
          if (task.state === RUNNING) {
            if (swap) {
              task.swapTime = +new Date();
            }
            if (task.subtasks.length > 0) {
              var subtask = task.subtasks.shift();
              subtask.error = task.error;
              subtask.swapTime = task.swapTime;
              subtask.userData = task.userData;
              subtask.run(subtask);
              if (!subtask.error) {
                runNext(subtask, recurse2);
              }
            } else {
              finish(task);
              if (!task.error) {
                if (task.parent !== null) {
                  task.parent.error = task.error;
                  task.parent.swapTime = task.swapTime;
                  task.parent.userData = task.userData;
                  runNext(task.parent, recurse2);
                }
              }
            }
          }
        };
        if (swap) {
          setTimeout(doNext, 0);
        } else {
          doNext(recurse);
        }
      };
      var finish = function(task, suppressCallbacks) {
        task.state = DONE;
        delete sTasks[task.id];
        if (sVL >= 1) {
          forge.log.verbose(cat, "[%s][%s] finish", task.id, task.name, task);
        }
        if (task.parent === null) {
          if (!(task.type in sTaskQueues)) {
            forge.log.error(cat, "[%s][%s] task queue missing [%s]", task.id, task.name, task.type);
          } else if (sTaskQueues[task.type].length === 0) {
            forge.log.error(cat, "[%s][%s] task queue empty [%s]", task.id, task.name, task.type);
          } else if (sTaskQueues[task.type][0] !== task) {
            forge.log.error(cat, "[%s][%s] task not first in queue [%s]", task.id, task.name, task.type);
          } else {
            sTaskQueues[task.type].shift();
            if (sTaskQueues[task.type].length === 0) {
              if (sVL >= 1) {
                forge.log.verbose(cat, "[%s][%s] delete queue [%s]", task.id, task.name, task.type);
              }
              delete sTaskQueues[task.type];
            } else {
              if (sVL >= 1) {
                forge.log.verbose(cat, "[%s][%s] queue start next [%s] remain:%s", task.id, task.name, task.type, sTaskQueues[task.type].length);
              }
              sTaskQueues[task.type][0].start();
            }
          }
          if (!suppressCallbacks) {
            if (task.error && task.failureCallback) {
              task.failureCallback(task);
            } else if (!task.error && task.successCallback) {
              task.successCallback(task);
            }
          }
        }
      };
      module.exports = forge.task = forge.task || {};
      forge.task.start = function(options) {
        var task = new Task({
          run: options.run,
          name: options.name || sNoTaskName
        });
        task.type = options.type;
        task.successCallback = options.success || null;
        task.failureCallback = options.failure || null;
        if (!(task.type in sTaskQueues)) {
          if (sVL >= 1) {
            forge.log.verbose(cat, "[%s][%s] create queue [%s]", task.id, task.name, task.type);
          }
          sTaskQueues[task.type] = [task];
          start(task);
        } else {
          sTaskQueues[options.type].push(task);
        }
      };
      forge.task.cancel = function(type) {
        if (type in sTaskQueues) {
          sTaskQueues[type] = [sTaskQueues[type][0]];
        }
      };
      forge.task.createCondition = function() {
        var cond = {
          tasks: {}
        };
        cond.wait = function(task) {
          if (!(task.id in cond.tasks)) {
            task.block();
            cond.tasks[task.id] = task;
          }
        };
        cond.notify = function() {
          var tmp = cond.tasks;
          cond.tasks = {};
          for (var id in tmp) {
            tmp[id].unblock();
          }
        };
        return cond;
      };
    }
  });

  // node_modules/node-forge/lib/index.js
  var require_lib2 = __commonJS({
    "node_modules/node-forge/lib/index.js"(exports, module) {
      module.exports = require_forge();
      require_aes();
      require_aesCipherSuites();
      require_asn1();
      require_cipher();
      require_debug();
      require_des();
      require_ed25519();
      require_hmac();
      require_kem();
      require_log();
      require_md_all();
      require_mgf1();
      require_pbkdf2();
      require_pem();
      require_pkcs1();
      require_pkcs12();
      require_pkcs7();
      require_pki();
      require_prime();
      require_prng();
      require_pss();
      require_random();
      require_rc2();
      require_ssh();
      require_task();
      require_tls();
      require_util4();
    }
  });

  // node_modules/base64url-universal/lib/base64url.js
  var require_base64url = __commonJS({
    "node_modules/base64url-universal/lib/base64url.js"(exports, module) {
      "use strict";
      var _alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
      var _alphabetIdx = [
        62,
        -1,
        -1,
        52,
        53,
        54,
        55,
        56,
        57,
        58,
        59,
        60,
        61,
        -1,
        -1,
        -1,
        64,
        -1,
        -1,
        -1,
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        -1,
        -1,
        -1,
        -1,
        63,
        -1,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        46,
        47,
        48,
        49,
        50,
        51
      ];
      function encode(input) {
        if (!(input instanceof Uint8Array || typeof input === "string")) {
          throw new TypeError('"input" be a string or Uint8Array.');
        }
        if (typeof input === "string") {
          input = new TextEncoder().encode(input);
        }
        let output = "";
        let chr1, chr2, chr3;
        let i = 0;
        while (i < input.byteLength) {
          chr1 = input[i++];
          chr2 = input[i++];
          chr3 = input[i++];
          output += _alphabet.charAt(chr1 >> 2);
          output += _alphabet.charAt((chr1 & 3) << 4 | chr2 >> 4);
          if (!isNaN(chr2)) {
            output += _alphabet.charAt((chr2 & 15) << 2 | chr3 >> 6);
            if (!isNaN(chr3)) {
              output += _alphabet.charAt(chr3 & 63);
            }
          }
        }
        return output;
      }
      function decode(input) {
        let length = input.length;
        const mod4 = length % 4;
        if (mod4 === 1) {
          throw new Error("Illegal base64 string.");
        }
        let diff = 0;
        if (mod4 > 0) {
          diff = 4 - mod4;
          length += diff;
        }
        const output = new Uint8Array(length / 4 * 3 - diff);
        let enc1, enc2, enc3, enc4;
        let i = 0, j = 0;
        while (i < length) {
          enc1 = _alphabetIdx[input.charCodeAt(i++) - 45];
          enc2 = _alphabetIdx[input.charCodeAt(i++) - 45];
          output[j++] = enc1 << 2 | enc2 >> 4;
          if (i < input.length) {
            enc3 = _alphabetIdx[input.charCodeAt(i++) - 45];
            output[j++] = (enc2 & 15) << 4 | enc3 >> 2;
            if (i < input.length) {
              enc4 = _alphabetIdx[input.charCodeAt(i++) - 45];
              output[j++] = (enc3 & 3) << 6 | enc4;
            }
          }
        }
        return output;
      }
      module.exports = { decode, encode };
    }
  });

  // node_modules/base64url-universal/lib/browser.js
  var require_browser = __commonJS({
    "node_modules/base64url-universal/lib/browser.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      var base64url = require_base64url();
      api.encode = base64url.encode;
      api.decode = base64url.decode;
    }
  });

  // node_modules/crypto-ld/lib/util.js
  var require_util5 = __commonJS({
    "node_modules/crypto-ld/lib/util.js"(exports) {
      "use strict";
      var { asn1, oids, util: { ByteBuffer } } = require_lib2();
      exports.base58Decode = ({ decode, keyMaterial, type }) => {
        let bytes;
        try {
          bytes = decode(keyMaterial);
        } catch (e) {
        }
        if (bytes === void 0) {
          throw new TypeError(`The ${type} key material must be Base58 encoded.`);
        }
        return bytes;
      };
      exports.privateKeyDerEncode = ({ privateKeyBytes, seedBytes }) => {
        if (!(privateKeyBytes || seedBytes)) {
          throw new TypeError("`privateKeyBytes` or `seedBytes` is required.");
        }
        if (!privateKeyBytes && !(Buffer.isBuffer(seedBytes) && seedBytes.length === 32)) {
          throw new TypeError("`seedBytes` must be a 32 byte Buffer.");
        }
        if (!seedBytes && !(Buffer.isBuffer(privateKeyBytes) && privateKeyBytes.length === 64)) {
          throw new TypeError("`privateKeyBytes` must be a 64 byte Buffer.");
        }
        let p;
        if (seedBytes) {
          p = seedBytes;
        } else {
          p = Buffer.from(privateKeyBytes.buffer, privateKeyBytes.byteOffset, 32);
        }
        const keyBuffer = new ByteBuffer(p);
        const asn1Key = asn1.create(asn1.UNIVERSAL, asn1.Type.OCTETSTRING, false, keyBuffer.getBytes());
        const a = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids.EdDSA25519).getBytes())
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(asn1Key).getBytes())
        ]);
        const privateKeyDer = asn1.toDer(a);
        return Buffer.from(privateKeyDer.getBytes(), "binary");
      };
      exports.publicKeyDerEncode = ({ publicKeyBytes }) => {
        if (!(Buffer.isBuffer(publicKeyBytes) && publicKeyBytes.length === 32)) {
          throw new TypeError("`publicKeyBytes` must be a 32 byte Buffer.");
        }
        const zeroBuffer = Buffer.from(new Uint8Array([0]));
        const keyBuffer = new ByteBuffer(Buffer.concat([zeroBuffer, publicKeyBytes]));
        const a = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids.EdDSA25519).getBytes())
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, keyBuffer.getBytes())
        ]);
        const publicKeyDer = asn1.toDer(a);
        return Buffer.from(publicKeyDer.getBytes(), "binary");
      };
    }
  });

  // node_modules/crypto-ld/lib/RSAKeyPair.js
  var require_RSAKeyPair = __commonJS({
    "node_modules/crypto-ld/lib/RSAKeyPair.js"(exports, module) {
      "use strict";
      var env = require_env();
      var forge = require_lib2();
      var {
        md: { sha256 },
        pki: { getPublicKeyFingerprint, publicKeyFromPem },
        util: { binary: { base58, raw } }
      } = forge;
      var LDKeyPair = require_LDKeyPair();
      var DEFAULT_RSA_KEY_BITS = 2048;
      var DEFAULT_RSA_EXPONENT = 65537;
      var RSAKeyPair = class extends LDKeyPair {
        constructor(options = {}) {
          super(options);
          this.type = "RsaVerificationKey2018";
          this.privateKeyPem = options.privateKeyPem;
          this.publicKeyPem = options.publicKeyPem;
          this.validateKeyParams();
        }
        get publicKey() {
          return this.publicKeyPem;
        }
        get privateKey() {
          return this.privateKeyPem;
        }
        static async generate(options = {}) {
          return new Promise((resolve, reject) => {
            forge.pki.rsa.generateKeyPair({
              bits: DEFAULT_RSA_KEY_BITS,
              e: DEFAULT_RSA_EXPONENT,
              workers: -1
            }, (err, keyPair) => {
              if (err) {
                return reject(err);
              }
              resolve(new RSAKeyPair({
                publicKeyPem: forge.pki.publicKeyToPem(keyPair.publicKey),
                privateKeyPem: forge.pki.privateKeyToPem(keyPair.privateKey),
                ...options
              }));
            });
          });
        }
        static async from(options) {
          const privateKeyPem = options.privateKeyPem || options.privateKeyPem && options.privateKey.privateKeyPem;
          const keys = new RSAKeyPair({
            publicKey: options.publicKeyPem,
            privateKeyPem,
            type: options.type || options.keyType,
            ...options
          });
          return keys;
        }
        validateKeyParams() {
          if (this.publicKeyPem) {
            const publicKey = forge.pki.publicKeyFromPem(this.publicKeyPem);
            const keyBits = publicKey.n.bitLength();
            if (keyBits !== DEFAULT_RSA_KEY_BITS) {
              throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)} required value is ${DEFAULT_RSA_KEY_BITS}`);
            }
            if (publicKey.e.toString(10) !== "65537") {
              throw new Error(`Invalid RSA exponent ${JSON.stringify(publicKey.e.toString(10))} required value is 65537}`);
            }
          }
          if (this.privateKeyPem) {
            const privateKey = forge.pki.privateKeyFromPem(this.privateKeyPem);
            const keyBits = privateKey.n.bitLength();
            if (keyBits !== DEFAULT_RSA_KEY_BITS) {
              throw new Error(`Invalid RSA keyBit length ${JSON.stringify(keyBits)} required value is ${DEFAULT_RSA_KEY_BITS}`);
            }
            if (privateKey.e.toString(10) !== "65537") {
              throw new Error(`Invalid RSA exponent ${JSON.stringify(privateKey.e.toString(10))} required value is 65537}`);
            }
          }
        }
        addEncodedPublicKey(publicKeyNode) {
          publicKeyNode.publicKeyPem = this.publicKeyPem;
          return publicKeyNode;
        }
        async addEncryptedPrivateKey(keyNode) {
          if (this.passphrase !== null) {
            keyNode.privateKeyPem = forge.pki.encryptRsaPrivateKey(forge.pki.privateKeyFromPem(this.privateKeyPem), this.passphrase, { algorithm: "aes256" });
          } else {
            keyNode.privateKeyPem = this.privateKeyPem;
          }
          return keyNode;
        }
        fingerprint() {
          const buffer = forge.util.createBuffer();
          const fingerprintBuffer = forge.pki.getPublicKeyFingerprint(forge.pki.publicKeyFromPem(this.publicKeyPem), { md: sha256.create() });
          buffer.putBytes(forge.util.hexToBytes("5d1220"));
          buffer.putBytes(fingerprintBuffer.bytes());
          return `z${base58.encode(buffer)}`;
        }
        verifyFingerprint(fingerprint) {
          if (!(typeof fingerprint === "string" && fingerprint[0] === "z")) {
            return {
              error: new Error("`fingerprint` must be a multibase encoded string."),
              valid: false
            };
          }
          const fingerprintBuffer = base58.decode(fingerprint.slice(1));
          const keyFingerprintBuffer = getPublicKeyFingerprint(publicKeyFromPem(this.publicKeyPem), { md: sha256.create() });
          const valid = fingerprintBuffer.slice(0, 3).toString("hex") === "5d1220" && keyFingerprintBuffer.toHex() === fingerprintBuffer.slice(3).toString("hex");
          if (!valid) {
            return {
              error: new Error("The fingerprint does not match the public key."),
              valid: false
            };
          }
          return { valid };
        }
        signer() {
          return rsaSignerFactory(this);
        }
        verifier() {
          return rsaVerifierFactory(this);
        }
      };
      function rsaSignerFactory(key) {
        if (!key.privateKeyPem) {
          return {
            async sign() {
              throw new Error("No private key to sign with.");
            }
          };
        }
        if (env.nodejs) {
          const crypto = require_crypto();
          if ("RSA_PKCS1_PSS_PADDING" in crypto.constants) {
            return {
              async sign({ data }) {
                const signer = crypto.createSign("RSA-SHA256");
                signer.update(Buffer.from(data.buffer, data.byteOffset, data.length));
                const buffer = signer.sign({
                  key: key.privateKeyPem,
                  padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                  saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
                });
                return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
              }
            };
          }
        }
        const privateKey = forge.pki.privateKeyFromPem(key.privateKeyPem);
        return {
          async sign({ data }) {
            const pss = createPss();
            const md = sha256.create();
            md.update(raw.encode(data), "binary");
            const binaryString = privateKey.sign(md, pss);
            return raw.decode(binaryString);
          }
        };
      }
      function rsaVerifierFactory(key) {
        if (env.nodejs) {
          const crypto = require_crypto();
          if ("RSA_PKCS1_PSS_PADDING" in crypto.constants) {
            return {
              async verify({ data, signature }) {
                const verifier = crypto.createVerify("RSA-SHA256");
                verifier.update(Buffer.from(data.buffer, data.byteOffset, data.length));
                return verifier.verify({
                  key: key.publicKeyPem,
                  padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
                  saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
                }, Buffer.from(signature.buffer, signature.byteOffset, signature.length));
              }
            };
          }
        }
        const publicKey = publicKeyFromPem(key.publicKeyPem);
        return {
          async verify({ data, signature }) {
            const pss = createPss();
            const md = sha256.create();
            md.update(raw.encode(data), "binary");
            try {
              return publicKey.verify(md.digest().bytes(), raw.encode(signature), pss);
            } catch (e) {
              return false;
            }
          }
        };
      }
      function createPss() {
        const md = sha256.create();
        return forge.pss.create({
          md,
          mgf: forge.mgf.mgf1.create(sha256.create()),
          saltLength: md.digestLength
        });
      }
      module.exports = RSAKeyPair;
    }
  });

  // node_modules/crypto-ld/lib/LDKeyPair.js
  var require_LDKeyPair = __commonJS({
    "node_modules/crypto-ld/lib/LDKeyPair.js"(exports, module) {
      "use strict";
      var forge = require_lib2();
      var { util: { binary: { base58 } } } = forge;
      var LDKeyPair = class {
        constructor(options = {}) {
          this.passphrase = options.passphrase || null;
          this.id = options.id;
          this.controller = options.controller;
          this.owner = options.owner;
        }
        get publicKey() {
          throw new Error("Abstract method, must be implemented in subclass.");
        }
        get privateKey() {
          throw new Error("Abstract method, must be implemented in subclass.");
        }
        static async generate(options) {
          switch (options.type) {
            case "Ed25519VerificationKey2018":
              const Ed25519KeyPair = require_Ed25519KeyPair();
              return Ed25519KeyPair.generate(options);
            case "RsaVerificationKey2018":
              const RSAKeyPair = require_RSAKeyPair();
              return RSAKeyPair.generate(options);
            default:
              throw new Error(`Unsupported Key Type: ${options.type}`);
          }
        }
        static async from(options) {
          switch (options.type) {
            case "Ed25519VerificationKey2018":
              const Ed25519KeyPair = require_Ed25519KeyPair();
              return Ed25519KeyPair.from(options);
            case "RsaVerificationKey2018":
              const RSAKeyPair = require_RSAKeyPair();
              return RSAKeyPair.from(options);
            default:
              throw new Error(`Unsupported Key Type: ${options.type}`);
          }
        }
        static fromFingerprint({ fingerprint }) {
          const buffer = base58.decode(fingerprint.substr(1));
          if (buffer[0] === 237 && buffer[1] === 1) {
            const Ed25519KeyPair = require_Ed25519KeyPair();
            return new Ed25519KeyPair({
              publicKeyBase58: base58.encode(buffer.slice(2))
            });
          }
          throw new Error(`Unsupported Fingerprint Type: ${fingerprint}`);
        }
        static async pbkdf2(password, salt, iterations, keySize) {
          return new Promise((resolve, reject) => {
            forge.pkcs5.pbkdf2(password, salt, iterations, keySize, (err, key) => err ? reject(err) : resolve(key));
          });
        }
        publicNode({ controller = this.controller, owner = this.owner } = {}) {
          const publicNode = {
            id: this.id,
            type: this.type
          };
          if (controller) {
            publicNode.controller = controller;
          }
          if (owner) {
            publicNode.owner = owner;
          }
          this.addEncodedPublicKey(publicNode);
          return publicNode;
        }
        async export() {
          const keyNode = this.publicNode();
          return this.addEncryptedPrivateKey(keyNode);
        }
      };
      module.exports = LDKeyPair;
    }
  });

  // (disabled):node_modules/semver/semver.js
  var require_semver = __commonJS({
    "(disabled):node_modules/semver/semver.js"() {
    }
  });

  // (disabled):node_modules/bs58/index.js
  var require_bs58 = __commonJS({
    "(disabled):node_modules/bs58/index.js"() {
    }
  });

  // (disabled):node_modules/util/util.js
  var require_util6 = __commonJS({
    "(disabled):node_modules/util/util.js"() {
    }
  });

  // (disabled):node_modules/crypto-ld/lib/ed25519PrivateKeyNode12
  var require_ed25519PrivateKeyNode12 = __commonJS({
    "(disabled):node_modules/crypto-ld/lib/ed25519PrivateKeyNode12"() {
    }
  });

  // (disabled):node_modules/sodium-native/index.js
  var require_sodium_native = __commonJS({
    "(disabled):node_modules/sodium-native/index.js"() {
    }
  });

  // (disabled):node_modules/crypto-ld/lib/ed25519PublicKeyNode12
  var require_ed25519PublicKeyNode12 = __commonJS({
    "(disabled):node_modules/crypto-ld/lib/ed25519PublicKeyNode12"() {
    }
  });

  // node_modules/crypto-ld/lib/Ed25519KeyPair.js
  var require_Ed25519KeyPair = __commonJS({
    "node_modules/crypto-ld/lib/Ed25519KeyPair.js"(exports, module) {
      "use strict";
      var env = require_env();
      var forge = require_lib2();
      var base64url = require_browser();
      var { pki: { ed25519 }, util: { binary: { base58 } } } = forge;
      var util = require_util5();
      var LDKeyPair = require_LDKeyPair();
      var Ed25519KeyPair = class extends LDKeyPair {
        constructor(options = {}) {
          super(options);
          this.type = "Ed25519VerificationKey2018";
          this.privateKeyBase58 = options.privateKeyBase58;
          this.publicKeyBase58 = options.publicKeyBase58;
        }
        get publicKey() {
          return this.publicKeyBase58;
        }
        get privateKey() {
          return this.privateKeyBase58;
        }
        static async generate(options = {}) {
          if (env.nodejs && require_semver().gte(process.version, "12.0.0")) {
            const bs58 = require_bs58();
            const {
              asn1,
              ed25519: { privateKeyFromAsn1, publicKeyFromAsn1 },
              util: { ByteBuffer }
            } = forge;
            const { promisify } = require_util6();
            const { createPublicKey, generateKeyPair } = require_crypto();
            const publicKeyEncoding = { format: "der", type: "spki" };
            const privateKeyEncoding = { format: "der", type: "pkcs8" };
            if (!("seed" in options)) {
              const generateKeyPairAsync = promisify(generateKeyPair);
              const { publicKey: publicKey3, privateKey: privateKey3 } = await generateKeyPairAsync("ed25519", {
                publicKeyEncoding,
                privateKeyEncoding
              });
              const publicKeyBytes2 = publicKeyFromAsn1(asn1.fromDer(new ByteBuffer(publicKey3)));
              const { privateKeyBytes: privateKeyBytes2 } = privateKeyFromAsn1(asn1.fromDer(new ByteBuffer(privateKey3)));
              return new Ed25519KeyPair({
                publicKeyBase58: bs58.encode(publicKeyBytes2),
                privateKeyBase58: bs58.encode(Buffer.concat([privateKeyBytes2, publicKeyBytes2])),
                ...options
              });
            }
            const { seed } = options;
            let seedBytes;
            if (seed instanceof Uint8Array || Buffer.isBuffer(seed)) {
              seedBytes = Buffer.from(seed);
            }
            if (!(Buffer.isBuffer(seedBytes) && seedBytes.length === 32)) {
              throw new TypeError("`seed` must be a 32 byte Buffer or Uint8Array.");
            }
            const _privateKey = require_ed25519PrivateKeyNode12();
            const privateKey2 = _privateKey.create({ seedBytes });
            const publicKey2 = createPublicKey(privateKey2);
            const publicKeyBytes = publicKeyFromAsn1(asn1.fromDer(new ByteBuffer(publicKey2.export(publicKeyEncoding))));
            const { privateKeyBytes } = privateKeyFromAsn1(asn1.fromDer(new ByteBuffer(privateKey2.export(privateKeyEncoding))));
            return new Ed25519KeyPair({
              publicKeyBase58: bs58.encode(publicKeyBytes),
              privateKeyBase58: bs58.encode(Buffer.concat([privateKeyBytes, publicKeyBytes])),
              ...options
            });
          }
          if (env.nodejs) {
            const sodium = require_sodium_native();
            const bs58 = require_bs58();
            const publicKey2 = new Buffer.alloc(sodium.crypto_sign_PUBLICKEYBYTES);
            const privateKey2 = new Buffer.alloc(sodium.crypto_sign_SECRETKEYBYTES);
            if ("seed" in options) {
              sodium.crypto_sign_seed_keypair(publicKey2, privateKey2, options.seed);
            } else {
              sodium.crypto_sign_keypair(publicKey2, privateKey2);
            }
            return new Ed25519KeyPair({
              publicKeyBase58: bs58.encode(publicKey2),
              privateKeyBase58: bs58.encode(privateKey2),
              ...options
            });
          }
          const generateOptions = {};
          if ("seed" in options) {
            generateOptions.seed = options.seed;
          }
          const { publicKey, privateKey } = ed25519.generateKeyPair(generateOptions);
          return new Ed25519KeyPair({
            publicKeyBase58: base58.encode(publicKey),
            privateKeyBase58: base58.encode(privateKey),
            ...options
          });
        }
        static async from(options) {
          const privateKeyBase58 = options.privateKeyBase58 || options.privateKey && options.privateKey.privateKeyBase58;
          const keyPair = new Ed25519KeyPair({
            privateKeyBase58,
            type: options.type || options.keyType,
            ...options
          });
          return keyPair;
        }
        signer() {
          return ed25519SignerFactory(this);
        }
        verifier() {
          return ed25519VerifierFactory(this);
        }
        addEncodedPublicKey(publicKeyNode) {
          publicKeyNode.publicKeyBase58 = this.publicKeyBase58;
          return publicKeyNode;
        }
        async addEncryptedPrivateKey(keyNode) {
          if (this.passphrase !== null) {
            keyNode.privateKeyJwe = await this.encrypt({ privateKeyBase58: this.privateKeyBase58 }, this.passphrase);
          } else {
            keyNode.privateKeyBase58 = this.privateKeyBase58;
          }
          return keyNode;
        }
        async encrypt(privateKey, password) {
          const keySize = 32;
          const salt = forge.random.getBytesSync(32);
          const iterations = 4096;
          const key = await LDKeyPair.pbkdf2(password, salt, iterations, keySize);
          const jweHeader = {
            alg: "PBES2-A128GCMKW",
            enc: "A128GCMKW",
            jwk: {
              kty: "PBKDF2",
              s: base64url.encode(salt),
              c: iterations
            }
          };
          const iv = forge.random.getBytesSync(12);
          const cipher = forge.cipher.createCipher("AES-GCM", key);
          cipher.start({ iv });
          cipher.update(forge.util.createBuffer(JSON.stringify(privateKey)));
          cipher.finish();
          const encrypted = cipher.output.getBytes();
          const tag = cipher.mode.tag.getBytes();
          const jwe = {
            unprotected: jweHeader,
            iv: base64url.encode(iv),
            ciphertext: base64url.encode(encrypted),
            tag: base64url.encode(tag)
          };
          return jwe;
        }
        async decrypt(jwe, password) {
          const keySize = 32;
          const { c: iterations } = jwe.unprotected.jwk;
          let { s: salt } = jwe.unprotected.jwk;
          salt = base64url.encode(salt);
          const key = await LDKeyPair.pbkdf2(password, salt, iterations, keySize);
          const iv = base64url.encode(jwe.iv);
          const tag = base64url.encode(jwe.tag);
          const decipher = forge.cipher.createDecipher("AES-GCM", key);
          decipher.start({ iv, tag });
          decipher.update(base64url.encode(jwe.ciphertext));
          const pass = decipher.finish();
          if (!pass) {
            throw new Error("Invalid password.");
          }
          const privateKey = JSON.parse(decipher.output.getBytes());
          return privateKey;
        }
        static fingerprintFromPublicKey({ publicKeyBase58 }) {
          const pubkeyBytes = util.base58Decode({
            decode: base58.decode,
            keyMaterial: publicKeyBase58,
            type: "public"
          });
          const buffer = new Uint8Array(2 + pubkeyBytes.length);
          buffer[0] = 237;
          buffer[1] = 1;
          buffer.set(pubkeyBytes, 2);
          return `z${base58.encode(buffer)}`;
        }
        fingerprint() {
          const { publicKeyBase58 } = this;
          return Ed25519KeyPair.fingerprintFromPublicKey({ publicKeyBase58 });
        }
        verifyFingerprint(fingerprint) {
          if (!(typeof fingerprint === "string" && fingerprint[0] === "z")) {
            return {
              error: new Error("`fingerprint` must be a multibase encoded string."),
              valid: false
            };
          }
          let fingerprintBuffer;
          try {
            fingerprintBuffer = util.base58Decode({
              decode: base58.decode,
              keyMaterial: fingerprint.slice(1),
              type: `fingerprint's`
            });
          } catch (e) {
            return { error: e, valid: false };
          }
          let publicKeyBuffer;
          try {
            publicKeyBuffer = util.base58Decode({
              decode: base58.decode,
              keyMaterial: this.publicKeyBase58,
              type: "public"
            });
          } catch (e) {
            return { error: e, valid: false };
          }
          const valid = fingerprintBuffer.slice(0, 2).toString("hex") === "ed01" && publicKeyBuffer.equals(fingerprintBuffer.slice(2));
          if (!valid) {
            return {
              error: new Error("The fingerprint does not match the public key."),
              valid: false
            };
          }
          return { valid };
        }
      };
      function ed25519SignerFactory(key) {
        if (!key.privateKeyBase58) {
          return {
            async sign() {
              throw new Error("No private key to sign with.");
            }
          };
        }
        if (env.nodejs && require_semver().gte(process.version, "12.0.0")) {
          const bs58 = require_bs58();
          const privateKeyBytes = util.base58Decode({
            decode: bs58.decode,
            keyMaterial: key.privateKeyBase58,
            type: "private"
          });
          const _privateKey = require_ed25519PrivateKeyNode12();
          const privateKey2 = _privateKey.create({ privateKeyBytes });
          const { sign } = require_crypto();
          return {
            async sign({ data }) {
              const signature = sign(null, Buffer.from(data.buffer, data.byteOffset, data.length), privateKey2);
              return signature;
            }
          };
        }
        if (env.nodejs) {
          const sodium = require_sodium_native();
          const bs58 = require_bs58();
          const privateKey2 = util.base58Decode({
            decode: bs58.decode,
            keyMaterial: key.privateKeyBase58,
            type: "private"
          });
          return {
            async sign({ data }) {
              const signature = Buffer.alloc(sodium.crypto_sign_BYTES);
              await sodium.crypto_sign_detached(signature, Buffer.from(data.buffer, data.byteOffset, data.length), privateKey2);
              return signature;
            }
          };
        }
        const privateKey = util.base58Decode({
          decode: base58.decode,
          keyMaterial: key.privateKeyBase58,
          type: "private"
        });
        return {
          async sign({ data }) {
            return ed25519.sign({ message: data, privateKey });
          }
        };
      }
      function ed25519VerifierFactory(key) {
        if (env.nodejs && require_semver().gte(process.version, "12.0.0")) {
          const bs58 = require_bs58();
          const publicKeyBytes = util.base58Decode({
            decode: bs58.decode,
            keyMaterial: key.publicKeyBase58,
            type: "public"
          });
          const _publicKey = require_ed25519PublicKeyNode12();
          const publicKey2 = _publicKey.create({ publicKeyBytes });
          const { verify } = require_crypto();
          return {
            async verify({ data, signature }) {
              return verify(null, Buffer.from(data.buffer, data.byteOffset, data.length), publicKey2, signature);
            }
          };
        }
        if (env.nodejs) {
          const sodium = require_sodium_native();
          const bs58 = require_bs58();
          const publicKey2 = util.base58Decode({
            decode: bs58.decode,
            keyMaterial: key.publicKeyBase58,
            type: "public"
          });
          return {
            async verify({ data, signature }) {
              return sodium.crypto_sign_verify_detached(Buffer.from(signature.buffer, signature.byteOffset, signature.length), Buffer.from(data.buffer, data.byteOffset, data.length), publicKey2);
            }
          };
        }
        const publicKey = util.base58Decode({
          decode: base58.decode,
          keyMaterial: key.publicKeyBase58,
          type: "public"
        });
        return {
          async verify({ data, signature }) {
            return ed25519.verify({ message: data, signature, publicKey });
          }
        };
      }
      module.exports = Ed25519KeyPair;
    }
  });

  // node_modules/crypto-ld/lib/index.js
  var require_lib3 = __commonJS({
    "node_modules/crypto-ld/lib/index.js"(exports, module) {
      "use strict";
      module.exports = {
        Ed25519KeyPair: require_Ed25519KeyPair(),
        LDKeyPair: require_LDKeyPair(),
        RSAKeyPair: require_RSAKeyPair()
      };
    }
  });

  // node_modules/rdf-canonize/lib/util.js
  var require_util7 = __commonJS({
    "node_modules/rdf-canonize/lib/util.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      var _setImmediate = typeof setImmediate === "function" && setImmediate;
      var _delay = _setImmediate ? (fn) => _setImmediate(fn) : (fn) => setTimeout(fn, 0);
      if (typeof process === "object" && typeof process.nextTick === "function") {
        api.nextTick = process.nextTick;
      } else {
        api.nextTick = _delay;
      }
      api.setImmediate = _setImmediate ? _delay : api.nextTick;
      api.clone = function(value) {
        if (value && typeof value === "object") {
          let rval;
          if (Array.isArray(value)) {
            rval = [];
            for (let i = 0; i < value.length; ++i) {
              rval[i] = api.clone(value[i]);
            }
          } else if (api.isObject(value)) {
            rval = {};
            for (const key in value) {
              rval[key] = api.clone(value[key]);
            }
          } else {
            rval = value.toString();
          }
          return rval;
        }
        return value;
      };
      api.isObject = (v) => Object.prototype.toString.call(v) === "[object Object]";
      api.isUndefined = (v) => typeof v === "undefined";
      api.callbackify = (fn) => {
        return async function(...args) {
          const callback = args[args.length - 1];
          if (typeof callback === "function") {
            args.pop();
          }
          let result;
          try {
            result = await fn.apply(null, args);
          } catch (e) {
            if (typeof callback === "function") {
              return _invokeCallback(callback, e);
            }
            throw e;
          }
          if (typeof callback === "function") {
            return _invokeCallback(callback, null, result);
          }
          return result;
        };
      };
      function _invokeCallback(callback, err, result) {
        try {
          return callback(err, result);
        } catch (unhandledError) {
          process.nextTick(() => {
            throw unhandledError;
          });
        }
      }
    }
  });

  // node_modules/rdf-canonize/lib/AsyncAlgorithm.js
  var require_AsyncAlgorithm = __commonJS({
    "node_modules/rdf-canonize/lib/AsyncAlgorithm.js"(exports, module) {
      "use strict";
      var util = require_util7();
      module.exports = class AsyncAlgorithm {
        constructor({
          maxCallStackDepth = 500,
          maxTotalCallStackDepth = 4294967295,
          timeSlice = 10
        } = {}) {
          this.schedule = {};
          this.schedule.MAX_DEPTH = maxCallStackDepth;
          this.schedule.MAX_TOTAL_DEPTH = maxTotalCallStackDepth;
          this.schedule.depth = 0;
          this.schedule.totalDepth = 0;
          this.schedule.timeSlice = timeSlice;
        }
        doWork(fn, callback) {
          const schedule = this.schedule;
          if (schedule.totalDepth >= schedule.MAX_TOTAL_DEPTH) {
            return callback(new Error("Maximum total call stack depth exceeded; canonicalization aborting."));
          }
          (function work() {
            if (schedule.depth === schedule.MAX_DEPTH) {
              schedule.depth = 0;
              schedule.running = false;
              return util.nextTick(work);
            }
            const now = Date.now();
            if (!schedule.running) {
              schedule.start = Date.now();
              schedule.deadline = schedule.start + schedule.timeSlice;
            }
            if (now < schedule.deadline) {
              schedule.running = true;
              schedule.depth++;
              schedule.totalDepth++;
              return fn((err, result) => {
                schedule.depth--;
                schedule.totalDepth--;
                callback(err, result);
              });
            }
            schedule.depth = 0;
            schedule.running = false;
            util.setImmediate(work);
          })();
        }
        forEach(iterable, fn, callback) {
          const self2 = this;
          let iterator;
          let idx = 0;
          let length;
          if (Array.isArray(iterable)) {
            length = iterable.length;
            iterator = () => {
              if (idx === length) {
                return false;
              }
              iterator.value = iterable[idx++];
              iterator.key = idx;
              return true;
            };
          } else {
            const keys = Object.keys(iterable);
            length = keys.length;
            iterator = () => {
              if (idx === length) {
                return false;
              }
              iterator.key = keys[idx++];
              iterator.value = iterable[iterator.key];
              return true;
            };
          }
          (function iterate(err) {
            if (err) {
              return callback(err);
            }
            if (iterator()) {
              return self2.doWork(() => fn(iterator.value, iterator.key, iterate));
            }
            callback();
          })();
        }
        waterfall(fns, callback) {
          const self2 = this;
          self2.forEach(fns, (fn, idx, callback2) => self2.doWork(fn, callback2), callback);
        }
        whilst(condition, fn, callback) {
          const self2 = this;
          (function loop(err) {
            if (err) {
              return callback(err);
            }
            if (!condition()) {
              return callback();
            }
            self2.doWork(fn, loop);
          })();
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/IdentifierIssuer.js
  var require_IdentifierIssuer2 = __commonJS({
    "node_modules/rdf-canonize/lib/IdentifierIssuer.js"(exports, module) {
      "use strict";
      var util = require_util7();
      module.exports = class IdentifierIssuer {
        constructor(prefix) {
          this.prefix = prefix;
          this.counter = 0;
          this.existing = {};
        }
        clone() {
          const copy = new IdentifierIssuer(this.prefix);
          copy.counter = this.counter;
          copy.existing = util.clone(this.existing);
          return copy;
        }
        getId(old) {
          if (old && old in this.existing) {
            return this.existing[old];
          }
          const identifier = this.prefix + this.counter;
          this.counter += 1;
          if (old) {
            this.existing[old] = identifier;
          }
          return identifier;
        }
        hasId(old) {
          return old in this.existing;
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/MessageDigest-browser.js
  var require_MessageDigest_browser2 = __commonJS({
    "node_modules/rdf-canonize/lib/MessageDigest-browser.js"(exports, module) {
      "use strict";
      var forge = require_forge();
      require_md();
      require_sha1();
      require_sha256();
      module.exports = class MessageDigest {
        constructor(algorithm) {
          this.md = forge.md[algorithm].create();
        }
        update(msg) {
          this.md.update(msg, "utf8");
        }
        digest() {
          return this.md.digest().toHex();
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/Permutator.js
  var require_Permutator = __commonJS({
    "node_modules/rdf-canonize/lib/Permutator.js"(exports, module) {
      "use strict";
      module.exports = class Permutator {
        constructor(list) {
          this.list = list.sort();
          this.done = false;
          this.left = {};
          for (let i = 0; i < list.length; ++i) {
            this.left[list[i]] = true;
          }
        }
        hasNext() {
          return !this.done;
        }
        next() {
          const rval = this.list.slice();
          let k = null;
          let pos = 0;
          const length = this.list.length;
          for (let i = 0; i < length; ++i) {
            const element = this.list[i];
            const left = this.left[element];
            if ((k === null || element > k) && (left && i > 0 && element > this.list[i - 1] || !left && i < length - 1 && element > this.list[i + 1])) {
              k = element;
              pos = i;
            }
          }
          if (k === null) {
            this.done = true;
          } else {
            const swap = this.left[k] ? pos - 1 : pos + 1;
            this.list[pos] = this.list[swap];
            this.list[swap] = k;
            for (let i = 0; i < length; ++i) {
              if (this.list[i] > k) {
                this.left[this.list[i]] = !this.left[this.list[i]];
              }
            }
          }
          return rval;
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/NQuads.js
  var require_NQuads3 = __commonJS({
    "node_modules/rdf-canonize/lib/NQuads.js"(exports, module) {
      "use strict";
      var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      var RDF_LANGSTRING = RDF + "langString";
      var XSD_STRING = "http://www.w3.org/2001/XMLSchema#string";
      var REGEX = {};
      (() => {
        const iri = "(?:<([^:]+:[^>]*)>)";
        const PN_CHARS_BASE = "A-Za-z\xC0-\xD6\xD8-\xF6\xF8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD";
        const PN_CHARS_U = PN_CHARS_BASE + "_";
        const PN_CHARS = PN_CHARS_U + "0-9-\xB7\u0300-\u036F\u203F-\u2040";
        const BLANK_NODE_LABEL = "(_:(?:[" + PN_CHARS_U + "0-9])(?:(?:[" + PN_CHARS + ".])*(?:[" + PN_CHARS + "]))?)";
        const bnode = BLANK_NODE_LABEL;
        const plain = '"([^"\\\\]*(?:\\\\.[^"\\\\]*)*)"';
        const datatype = "(?:\\^\\^" + iri + ")";
        const language = "(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))";
        const literal = "(?:" + plain + "(?:" + datatype + "|" + language + ")?)";
        const ws = "[ \\t]+";
        const wso = "[ \\t]*";
        const subject = "(?:" + iri + "|" + bnode + ")" + ws;
        const property = iri + ws;
        const object = "(?:" + iri + "|" + bnode + "|" + literal + ")" + wso;
        const graphName = "(?:\\.|(?:(?:" + iri + "|" + bnode + ")" + wso + "\\.))";
        REGEX.eoln = /(?:\r\n)|(?:\n)|(?:\r)/g;
        REGEX.empty = new RegExp("^" + wso + "$");
        REGEX.quad = new RegExp("^" + wso + subject + property + object + graphName + wso + "$");
      })();
      module.exports = class NQuads {
        static parse(input) {
          const dataset = [];
          const graphs = {};
          const lines = input.split(REGEX.eoln);
          let lineNumber = 0;
          for (const line of lines) {
            lineNumber++;
            if (REGEX.empty.test(line)) {
              continue;
            }
            const match = line.match(REGEX.quad);
            if (match === null) {
              throw new Error("N-Quads parse error on line " + lineNumber + ".");
            }
            const quad = {};
            if (match[1] !== void 0) {
              quad.subject = { termType: "NamedNode", value: match[1] };
            } else {
              quad.subject = { termType: "BlankNode", value: match[2] };
            }
            quad.predicate = { termType: "NamedNode", value: match[3] };
            if (match[4] !== void 0) {
              quad.object = { termType: "NamedNode", value: match[4] };
            } else if (match[5] !== void 0) {
              quad.object = { termType: "BlankNode", value: match[5] };
            } else {
              quad.object = {
                termType: "Literal",
                value: void 0,
                datatype: {
                  termType: "NamedNode"
                }
              };
              if (match[7] !== void 0) {
                quad.object.datatype.value = match[7];
              } else if (match[8] !== void 0) {
                quad.object.datatype.value = RDF_LANGSTRING;
                quad.object.language = match[8];
              } else {
                quad.object.datatype.value = XSD_STRING;
              }
              quad.object.value = _unescape(match[6]);
            }
            if (match[9] !== void 0) {
              quad.graph = {
                termType: "NamedNode",
                value: match[9]
              };
            } else if (match[10] !== void 0) {
              quad.graph = {
                termType: "BlankNode",
                value: match[10]
              };
            } else {
              quad.graph = {
                termType: "DefaultGraph",
                value: ""
              };
            }
            if (!(quad.graph.value in graphs)) {
              graphs[quad.graph.value] = [quad];
              dataset.push(quad);
            } else {
              let unique = true;
              const quads = graphs[quad.graph.value];
              for (const q of quads) {
                if (_compareTriples(q, quad)) {
                  unique = false;
                  break;
                }
              }
              if (unique) {
                quads.push(quad);
                dataset.push(quad);
              }
            }
          }
          return dataset;
        }
        static serialize(dataset) {
          if (!Array.isArray(dataset)) {
            dataset = NQuads.legacyDatasetToQuads(dataset);
          }
          const quads = [];
          for (const quad of dataset) {
            quads.push(NQuads.serializeQuad(quad));
          }
          return quads.sort().join("");
        }
        static serializeQuad(quad) {
          const s = quad.subject;
          const p = quad.predicate;
          const o = quad.object;
          const g = quad.graph;
          let nquad = "";
          [s, p].forEach((term) => {
            if (term.termType === "NamedNode") {
              nquad += "<" + term.value + ">";
            } else {
              nquad += term.value;
            }
            nquad += " ";
          });
          if (o.termType === "NamedNode") {
            nquad += "<" + o.value + ">";
          } else if (o.termType === "BlankNode") {
            nquad += o.value;
          } else {
            nquad += '"' + _escape(o.value) + '"';
            if (o.datatype.value === RDF_LANGSTRING) {
              if (o.language) {
                nquad += "@" + o.language;
              }
            } else if (o.datatype.value !== XSD_STRING) {
              nquad += "^^<" + o.datatype.value + ">";
            }
          }
          if (g.termType === "NamedNode") {
            nquad += " <" + g.value + ">";
          } else if (g.termType === "BlankNode") {
            nquad += " " + g.value;
          }
          nquad += " .\n";
          return nquad;
        }
        static legacyDatasetToQuads(dataset) {
          const quads = [];
          const termTypeMap = {
            "blank node": "BlankNode",
            IRI: "NamedNode",
            literal: "Literal"
          };
          for (const graphName in dataset) {
            const triples = dataset[graphName];
            triples.forEach((triple) => {
              const quad = {};
              for (const componentName in triple) {
                const oldComponent = triple[componentName];
                const newComponent = {
                  termType: termTypeMap[oldComponent.type],
                  value: oldComponent.value
                };
                if (newComponent.termType === "Literal") {
                  newComponent.datatype = {
                    termType: "NamedNode"
                  };
                  if ("datatype" in oldComponent) {
                    newComponent.datatype.value = oldComponent.datatype;
                  }
                  if ("language" in oldComponent) {
                    if (!("datatype" in oldComponent)) {
                      newComponent.datatype.value = RDF_LANGSTRING;
                    }
                    newComponent.language = oldComponent.language;
                  } else if (!("datatype" in oldComponent)) {
                    newComponent.datatype.value = XSD_STRING;
                  }
                }
                quad[componentName] = newComponent;
              }
              if (graphName === "@default") {
                quad.graph = {
                  termType: "DefaultGraph",
                  value: ""
                };
              } else {
                quad.graph = {
                  termType: graphName.startsWith("_:") ? "BlankNode" : "NamedNode",
                  value: graphName
                };
              }
              quads.push(quad);
            });
          }
          return quads;
        }
      };
      function _compareTriples(t1, t2) {
        for (const k in t1) {
          if (t1[k].termType !== t2[k].termType || t1[k].value !== t2[k].value) {
            return false;
          }
        }
        if (t1.object.termType !== "Literal") {
          return true;
        }
        return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.datatype.value === t2.object.datatype.value && t1.object.language === t2.object.language;
      }
      var _escapeRegex = /["\\\n\r]/g;
      function _escape(s) {
        return s.replace(_escapeRegex, function(match) {
          switch (match) {
            case '"':
              return '\\"';
            case "\\":
              return "\\\\";
            case "\n":
              return "\\n";
            case "\r":
              return "\\r";
          }
        });
      }
      var _unescapeRegex = /(?:\\([tbnrf"'\\]))|(?:\\u([0-9A-Fa-f]{4}))|(?:\\U([0-9A-Fa-f]{8}))/g;
      function _unescape(s) {
        return s.replace(_unescapeRegex, function(match, code, u, U) {
          if (code) {
            switch (code) {
              case "t":
                return "	";
              case "b":
                return "\b";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "f":
                return "\f";
              case '"':
                return '"';
              case "'":
                return "'";
              case "\\":
                return "\\";
            }
          }
          if (u) {
            return String.fromCharCode(parseInt(u, 16));
          }
          if (U) {
            throw new Error("Unsupported U escape");
          }
        });
      }
    }
  });

  // node_modules/rdf-canonize/lib/URDNA2015.js
  var require_URDNA20152 = __commonJS({
    "node_modules/rdf-canonize/lib/URDNA2015.js"(exports, module) {
      "use strict";
      var AsyncAlgorithm = require_AsyncAlgorithm();
      var IdentifierIssuer = require_IdentifierIssuer2();
      var MessageDigest = require_MessageDigest_browser2();
      var Permutator = require_Permutator();
      var NQuads = require_NQuads3();
      var util = require_util7();
      var POSITIONS = { subject: "s", object: "o", graph: "g" };
      module.exports = class URDNA2015 extends AsyncAlgorithm {
        constructor(options) {
          options = options || {};
          super(options);
          this.name = "URDNA2015";
          this.options = Object.assign({}, options);
          this.blankNodeInfo = {};
          this.hashToBlankNodes = {};
          this.canonicalIssuer = new IdentifierIssuer("_:c14n");
          this.hashAlgorithm = "sha256";
          this.quads;
        }
        main(dataset, callback) {
          const self2 = this;
          self2.schedule.start = Date.now();
          let result;
          self2.quads = dataset;
          const nonNormalized = {};
          self2.waterfall([
            (callback2) => {
              self2.forEach(dataset, (quad, idx, callback3) => {
                self2.forEachComponent(quad, (component) => {
                  if (component.termType !== "BlankNode") {
                    return;
                  }
                  const id = component.value;
                  if (id in self2.blankNodeInfo) {
                    self2.blankNodeInfo[id].quads.push(quad);
                  } else {
                    nonNormalized[id] = true;
                    self2.blankNodeInfo[id] = { quads: [quad] };
                  }
                });
                callback3();
              }, callback2);
            },
            (callback2) => {
              let simple = true;
              self2.whilst(() => simple, (callback3) => {
                simple = false;
                self2.hashToBlankNodes = {};
                self2.waterfall([
                  (callback4) => {
                    self2.forEach(nonNormalized, (value, id, callback5) => {
                      self2.hashFirstDegreeQuads(id, (err, hash) => {
                        if (err) {
                          return callback5(err);
                        }
                        if (hash in self2.hashToBlankNodes) {
                          self2.hashToBlankNodes[hash].push(id);
                        } else {
                          self2.hashToBlankNodes[hash] = [id];
                        }
                        callback5();
                      });
                    }, callback4);
                  },
                  (callback4) => {
                    const hashes = Object.keys(self2.hashToBlankNodes).sort();
                    self2.forEach(hashes, (hash, i, callback5) => {
                      const idList = self2.hashToBlankNodes[hash];
                      if (idList.length > 1) {
                        return callback5();
                      }
                      const id = idList[0];
                      self2.canonicalIssuer.getId(id);
                      delete nonNormalized[id];
                      delete self2.hashToBlankNodes[hash];
                      simple = true;
                      callback5();
                    }, callback4);
                  }
                ], callback3);
              }, callback2);
            },
            (callback2) => {
              const hashes = Object.keys(self2.hashToBlankNodes).sort();
              self2.forEach(hashes, (hash, idx, callback3) => {
                const hashPathList = [];
                const idList = self2.hashToBlankNodes[hash];
                self2.waterfall([
                  (callback4) => {
                    self2.forEach(idList, (id, idx2, callback5) => {
                      if (self2.canonicalIssuer.hasId(id)) {
                        return callback5();
                      }
                      const issuer = new IdentifierIssuer("_:b");
                      issuer.getId(id);
                      self2.hashNDegreeQuads(id, issuer, (err, result2) => {
                        if (err) {
                          return callback5(err);
                        }
                        hashPathList.push(result2);
                        callback5();
                      });
                    }, callback4);
                  },
                  (callback4) => {
                    hashPathList.sort((a, b) => a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0);
                    self2.forEach(hashPathList, (result2, idx2, callback5) => {
                      for (const existing in result2.issuer.existing) {
                        self2.canonicalIssuer.getId(existing);
                      }
                      callback5();
                    }, callback4);
                  }
                ], callback3);
              }, callback2);
            },
            (callback2) => {
              const normalized = [];
              self2.waterfall([
                (callback3) => {
                  self2.forEach(self2.quads, (quad, idx, callback4) => {
                    self2.forEachComponent(quad, (component) => {
                      if (component.termType === "BlankNode" && !component.value.startsWith(self2.canonicalIssuer.prefix)) {
                        component.value = self2.canonicalIssuer.getId(component.value);
                      }
                    });
                    normalized.push(NQuads.serializeQuad(quad));
                    callback4();
                  }, callback3);
                },
                (callback3) => {
                  normalized.sort();
                  result = normalized.join("");
                  return callback3();
                }
              ], callback2);
            }
          ], (err) => callback(err, result));
        }
        hashFirstDegreeQuads(id, callback) {
          const self2 = this;
          const info = self2.blankNodeInfo[id];
          if ("hash" in info) {
            return callback(null, info.hash);
          }
          const nquads = [];
          const quads = info.quads;
          self2.forEach(quads, (quad, idx, callback2) => {
            const copy = { predicate: quad.predicate };
            self2.forEachComponent(quad, (component, key) => {
              copy[key] = self2.modifyFirstDegreeComponent(id, component, key);
            });
            nquads.push(NQuads.serializeQuad(copy));
            callback2();
          }, (err) => {
            if (err) {
              return callback(err);
            }
            nquads.sort();
            const md = new MessageDigest(self2.hashAlgorithm);
            for (let i = 0; i < nquads.length; ++i) {
              md.update(nquads[i]);
            }
            info.hash = md.digest();
            callback(null, info.hash);
          });
        }
        hashRelatedBlankNode(related, quad, issuer, position, callback) {
          const self2 = this;
          let id;
          self2.waterfall([
            (callback2) => {
              if (self2.canonicalIssuer.hasId(related)) {
                id = self2.canonicalIssuer.getId(related);
                return callback2();
              }
              if (issuer.hasId(related)) {
                id = issuer.getId(related);
                return callback2();
              }
              self2.hashFirstDegreeQuads(related, (err, hash) => {
                if (err) {
                  return callback2(err);
                }
                id = hash;
                callback2();
              });
            }
          ], (err) => {
            if (err) {
              return callback(err);
            }
            const md = new MessageDigest(self2.hashAlgorithm);
            md.update(position);
            if (position !== "g") {
              md.update(self2.getRelatedPredicate(quad));
            }
            md.update(id);
            return callback(null, md.digest());
          });
        }
        hashNDegreeQuads(id, issuer, callback) {
          const self2 = this;
          let hashToRelated;
          const md = new MessageDigest(self2.hashAlgorithm);
          self2.waterfall([
            (callback2) => self2.createHashToRelated(id, issuer, (err, result) => {
              if (err) {
                return callback2(err);
              }
              hashToRelated = result;
              callback2();
            }),
            (callback2) => {
              const hashes = Object.keys(hashToRelated).sort();
              self2.forEach(hashes, (hash, idx, callback3) => {
                md.update(hash);
                let chosenPath = "";
                let chosenIssuer;
                const permutator = new Permutator(hashToRelated[hash]);
                self2.whilst(() => permutator.hasNext(), (nextPermutation) => {
                  const permutation = permutator.next();
                  let issuerCopy = issuer.clone();
                  let path = "";
                  const recursionList = [];
                  self2.waterfall([
                    (callback4) => {
                      self2.forEach(permutation, (related, idx2, callback5) => {
                        if (self2.canonicalIssuer.hasId(related)) {
                          path += self2.canonicalIssuer.getId(related);
                        } else {
                          if (!issuerCopy.hasId(related)) {
                            recursionList.push(related);
                          }
                          path += issuerCopy.getId(related);
                        }
                        if (chosenPath.length !== 0 && path > chosenPath) {
                          return nextPermutation();
                        }
                        callback5();
                      }, callback4);
                    },
                    (callback4) => {
                      self2.forEach(recursionList, (related, idx2, callback5) => {
                        self2.hashNDegreeQuads(related, issuerCopy, (err, result) => {
                          if (err) {
                            return callback5(err);
                          }
                          path += issuerCopy.getId(related);
                          path += "<" + result.hash + ">";
                          issuerCopy = result.issuer;
                          if (chosenPath.length !== 0 && path > chosenPath) {
                            return nextPermutation();
                          }
                          callback5();
                        });
                      }, callback4);
                    },
                    (callback4) => {
                      if (chosenPath.length === 0 || path < chosenPath) {
                        chosenPath = path;
                        chosenIssuer = issuerCopy;
                      }
                      callback4();
                    }
                  ], nextPermutation);
                }, (err) => {
                  if (err) {
                    return callback3(err);
                  }
                  md.update(chosenPath);
                  issuer = chosenIssuer;
                  callback3();
                });
              }, callback2);
            }
          ], (err) => {
            callback(err, { hash: md.digest(), issuer });
          });
        }
        modifyFirstDegreeComponent(id, component) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          component = util.clone(component);
          component.value = component.value === id ? "_:a" : "_:z";
          return component;
        }
        getRelatedPredicate(quad) {
          return "<" + quad.predicate.value + ">";
        }
        createHashToRelated(id, issuer, callback) {
          const self2 = this;
          const hashToRelated = {};
          const quads = self2.blankNodeInfo[id].quads;
          self2.forEach(quads, (quad, idx, callback2) => {
            self2.forEach(quad, (component, key, callback3) => {
              if (key === "predicate" || !(component.termType === "BlankNode" && component.value !== id)) {
                return callback3();
              }
              const related = component.value;
              const position = POSITIONS[key];
              self2.hashRelatedBlankNode(related, quad, issuer, position, (err, hash) => {
                if (err) {
                  return callback3(err);
                }
                if (hash in hashToRelated) {
                  hashToRelated[hash].push(related);
                } else {
                  hashToRelated[hash] = [related];
                }
                callback3();
              });
            }, callback2);
          }, (err) => callback(err, hashToRelated));
        }
        forEachComponent(quad, op) {
          for (const key in quad) {
            if (key === "predicate") {
              continue;
            }
            op(quad[key], key, quad);
          }
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/URGNA2012.js
  var require_URGNA20122 = __commonJS({
    "node_modules/rdf-canonize/lib/URGNA2012.js"(exports, module) {
      "use strict";
      var URDNA2015 = require_URDNA20152();
      var util = require_util7();
      module.exports = class URDNA2012 extends URDNA2015 {
        constructor(options) {
          super(options);
          this.name = "URGNA2012";
          this.hashAlgorithm = "sha1";
        }
        modifyFirstDegreeComponent(id, component, key) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          component = util.clone(component);
          if (key === "name") {
            component.value = "_:g";
          } else {
            component.value = component.value === id ? "_:a" : "_:z";
          }
          return component;
        }
        getRelatedPredicate(quad) {
          return quad.predicate.value;
        }
        createHashToRelated(id, issuer, callback) {
          const self2 = this;
          const hashToRelated = {};
          const quads = self2.blankNodeInfo[id].quads;
          self2.forEach(quads, (quad, idx, callback2) => {
            let position;
            let related;
            if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
              related = quad.subject.value;
              position = "p";
            } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
              related = quad.object.value;
              position = "r";
            } else {
              return callback2();
            }
            self2.hashRelatedBlankNode(related, quad, issuer, position, (err, hash) => {
              if (err) {
                return callback2(err);
              }
              if (hash in hashToRelated) {
                hashToRelated[hash].push(related);
              } else {
                hashToRelated[hash] = [related];
              }
              callback2();
            });
          }, (err) => callback(err, hashToRelated));
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/URDNA2015Sync.js
  var require_URDNA2015Sync2 = __commonJS({
    "node_modules/rdf-canonize/lib/URDNA2015Sync.js"(exports, module) {
      "use strict";
      var IdentifierIssuer = require_IdentifierIssuer2();
      var MessageDigest = require_MessageDigest_browser2();
      var Permutator = require_Permutator();
      var NQuads = require_NQuads3();
      var util = require_util7();
      var POSITIONS = { subject: "s", object: "o", graph: "g" };
      module.exports = class URDNA2015Sync {
        constructor() {
          this.name = "URDNA2015";
          this.blankNodeInfo = {};
          this.hashToBlankNodes = {};
          this.canonicalIssuer = new IdentifierIssuer("_:c14n");
          this.hashAlgorithm = "sha256";
          this.quads;
        }
        main(dataset) {
          const self2 = this;
          self2.quads = dataset;
          const nonNormalized = {};
          for (const quad of dataset) {
            self2.forEachComponent(quad, (component) => {
              if (component.termType !== "BlankNode") {
                return;
              }
              const id = component.value;
              if (id in self2.blankNodeInfo) {
                self2.blankNodeInfo[id].quads.push(quad);
              } else {
                nonNormalized[id] = true;
                self2.blankNodeInfo[id] = { quads: [quad] };
              }
            });
          }
          let simple = true;
          while (simple) {
            simple = false;
            self2.hashToBlankNodes = {};
            for (const id in nonNormalized) {
              const hash = self2.hashFirstDegreeQuads(id);
              if (hash in self2.hashToBlankNodes) {
                self2.hashToBlankNodes[hash].push(id);
              } else {
                self2.hashToBlankNodes[hash] = [id];
              }
            }
            const hashes2 = Object.keys(self2.hashToBlankNodes).sort();
            for (let i = 0; i < hashes2.length; ++i) {
              const hash = hashes2[i];
              const idList = self2.hashToBlankNodes[hash];
              if (idList.length > 1) {
                continue;
              }
              const id = idList[0];
              self2.canonicalIssuer.getId(id);
              delete nonNormalized[id];
              delete self2.hashToBlankNodes[hash];
              simple = true;
            }
          }
          const hashes = Object.keys(self2.hashToBlankNodes).sort();
          for (let i = 0; i < hashes.length; ++i) {
            const hashPathList = [];
            const hash = hashes[i];
            const idList = self2.hashToBlankNodes[hash];
            for (let j = 0; j < idList.length; ++j) {
              const id = idList[j];
              if (self2.canonicalIssuer.hasId(id)) {
                continue;
              }
              const issuer = new IdentifierIssuer("_:b");
              issuer.getId(id);
              const result = self2.hashNDegreeQuads(id, issuer);
              hashPathList.push(result);
            }
            hashPathList.sort((a, b) => a.hash < b.hash ? -1 : a.hash > b.hash ? 1 : 0);
            for (let j = 0; j < hashPathList.length; ++j) {
              const result = hashPathList[j];
              for (const existing in result.issuer.existing) {
                self2.canonicalIssuer.getId(existing);
              }
            }
          }
          const normalized = [];
          for (let i = 0; i < self2.quads.length; ++i) {
            const quad = self2.quads[i];
            self2.forEachComponent(quad, (component) => {
              if (component.termType === "BlankNode" && !component.value.startsWith(self2.canonicalIssuer.prefix)) {
                component.value = self2.canonicalIssuer.getId(component.value);
              }
            });
            normalized.push(NQuads.serializeQuad(quad));
          }
          normalized.sort();
          return normalized.join("");
        }
        hashFirstDegreeQuads(id) {
          const self2 = this;
          const info = self2.blankNodeInfo[id];
          if ("hash" in info) {
            return info.hash;
          }
          const nquads = [];
          const quads = info.quads;
          for (let i = 0; i < quads.length; ++i) {
            const quad = quads[i];
            const copy = { predicate: quad.predicate };
            self2.forEachComponent(quad, (component, key) => {
              copy[key] = self2.modifyFirstDegreeComponent(id, component, key);
            });
            nquads.push(NQuads.serializeQuad(copy));
          }
          nquads.sort();
          const md = new MessageDigest(self2.hashAlgorithm);
          for (let i = 0; i < nquads.length; ++i) {
            md.update(nquads[i]);
          }
          info.hash = md.digest();
          return info.hash;
        }
        hashRelatedBlankNode(related, quad, issuer, position) {
          const self2 = this;
          let id;
          if (self2.canonicalIssuer.hasId(related)) {
            id = self2.canonicalIssuer.getId(related);
          } else if (issuer.hasId(related)) {
            id = issuer.getId(related);
          } else {
            id = self2.hashFirstDegreeQuads(related);
          }
          const md = new MessageDigest(self2.hashAlgorithm);
          md.update(position);
          if (position !== "g") {
            md.update(self2.getRelatedPredicate(quad));
          }
          md.update(id);
          return md.digest();
        }
        hashNDegreeQuads(id, issuer) {
          const self2 = this;
          const md = new MessageDigest(self2.hashAlgorithm);
          const hashToRelated = self2.createHashToRelated(id, issuer);
          const hashes = Object.keys(hashToRelated).sort();
          for (let i = 0; i < hashes.length; ++i) {
            const hash = hashes[i];
            md.update(hash);
            let chosenPath = "";
            let chosenIssuer;
            const permutator = new Permutator(hashToRelated[hash]);
            while (permutator.hasNext()) {
              const permutation = permutator.next();
              let issuerCopy = issuer.clone();
              let path = "";
              const recursionList = [];
              let nextPermutation = false;
              for (let j = 0; j < permutation.length; ++j) {
                const related = permutation[j];
                if (self2.canonicalIssuer.hasId(related)) {
                  path += self2.canonicalIssuer.getId(related);
                } else {
                  if (!issuerCopy.hasId(related)) {
                    recursionList.push(related);
                  }
                  path += issuerCopy.getId(related);
                }
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              for (let j = 0; j < recursionList.length; ++j) {
                const related = recursionList[j];
                const result = self2.hashNDegreeQuads(related, issuerCopy);
                path += issuerCopy.getId(related);
                path += "<" + result.hash + ">";
                issuerCopy = result.issuer;
                if (chosenPath.length !== 0 && path > chosenPath) {
                  nextPermutation = true;
                  break;
                }
              }
              if (nextPermutation) {
                continue;
              }
              if (chosenPath.length === 0 || path < chosenPath) {
                chosenPath = path;
                chosenIssuer = issuerCopy;
              }
            }
            md.update(chosenPath);
            issuer = chosenIssuer;
          }
          return { hash: md.digest(), issuer };
        }
        modifyFirstDegreeComponent(id, component) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          component = util.clone(component);
          component.value = component.value === id ? "_:a" : "_:z";
          return component;
        }
        getRelatedPredicate(quad) {
          return "<" + quad.predicate.value + ">";
        }
        createHashToRelated(id, issuer) {
          const self2 = this;
          const hashToRelated = {};
          const quads = self2.blankNodeInfo[id].quads;
          for (let i = 0; i < quads.length; ++i) {
            const quad = quads[i];
            for (const key in quad) {
              const component = quad[key];
              if (key === "predicate" || !(component.termType === "BlankNode" && component.value !== id)) {
                continue;
              }
              const related = component.value;
              const position = POSITIONS[key];
              const hash = self2.hashRelatedBlankNode(related, quad, issuer, position);
              if (hash in hashToRelated) {
                hashToRelated[hash].push(related);
              } else {
                hashToRelated[hash] = [related];
              }
            }
          }
          return hashToRelated;
        }
        forEachComponent(quad, op) {
          for (const key in quad) {
            if (key === "predicate") {
              continue;
            }
            op(quad[key], key, quad);
          }
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/URGNA2012Sync.js
  var require_URGNA2012Sync2 = __commonJS({
    "node_modules/rdf-canonize/lib/URGNA2012Sync.js"(exports, module) {
      "use strict";
      var URDNA2015Sync = require_URDNA2015Sync2();
      var util = require_util7();
      module.exports = class URDNA2012Sync extends URDNA2015Sync {
        constructor() {
          super();
          this.name = "URGNA2012";
          this.hashAlgorithm = "sha1";
        }
        modifyFirstDegreeComponent(id, component, key) {
          if (component.termType !== "BlankNode") {
            return component;
          }
          component = util.clone(component);
          if (key === "name") {
            component.value = "_:g";
          } else {
            component.value = component.value === id ? "_:a" : "_:z";
          }
          return component;
        }
        getRelatedPredicate(quad) {
          return quad.predicate.value;
        }
        createHashToRelated(id, issuer) {
          const self2 = this;
          const hashToRelated = {};
          const quads = self2.blankNodeInfo[id].quads;
          for (let i = 0; i < quads.length; ++i) {
            const quad = quads[i];
            let position;
            let related;
            if (quad.subject.termType === "BlankNode" && quad.subject.value !== id) {
              related = quad.subject.value;
              position = "p";
            } else if (quad.object.termType === "BlankNode" && quad.object.value !== id) {
              related = quad.object.value;
              position = "r";
            } else {
              continue;
            }
            const hash = self2.hashRelatedBlankNode(related, quad, issuer, position);
            if (hash in hashToRelated) {
              hashToRelated[hash].push(related);
            } else {
              hashToRelated[hash] = [related];
            }
          }
          return hashToRelated;
        }
      };
    }
  });

  // node_modules/rdf-canonize/lib/index.js
  var require_lib4 = __commonJS({
    "node_modules/rdf-canonize/lib/index.js"(exports, module) {
      "use strict";
      var util = require_util7();
      var URDNA2015 = require_URDNA20152();
      var URGNA2012 = require_URGNA20122();
      var URDNA2015Sync = require_URDNA2015Sync2();
      var URGNA2012Sync = require_URGNA2012Sync2();
      var rdfCanonizeNative;
      try {
        rdfCanonizeNative = require_rdf_canonize_native();
      } catch (e) {
      }
      var api = {};
      module.exports = api;
      api.NQuads = require_NQuads3();
      api.IdentifierIssuer = require_IdentifierIssuer2();
      api._rdfCanonizeNative = function(api2) {
        if (api2) {
          rdfCanonizeNative = api2;
        }
        return rdfCanonizeNative;
      };
      api.canonize = util.callbackify(async function(dataset, options) {
        let callback;
        const promise = new Promise((resolve, reject) => {
          callback = (err, canonical) => {
            if (err) {
              return reject(err);
            }
            resolve(canonical);
          };
        });
        if (!Array.isArray(dataset)) {
          dataset = api.NQuads.legacyDatasetToQuads(dataset);
        }
        if (options.useNative) {
          if (rdfCanonizeNative) {
            rdfCanonizeNative.canonize(dataset, options, callback);
          } else {
            throw new Error("rdf-canonize-native not available");
          }
        } else {
          if (options.algorithm === "URDNA2015") {
            new URDNA2015(options).main(dataset, callback);
          } else if (options.algorithm === "URGNA2012") {
            new URGNA2012(options).main(dataset, callback);
          } else if (!("algorithm" in options)) {
            throw new Error("No RDF Dataset Canonicalization algorithm specified.");
          } else {
            throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm);
          }
        }
        return promise;
      });
      api.canonizeSync = function(dataset, options) {
        if (!Array.isArray(dataset)) {
          dataset = api.NQuads.legacyDatasetToQuads(dataset);
        }
        if (options.useNative) {
          if (rdfCanonizeNative) {
            return rdfCanonizeNative.canonizeSync(dataset, options);
          }
          throw new Error("rdf-canonize-native not available");
        }
        if (options.algorithm === "URDNA2015") {
          return new URDNA2015Sync(options).main(dataset);
        } else if (options.algorithm === "URGNA2012") {
          return new URGNA2012Sync(options).main(dataset);
        }
        if (!("algorithm" in options)) {
          throw new Error("No RDF Dataset Canonicalization algorithm specified.");
        }
        throw new Error("Invalid RDF Dataset Canonicalization algorithm: " + options.algorithm);
      };
    }
  });

  // node_modules/jsonld/lib/types.js
  var require_types2 = __commonJS({
    "node_modules/jsonld/lib/types.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.isArray = Array.isArray;
      api.isBoolean = (v) => typeof v === "boolean" || Object.prototype.toString.call(v) === "[object Boolean]";
      api.isDouble = (v) => api.isNumber(v) && String(v).indexOf(".") !== -1;
      api.isEmptyObject = (v) => api.isObject(v) && Object.keys(v).length === 0;
      api.isNumber = (v) => typeof v === "number" || Object.prototype.toString.call(v) === "[object Number]";
      api.isNumeric = (v) => !isNaN(parseFloat(v)) && isFinite(v);
      api.isObject = (v) => Object.prototype.toString.call(v) === "[object Object]";
      api.isString = (v) => typeof v === "string" || Object.prototype.toString.call(v) === "[object String]";
      api.isUndefined = (v) => typeof v === "undefined";
    }
  });

  // node_modules/jsonld/lib/graphTypes.js
  var require_graphTypes2 = __commonJS({
    "node_modules/jsonld/lib/graphTypes.js"(exports, module) {
      "use strict";
      var types = require_types2();
      var api = {};
      module.exports = api;
      api.isSubject = (v) => {
        if (types.isObject(v) && !("@value" in v || "@set" in v || "@list" in v)) {
          const keyCount = Object.keys(v).length;
          return keyCount > 1 || !("@id" in v);
        }
        return false;
      };
      api.isSubjectReference = (v) => types.isObject(v) && Object.keys(v).length === 1 && "@id" in v;
      api.isValue = (v) => types.isObject(v) && "@value" in v;
      api.isList = (v) => types.isObject(v) && "@list" in v;
      api.isGraph = (v) => {
        return types.isObject(v) && "@graph" in v && Object.keys(v).filter((key) => key !== "@id" && key !== "@index").length === 1;
      };
      api.isSimpleGraph = (v) => {
        return api.isGraph(v) && !("@id" in v);
      };
      api.isBlankNode = (v) => {
        if (types.isObject(v)) {
          if ("@id" in v) {
            return v["@id"].indexOf("_:") === 0;
          }
          return Object.keys(v).length === 0 || !("@value" in v || "@set" in v || "@list" in v);
        }
        return false;
      };
    }
  });

  // node_modules/jsonld/lib/JsonLdError.js
  var require_JsonLdError2 = __commonJS({
    "node_modules/jsonld/lib/JsonLdError.js"(exports, module) {
      "use strict";
      module.exports = class JsonLdError extends Error {
        constructor(message = "An unspecified JSON-LD error occurred.", name = "jsonld.Error", details = {}) {
          super(message);
          this.name = name;
          this.message = message;
          this.details = details;
        }
      };
    }
  });

  // node_modules/jsonld/lib/util.js
  var require_util8 = __commonJS({
    "node_modules/jsonld/lib/util.js"(exports, module) {
      "use strict";
      var graphTypes = require_graphTypes2();
      var types = require_types2();
      var IdentifierIssuer = require_lib4().IdentifierIssuer;
      var JsonLdError = require_JsonLdError2();
      var REGEX_LINK_HEADERS = /(?:<[^>]*?>|"[^"]*?"|[^,])+/g;
      var REGEX_LINK_HEADER = /\s*<([^>]*?)>\s*(?:;\s*(.*))?/;
      var REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:"([^"]*?)")|([^"]*?))\s*(?:(?:;\s*)|$)/g;
      var DEFAULTS = {
        headers: {
          accept: "application/ld+json, application/json"
        }
      };
      var api = {};
      module.exports = api;
      api.IdentifierIssuer = IdentifierIssuer;
      api.clone = function(value) {
        if (value && typeof value === "object") {
          let rval;
          if (types.isArray(value)) {
            rval = [];
            for (let i = 0; i < value.length; ++i) {
              rval[i] = api.clone(value[i]);
            }
          } else if (value instanceof Map) {
            rval = /* @__PURE__ */ new Map();
            for (const [k, v] of value) {
              rval.set(k, api.clone(v));
            }
          } else if (value instanceof Set) {
            rval = /* @__PURE__ */ new Set();
            for (const v of value) {
              rval.add(api.clone(v));
            }
          } else if (types.isObject(value)) {
            rval = {};
            for (const key in value) {
              rval[key] = api.clone(value[key]);
            }
          } else {
            rval = value.toString();
          }
          return rval;
        }
        return value;
      };
      api.asArray = function(value) {
        return Array.isArray(value) ? value : [value];
      };
      api.buildHeaders = (headers = {}) => {
        const hasAccept = Object.keys(headers).some((h) => h.toLowerCase() === "accept");
        if (hasAccept) {
          throw new RangeError('Accept header may not be specified; only "' + DEFAULTS.headers.accept + '" is supported.');
        }
        return Object.assign({ Accept: DEFAULTS.headers.accept }, headers);
      };
      api.parseLinkHeader = (header) => {
        const rval = {};
        const entries = header.match(REGEX_LINK_HEADERS);
        for (let i = 0; i < entries.length; ++i) {
          let match = entries[i].match(REGEX_LINK_HEADER);
          if (!match) {
            continue;
          }
          const result = { target: match[1] };
          const params = match[2];
          while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {
            result[match[1]] = match[2] === void 0 ? match[3] : match[2];
          }
          const rel = result["rel"] || "";
          if (Array.isArray(rval[rel])) {
            rval[rel].push(result);
          } else if (rval.hasOwnProperty(rel)) {
            rval[rel] = [rval[rel], result];
          } else {
            rval[rel] = result;
          }
        }
        return rval;
      };
      api.validateTypeValue = (v) => {
        if (types.isString(v) || types.isEmptyObject(v)) {
          return;
        }
        let isValid = false;
        if (types.isArray(v)) {
          isValid = true;
          for (let i = 0; i < v.length; ++i) {
            if (!types.isString(v[i])) {
              isValid = false;
              break;
            }
          }
        }
        if (!isValid) {
          throw new JsonLdError('Invalid JSON-LD syntax; "@type" value must a string, an array of strings, or an empty object.', "jsonld.SyntaxError", { code: "invalid type value", value: v });
        }
      };
      api.hasProperty = (subject, property) => {
        if (subject.hasOwnProperty(property)) {
          const value = subject[property];
          return !types.isArray(value) || value.length > 0;
        }
        return false;
      };
      api.hasValue = (subject, property, value) => {
        if (api.hasProperty(subject, property)) {
          let val = subject[property];
          const isList = graphTypes.isList(val);
          if (types.isArray(val) || isList) {
            if (isList) {
              val = val["@list"];
            }
            for (let i = 0; i < val.length; ++i) {
              if (api.compareValues(value, val[i])) {
                return true;
              }
            }
          } else if (!types.isArray(value)) {
            return api.compareValues(value, val);
          }
        }
        return false;
      };
      api.addValue = (subject, property, value, options) => {
        options = options || {};
        if (!("propertyIsArray" in options)) {
          options.propertyIsArray = false;
        }
        if (!("valueIsArray" in options)) {
          options.valueIsArray = false;
        }
        if (!("allowDuplicate" in options)) {
          options.allowDuplicate = true;
        }
        if (!("prependValue" in options)) {
          options.prependValue = false;
        }
        if (options.valueIsArray) {
          subject[property] = value;
        } else if (types.isArray(value)) {
          if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {
            subject[property] = [];
          }
          if (options.prependValue) {
            value = value.concat(subject[property]);
            subject[property] = [];
          }
          for (let i = 0; i < value.length; ++i) {
            api.addValue(subject, property, value[i], options);
          }
        } else if (subject.hasOwnProperty(property)) {
          const hasValue = !options.allowDuplicate && api.hasValue(subject, property, value);
          if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {
            subject[property] = [subject[property]];
          }
          if (!hasValue) {
            if (options.prependValue) {
              subject[property].unshift(value);
            } else {
              subject[property].push(value);
            }
          }
        } else {
          subject[property] = options.propertyIsArray ? [value] : value;
        }
      };
      api.getValues = (subject, property) => [].concat(subject[property] || []);
      api.removeProperty = (subject, property) => {
        delete subject[property];
      };
      api.removeValue = (subject, property, value, options) => {
        options = options || {};
        if (!("propertyIsArray" in options)) {
          options.propertyIsArray = false;
        }
        const values = api.getValues(subject, property).filter((e) => !api.compareValues(e, value));
        if (values.length === 0) {
          api.removeProperty(subject, property);
        } else if (values.length === 1 && !options.propertyIsArray) {
          subject[property] = values[0];
        } else {
          subject[property] = values;
        }
      };
      api.relabelBlankNodes = (input, options) => {
        options = options || {};
        const issuer = options.issuer || new IdentifierIssuer("_:b");
        return _labelBlankNodes(issuer, input);
      };
      api.compareValues = (v1, v2) => {
        if (v1 === v2) {
          return true;
        }
        if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1["@value"] === v2["@value"] && v1["@type"] === v2["@type"] && v1["@language"] === v2["@language"] && v1["@index"] === v2["@index"]) {
          return true;
        }
        if (types.isObject(v1) && "@id" in v1 && types.isObject(v2) && "@id" in v2) {
          return v1["@id"] === v2["@id"];
        }
        return false;
      };
      api.compareShortestLeast = (a, b) => {
        if (a.length < b.length) {
          return -1;
        }
        if (b.length < a.length) {
          return 1;
        }
        if (a === b) {
          return 0;
        }
        return a < b ? -1 : 1;
      };
      function _labelBlankNodes(issuer, element) {
        if (types.isArray(element)) {
          for (let i = 0; i < element.length; ++i) {
            element[i] = _labelBlankNodes(issuer, element[i]);
          }
        } else if (graphTypes.isList(element)) {
          element["@list"] = _labelBlankNodes(issuer, element["@list"]);
        } else if (types.isObject(element)) {
          if (graphTypes.isBlankNode(element)) {
            element["@id"] = issuer.getId(element["@id"]);
          }
          const keys = Object.keys(element).sort();
          for (let ki = 0; ki < keys.length; ++ki) {
            const key = keys[ki];
            if (key !== "@id") {
              element[key] = _labelBlankNodes(issuer, element[key]);
            }
          }
        }
        return element;
      }
    }
  });

  // node_modules/jsonld/lib/url.js
  var require_url2 = __commonJS({
    "node_modules/jsonld/lib/url.js"(exports, module) {
      "use strict";
      var types = require_types2();
      var api = {};
      module.exports = api;
      api.parsers = {
        simple: {
          keys: [
            "href",
            "scheme",
            "authority",
            "path",
            "query",
            "fragment"
          ],
          regex: /^(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/
        },
        full: {
          keys: [
            "href",
            "protocol",
            "scheme",
            "authority",
            "auth",
            "user",
            "password",
            "hostname",
            "port",
            "path",
            "directory",
            "file",
            "query",
            "fragment"
          ],
          regex: /^(([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?(?:(((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/
        }
      };
      api.parse = (str, parser) => {
        const parsed = {};
        const o = api.parsers[parser || "full"];
        const m = o.regex.exec(str);
        let i = o.keys.length;
        while (i--) {
          parsed[o.keys[i]] = m[i] === void 0 ? null : m[i];
        }
        if (parsed.scheme === "https" && parsed.port === "443" || parsed.scheme === "http" && parsed.port === "80") {
          parsed.href = parsed.href.replace(":" + parsed.port, "");
          parsed.authority = parsed.authority.replace(":" + parsed.port, "");
          parsed.port = null;
        }
        parsed.normalizedPath = api.removeDotSegments(parsed.path);
        return parsed;
      };
      api.prependBase = (base, iri) => {
        if (base === null) {
          return iri;
        }
        if (api.isAbsolute(iri)) {
          return iri;
        }
        if (types.isString(base)) {
          base = api.parse(base || "");
        }
        const rel = api.parse(iri);
        const transform = {
          protocol: base.protocol || ""
        };
        if (rel.authority !== null) {
          transform.authority = rel.authority;
          transform.path = rel.path;
          transform.query = rel.query;
        } else {
          transform.authority = base.authority;
          if (rel.path === "") {
            transform.path = base.path;
            if (rel.query !== null) {
              transform.query = rel.query;
            } else {
              transform.query = base.query;
            }
          } else {
            if (rel.path.indexOf("/") === 0) {
              transform.path = rel.path;
            } else {
              let path = base.path;
              path = path.substr(0, path.lastIndexOf("/") + 1);
              if (path.length > 0 && path.substr(-1) !== "/") {
                path += "/";
              }
              path += rel.path;
              transform.path = path;
            }
            transform.query = rel.query;
          }
        }
        if (rel.path !== "") {
          transform.path = api.removeDotSegments(transform.path);
        }
        let rval = transform.protocol;
        if (transform.authority !== null) {
          rval += "//" + transform.authority;
        }
        rval += transform.path;
        if (transform.query !== null) {
          rval += "?" + transform.query;
        }
        if (rel.fragment !== null) {
          rval += "#" + rel.fragment;
        }
        if (rval === "") {
          rval = "./";
        }
        return rval;
      };
      api.removeBase = (base, iri) => {
        if (base === null) {
          return iri;
        }
        if (types.isString(base)) {
          base = api.parse(base || "");
        }
        let root = "";
        if (base.href !== "") {
          root += (base.protocol || "") + "//" + (base.authority || "");
        } else if (iri.indexOf("//")) {
          root += "//";
        }
        if (iri.indexOf(root) !== 0) {
          return iri;
        }
        const rel = api.parse(iri.substr(root.length));
        const baseSegments = base.normalizedPath.split("/");
        const iriSegments = rel.normalizedPath.split("/");
        const last = rel.fragment || rel.query ? 0 : 1;
        while (baseSegments.length > 0 && iriSegments.length > last) {
          if (baseSegments[0] !== iriSegments[0]) {
            break;
          }
          baseSegments.shift();
          iriSegments.shift();
        }
        let rval = "";
        if (baseSegments.length > 0) {
          baseSegments.pop();
          for (let i = 0; i < baseSegments.length; ++i) {
            rval += "../";
          }
        }
        rval += iriSegments.join("/");
        if (rel.query !== null) {
          rval += "?" + rel.query;
        }
        if (rel.fragment !== null) {
          rval += "#" + rel.fragment;
        }
        if (rval === "") {
          rval = "./";
        }
        return rval;
      };
      api.removeDotSegments = (path) => {
        if (path.length === 0) {
          return "";
        }
        const input = path.split("/");
        const output = [];
        while (input.length > 0) {
          const next = input.shift();
          const done = input.length === 0;
          if (next === ".") {
            if (done) {
              output.push("");
            }
            continue;
          }
          if (next === "..") {
            output.pop();
            if (done) {
              output.push("");
            }
            continue;
          }
          output.push(next);
        }
        if (output.length > 0 && output[0] !== "") {
          output.unshift("");
        }
        if (output.length === 1 && output[0] === "") {
          return "/";
        }
        return output.join("/");
      };
      var isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):/;
      api.isAbsolute = (v) => types.isString(v) && isAbsoluteRegex.test(v);
      api.isRelative = (v) => types.isString(v);
    }
  });

  // node_modules/yallist/iterator.js
  var require_iterator2 = __commonJS({
    "node_modules/yallist/iterator.js"(exports, module) {
      "use strict";
      module.exports = function(Yallist) {
        Yallist.prototype[Symbol.iterator] = function* () {
          for (let walker = this.head; walker; walker = walker.next) {
            yield walker.value;
          }
        };
      };
    }
  });

  // node_modules/yallist/yallist.js
  var require_yallist2 = __commonJS({
    "node_modules/yallist/yallist.js"(exports, module) {
      "use strict";
      module.exports = Yallist;
      Yallist.Node = Node2;
      Yallist.create = Yallist;
      function Yallist(list) {
        var self2 = this;
        if (!(self2 instanceof Yallist)) {
          self2 = new Yallist();
        }
        self2.tail = null;
        self2.head = null;
        self2.length = 0;
        if (list && typeof list.forEach === "function") {
          list.forEach(function(item) {
            self2.push(item);
          });
        } else if (arguments.length > 0) {
          for (var i = 0, l = arguments.length; i < l; i++) {
            self2.push(arguments[i]);
          }
        }
        return self2;
      }
      Yallist.prototype.removeNode = function(node) {
        if (node.list !== this) {
          throw new Error("removing node which does not belong to this list");
        }
        var next = node.next;
        var prev = node.prev;
        if (next) {
          next.prev = prev;
        }
        if (prev) {
          prev.next = next;
        }
        if (node === this.head) {
          this.head = next;
        }
        if (node === this.tail) {
          this.tail = prev;
        }
        node.list.length--;
        node.next = null;
        node.prev = null;
        node.list = null;
        return next;
      };
      Yallist.prototype.unshiftNode = function(node) {
        if (node === this.head) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var head = this.head;
        node.list = this;
        node.next = head;
        if (head) {
          head.prev = node;
        }
        this.head = node;
        if (!this.tail) {
          this.tail = node;
        }
        this.length++;
      };
      Yallist.prototype.pushNode = function(node) {
        if (node === this.tail) {
          return;
        }
        if (node.list) {
          node.list.removeNode(node);
        }
        var tail = this.tail;
        node.list = this;
        node.prev = tail;
        if (tail) {
          tail.next = node;
        }
        this.tail = node;
        if (!this.head) {
          this.head = node;
        }
        this.length++;
      };
      Yallist.prototype.push = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          push(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.unshift = function() {
        for (var i = 0, l = arguments.length; i < l; i++) {
          unshift(this, arguments[i]);
        }
        return this.length;
      };
      Yallist.prototype.pop = function() {
        if (!this.tail) {
          return void 0;
        }
        var res = this.tail.value;
        this.tail = this.tail.prev;
        if (this.tail) {
          this.tail.next = null;
        } else {
          this.head = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.shift = function() {
        if (!this.head) {
          return void 0;
        }
        var res = this.head.value;
        this.head = this.head.next;
        if (this.head) {
          this.head.prev = null;
        } else {
          this.tail = null;
        }
        this.length--;
        return res;
      };
      Yallist.prototype.forEach = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.head, i = 0; walker !== null; i++) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.next;
        }
      };
      Yallist.prototype.forEachReverse = function(fn, thisp) {
        thisp = thisp || this;
        for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
          fn.call(thisp, walker.value, i, this);
          walker = walker.prev;
        }
      };
      Yallist.prototype.get = function(n) {
        for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
          walker = walker.next;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.getReverse = function(n) {
        for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
          walker = walker.prev;
        }
        if (i === n && walker !== null) {
          return walker.value;
        }
      };
      Yallist.prototype.map = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.head; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.next;
        }
        return res;
      };
      Yallist.prototype.mapReverse = function(fn, thisp) {
        thisp = thisp || this;
        var res = new Yallist();
        for (var walker = this.tail; walker !== null; ) {
          res.push(fn.call(thisp, walker.value, this));
          walker = walker.prev;
        }
        return res;
      };
      Yallist.prototype.reduce = function(fn, initial) {
        var acc;
        var walker = this.head;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.head) {
          walker = this.head.next;
          acc = this.head.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = 0; walker !== null; i++) {
          acc = fn(acc, walker.value, i);
          walker = walker.next;
        }
        return acc;
      };
      Yallist.prototype.reduceReverse = function(fn, initial) {
        var acc;
        var walker = this.tail;
        if (arguments.length > 1) {
          acc = initial;
        } else if (this.tail) {
          walker = this.tail.prev;
          acc = this.tail.value;
        } else {
          throw new TypeError("Reduce of empty list with no initial value");
        }
        for (var i = this.length - 1; walker !== null; i--) {
          acc = fn(acc, walker.value, i);
          walker = walker.prev;
        }
        return acc;
      };
      Yallist.prototype.toArray = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.head; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.next;
        }
        return arr;
      };
      Yallist.prototype.toArrayReverse = function() {
        var arr = new Array(this.length);
        for (var i = 0, walker = this.tail; walker !== null; i++) {
          arr[i] = walker.value;
          walker = walker.prev;
        }
        return arr;
      };
      Yallist.prototype.slice = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
          walker = walker.next;
        }
        for (; walker !== null && i < to; i++, walker = walker.next) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.sliceReverse = function(from, to) {
        to = to || this.length;
        if (to < 0) {
          to += this.length;
        }
        from = from || 0;
        if (from < 0) {
          from += this.length;
        }
        var ret = new Yallist();
        if (to < from || to < 0) {
          return ret;
        }
        if (from < 0) {
          from = 0;
        }
        if (to > this.length) {
          to = this.length;
        }
        for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
          walker = walker.prev;
        }
        for (; walker !== null && i > from; i--, walker = walker.prev) {
          ret.push(walker.value);
        }
        return ret;
      };
      Yallist.prototype.splice = function(start, deleteCount) {
        if (start > this.length) {
          start = this.length - 1;
        }
        if (start < 0) {
          start = this.length + start;
        }
        for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
          walker = walker.next;
        }
        var ret = [];
        for (var i = 0; walker && i < deleteCount; i++) {
          ret.push(walker.value);
          walker = this.removeNode(walker);
        }
        if (walker === null) {
          walker = this.tail;
        }
        if (walker !== this.head && walker !== this.tail) {
          walker = walker.prev;
        }
        for (var i = 2; i < arguments.length; i++) {
          walker = insert(this, walker, arguments[i]);
        }
        return ret;
      };
      Yallist.prototype.reverse = function() {
        var head = this.head;
        var tail = this.tail;
        for (var walker = head; walker !== null; walker = walker.prev) {
          var p = walker.prev;
          walker.prev = walker.next;
          walker.next = p;
        }
        this.head = tail;
        this.tail = head;
        return this;
      };
      function insert(self2, node, value) {
        var inserted = node === self2.head ? new Node2(value, null, node, self2) : new Node2(value, node, node.next, self2);
        if (inserted.next === null) {
          self2.tail = inserted;
        }
        if (inserted.prev === null) {
          self2.head = inserted;
        }
        self2.length++;
        return inserted;
      }
      function push(self2, item) {
        self2.tail = new Node2(item, self2.tail, null, self2);
        if (!self2.head) {
          self2.head = self2.tail;
        }
        self2.length++;
      }
      function unshift(self2, item) {
        self2.head = new Node2(item, null, self2.head, self2);
        if (!self2.tail) {
          self2.tail = self2.head;
        }
        self2.length++;
      }
      function Node2(value, prev, next, list) {
        if (!(this instanceof Node2)) {
          return new Node2(value, prev, next, list);
        }
        this.list = list;
        this.value = value;
        if (prev) {
          prev.next = this;
          this.prev = prev;
        } else {
          this.prev = null;
        }
        if (next) {
          next.prev = this;
          this.next = next;
        } else {
          this.next = null;
        }
      }
      try {
        require_iterator2()(Yallist);
      } catch (er) {
      }
    }
  });

  // node_modules/lru-cache/index.js
  var require_lru_cache2 = __commonJS({
    "node_modules/lru-cache/index.js"(exports, module) {
      "use strict";
      var Yallist = require_yallist2();
      var MAX = Symbol("max");
      var LENGTH = Symbol("length");
      var LENGTH_CALCULATOR = Symbol("lengthCalculator");
      var ALLOW_STALE = Symbol("allowStale");
      var MAX_AGE = Symbol("maxAge");
      var DISPOSE = Symbol("dispose");
      var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
      var LRU_LIST = Symbol("lruList");
      var CACHE = Symbol("cache");
      var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
      var naiveLength = () => 1;
      var LRUCache = class {
        constructor(options) {
          if (typeof options === "number")
            options = { max: options };
          if (!options)
            options = {};
          if (options.max && (typeof options.max !== "number" || options.max < 0))
            throw new TypeError("max must be a non-negative number");
          const max = this[MAX] = options.max || Infinity;
          const lc = options.length || naiveLength;
          this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
          this[ALLOW_STALE] = options.stale || false;
          if (options.maxAge && typeof options.maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          this[MAX_AGE] = options.maxAge || 0;
          this[DISPOSE] = options.dispose;
          this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
          this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
          this.reset();
        }
        set max(mL) {
          if (typeof mL !== "number" || mL < 0)
            throw new TypeError("max must be a non-negative number");
          this[MAX] = mL || Infinity;
          trim(this);
        }
        get max() {
          return this[MAX];
        }
        set allowStale(allowStale) {
          this[ALLOW_STALE] = !!allowStale;
        }
        get allowStale() {
          return this[ALLOW_STALE];
        }
        set maxAge(mA) {
          if (typeof mA !== "number")
            throw new TypeError("maxAge must be a non-negative number");
          this[MAX_AGE] = mA;
          trim(this);
        }
        get maxAge() {
          return this[MAX_AGE];
        }
        set lengthCalculator(lC) {
          if (typeof lC !== "function")
            lC = naiveLength;
          if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit) => {
              hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
              this[LENGTH] += hit.length;
            });
          }
          trim(this);
        }
        get lengthCalculator() {
          return this[LENGTH_CALCULATOR];
        }
        get length() {
          return this[LENGTH];
        }
        get itemCount() {
          return this[LRU_LIST].length;
        }
        rforEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].tail; walker !== null; ) {
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
          }
        }
        forEach(fn, thisp) {
          thisp = thisp || this;
          for (let walker = this[LRU_LIST].head; walker !== null; ) {
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
          }
        }
        keys() {
          return this[LRU_LIST].toArray().map((k) => k.key);
        }
        values() {
          return this[LRU_LIST].toArray().map((k) => k.value);
        }
        reset() {
          if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
          }
          this[CACHE] = /* @__PURE__ */ new Map();
          this[LRU_LIST] = new Yallist();
          this[LENGTH] = 0;
        }
        dump() {
          return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          }).toArray().filter((h) => h);
        }
        dumpLru() {
          return this[LRU_LIST];
        }
        set(key, value, maxAge) {
          maxAge = maxAge || this[MAX_AGE];
          if (maxAge && typeof maxAge !== "number")
            throw new TypeError("maxAge must be a number");
          const now = maxAge ? Date.now() : 0;
          const len = this[LENGTH_CALCULATOR](value, key);
          if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
              del(this, this[CACHE].get(key));
              return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            if (this[DISPOSE]) {
              if (!this[NO_DISPOSE_ON_SET])
                this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
          }
          const hit = new Entry(key, value, len, now, maxAge);
          if (hit.length > this[MAX]) {
            if (this[DISPOSE])
              this[DISPOSE](key, value);
            return false;
          }
          this[LENGTH] += hit.length;
          this[LRU_LIST].unshift(hit);
          this[CACHE].set(key, this[LRU_LIST].head);
          trim(this);
          return true;
        }
        has(key) {
          if (!this[CACHE].has(key))
            return false;
          const hit = this[CACHE].get(key).value;
          return !isStale(this, hit);
        }
        get(key) {
          return get(this, key, true);
        }
        peek(key) {
          return get(this, key, false);
        }
        pop() {
          const node = this[LRU_LIST].tail;
          if (!node)
            return null;
          del(this, node);
          return node.value;
        }
        del(key) {
          del(this, this[CACHE].get(key));
        }
        load(arr) {
          this.reset();
          const now = Date.now();
          for (let l = arr.length - 1; l >= 0; l--) {
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0)
              this.set(hit.k, hit.v);
            else {
              const maxAge = expiresAt - now;
              if (maxAge > 0) {
                this.set(hit.k, hit.v, maxAge);
              }
            }
          }
        }
        prune() {
          this[CACHE].forEach((value, key) => get(this, key, false));
        }
      };
      var get = (self2, key, doUse) => {
        const node = self2[CACHE].get(key);
        if (node) {
          const hit = node.value;
          if (isStale(self2, hit)) {
            del(self2, node);
            if (!self2[ALLOW_STALE])
              return void 0;
          } else {
            if (doUse) {
              if (self2[UPDATE_AGE_ON_GET])
                node.value.now = Date.now();
              self2[LRU_LIST].unshiftNode(node);
            }
          }
          return hit.value;
        }
      };
      var isStale = (self2, hit) => {
        if (!hit || !hit.maxAge && !self2[MAX_AGE])
          return false;
        const diff = Date.now() - hit.now;
        return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
      };
      var trim = (self2) => {
        if (self2[LENGTH] > self2[MAX]) {
          for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
            const prev = walker.prev;
            del(self2, walker);
            walker = prev;
          }
        }
      };
      var del = (self2, node) => {
        if (node) {
          const hit = node.value;
          if (self2[DISPOSE])
            self2[DISPOSE](hit.key, hit.value);
          self2[LENGTH] -= hit.length;
          self2[CACHE].delete(hit.key);
          self2[LRU_LIST].removeNode(node);
        }
      };
      var Entry = class {
        constructor(key, value, length, now, maxAge) {
          this.key = key;
          this.value = value;
          this.length = length;
          this.now = now;
          this.maxAge = maxAge || 0;
        }
      };
      var forEachStep = (self2, fn, node, thisp) => {
        let hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            hit = void 0;
        }
        if (hit)
          fn.call(thisp, hit.value, hit.key, self2);
      };
      module.exports = LRUCache;
    }
  });

  // node_modules/jsonld/lib/ResolvedContext.js
  var require_ResolvedContext2 = __commonJS({
    "node_modules/jsonld/lib/ResolvedContext.js"(exports, module) {
      "use strict";
      var LRU = require_lru_cache2();
      var MAX_ACTIVE_CONTEXTS = 10;
      module.exports = class ResolvedContext {
        constructor({ document: document2 }) {
          this.document = document2;
          this.cache = new LRU({ max: MAX_ACTIVE_CONTEXTS });
        }
        getProcessed(activeCtx) {
          return this.cache.get(activeCtx);
        }
        setProcessed(activeCtx, processedCtx) {
          this.cache.set(activeCtx, processedCtx);
        }
      };
    }
  });

  // node_modules/jsonld/lib/ContextResolver.js
  var require_ContextResolver2 = __commonJS({
    "node_modules/jsonld/lib/ContextResolver.js"(exports, module) {
      "use strict";
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString
      } = require_types2();
      var { prependBase } = require_url2();
      var JsonLdError = require_JsonLdError2();
      var ResolvedContext = require_ResolvedContext2();
      var MAX_CONTEXT_URLS = 10;
      module.exports = class ContextResolver {
        constructor({ sharedCache }) {
          this.perOpCache = /* @__PURE__ */ new Map();
          this.sharedCache = sharedCache;
        }
        async resolve({ context, documentLoader, base, cycles = /* @__PURE__ */ new Set() }) {
          if (context && _isObject(context) && context["@context"]) {
            context = context["@context"];
          }
          if (!_isArray(context)) {
            context = [context];
          }
          const allResolved = [];
          for (const ctx of context) {
            if (_isString(ctx)) {
              let resolved2 = this._get(ctx);
              if (!resolved2) {
                resolved2 = await this._resolveRemoteContext({ url: ctx, documentLoader, base, cycles });
              }
              if (_isArray(resolved2)) {
                allResolved.push(...resolved2);
              } else {
                allResolved.push(resolved2);
              }
              continue;
            }
            if (ctx === null) {
              allResolved.push(new ResolvedContext({ document: null }));
              continue;
            }
            if (!_isObject(ctx)) {
              _throwInvalidLocalContext(context);
            }
            const key = JSON.stringify(ctx);
            let resolved = this._get(key);
            if (!resolved) {
              resolved = new ResolvedContext({ document: ctx });
              this._cacheResolvedContext({ key, resolved, tag: "static" });
            }
            allResolved.push(resolved);
          }
          return allResolved;
        }
        _get(key) {
          let resolved = this.perOpCache.get(key);
          if (!resolved) {
            const tagMap = this.sharedCache.get(key);
            if (tagMap) {
              resolved = tagMap.get("static");
              if (resolved) {
                this.perOpCache.set(key, resolved);
              }
            }
          }
          return resolved;
        }
        _cacheResolvedContext({ key, resolved, tag }) {
          this.perOpCache.set(key, resolved);
          if (tag !== void 0) {
            let tagMap = this.sharedCache.get(key);
            if (!tagMap) {
              tagMap = /* @__PURE__ */ new Map();
              this.sharedCache.set(key, tagMap);
            }
            tagMap.set(tag, resolved);
          }
          return resolved;
        }
        async _resolveRemoteContext({ url, documentLoader, base, cycles }) {
          url = prependBase(base, url);
          const { context, remoteDoc } = await this._fetchContext({ url, documentLoader, cycles });
          base = remoteDoc.documentUrl || url;
          _resolveContextUrls({ context, base });
          const resolved = await this.resolve({ context, documentLoader, base, cycles });
          this._cacheResolvedContext({ key: url, resolved, tag: remoteDoc.tag });
          return resolved;
        }
        async _fetchContext({ url, documentLoader, cycles }) {
          if (cycles.size > MAX_CONTEXT_URLS) {
            throw new JsonLdError("Maximum number of @context URLs exceeded.", "jsonld.ContextUrlError", { code: "loading remote context failed", max: MAX_CONTEXT_URLS });
          }
          if (cycles.has(url)) {
            throw new JsonLdError("Cyclical @context URLs detected.", "jsonld.ContextUrlError", { code: "recursive context inclusion", url });
          }
          cycles.add(url);
          let context;
          let remoteDoc;
          try {
            remoteDoc = await documentLoader(url);
            context = remoteDoc.document || null;
            if (_isString(context)) {
              context = JSON.parse(context);
            }
          } catch (e) {
            throw new JsonLdError("Dereferencing a URL did not result in a valid JSON-LD object. Possible causes are an inaccessible URL perhaps due to a same-origin policy (ensure the server uses CORS if you are using client-side JavaScript), too many redirects, a non-JSON response, or more than one HTTP Link Header was provided for a remote context.", "jsonld.InvalidUrl", { code: "loading remote context failed", url, cause: e });
          }
          if (!_isObject(context)) {
            throw new JsonLdError("Dereferencing a URL did not result in a JSON object. The response was valid JSON, but it was not a JSON object.", "jsonld.InvalidUrl", { code: "invalid remote context", url });
          }
          if (!("@context" in context)) {
            context = { "@context": {} };
          } else {
            context = { "@context": context["@context"] };
          }
          if (remoteDoc.contextUrl) {
            if (!_isArray(context["@context"])) {
              context["@context"] = [context["@context"]];
            }
            context["@context"].push(remoteDoc.contextUrl);
          }
          return { context, remoteDoc };
        }
      };
      function _throwInvalidLocalContext(ctx) {
        throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", {
          code: "invalid local context",
          context: ctx
        });
      }
      function _resolveContextUrls({ context, base }) {
        if (!context) {
          return;
        }
        const ctx = context["@context"];
        if (_isString(ctx)) {
          context["@context"] = prependBase(base, ctx);
          return;
        }
        if (_isArray(ctx)) {
          for (let i = 0; i < ctx.length; ++i) {
            const element = ctx[i];
            if (_isString(element)) {
              ctx[i] = prependBase(base, element);
              continue;
            }
            if (_isObject(element)) {
              _resolveContextUrls({ context: { "@context": element }, base });
            }
          }
          return;
        }
        if (!_isObject(ctx)) {
          return;
        }
        for (const term in ctx) {
          _resolveContextUrls({ context: ctx[term], base });
        }
      }
    }
  });

  // node_modules/jsonld/lib/NQuads.js
  var require_NQuads4 = __commonJS({
    "node_modules/jsonld/lib/NQuads.js"(exports, module) {
      "use strict";
      module.exports = require_lib4().NQuads;
    }
  });

  // node_modules/jsonld/lib/constants.js
  var require_constants4 = __commonJS({
    "node_modules/jsonld/lib/constants.js"(exports, module) {
      "use strict";
      var RDF = "http://www.w3.org/1999/02/22-rdf-syntax-ns#";
      var XSD = "http://www.w3.org/2001/XMLSchema#";
      module.exports = {
        LINK_HEADER_REL: "http://www.w3.org/ns/json-ld#context",
        RDF,
        RDF_LIST: RDF + "List",
        RDF_FIRST: RDF + "first",
        RDF_REST: RDF + "rest",
        RDF_NIL: RDF + "nil",
        RDF_TYPE: RDF + "type",
        RDF_PLAIN_LITERAL: RDF + "PlainLiteral",
        RDF_XML_LITERAL: RDF + "XMLLiteral",
        RDF_JSON_LITERAL: RDF + "JSON",
        RDF_OBJECT: RDF + "object",
        RDF_LANGSTRING: RDF + "langString",
        XSD,
        XSD_BOOLEAN: XSD + "boolean",
        XSD_DOUBLE: XSD + "double",
        XSD_INTEGER: XSD + "integer",
        XSD_STRING: XSD + "string"
      };
    }
  });

  // (disabled):node_modules/xmldom/dom-parser.js
  var require_dom_parser = __commonJS({
    "(disabled):node_modules/xmldom/dom-parser.js"() {
    }
  });

  // node_modules/jsonld/lib/Rdfa.js
  var require_Rdfa = __commonJS({
    "node_modules/jsonld/lib/Rdfa.js"(exports, module) {
      "use strict";
      var {
        RDF_LANGSTRING,
        RDF_PLAIN_LITERAL,
        RDF_OBJECT,
        RDF_XML_LITERAL,
        XSD_STRING
      } = require_constants4();
      var _Node;
      if (typeof Node !== "undefined") {
        _Node = Node;
      } else {
        _Node = {
          ELEMENT_NODE: 1,
          ATTRIBUTE_NODE: 2,
          TEXT_NODE: 3,
          CDATA_SECTION_NODE: 4,
          ENTITY_REFERENCE_NODE: 5,
          ENTITY_NODE: 6,
          PROCESSING_INSTRUCTION_NODE: 7,
          COMMENT_NODE: 8,
          DOCUMENT_NODE: 9,
          DOCUMENT_TYPE_NODE: 10,
          DOCUMENT_FRAGMENT_NODE: 11,
          NOTATION_NODE: 12
        };
      }
      module.exports = class Rdfa {
        parse(data) {
          const dataset = {};
          dataset["@default"] = [];
          const subjects = data.getSubjects();
          for (let si = 0; si < subjects.length; ++si) {
            const subject = subjects[si];
            if (subject === null) {
              continue;
            }
            const triples = data.getSubjectTriples(subject);
            if (triples === null) {
              continue;
            }
            const predicates = triples.predicates;
            for (const predicate in predicates) {
              const objects = predicates[predicate].objects;
              for (let oi = 0; oi < objects.length; ++oi) {
                const object = objects[oi];
                const triple = {};
                if (subject.indexOf("_:") === 0) {
                  triple.subject = { type: "blank node", value: subject };
                } else {
                  triple.subject = { type: "IRI", value: subject };
                }
                if (predicate.indexOf("_:") === 0) {
                  triple.predicate = { type: "blank node", value: predicate };
                } else {
                  triple.predicate = { type: "IRI", value: predicate };
                }
                let value = object.value;
                if (object.type === RDF_XML_LITERAL) {
                  const XMLSerializer2 = getXMLSerializerClass();
                  const serializer = new XMLSerializer2();
                  value = "";
                  for (let x = 0; x < object.value.length; x++) {
                    if (object.value[x].nodeType === _Node.ELEMENT_NODE) {
                      value += serializer.serializeToString(object.value[x]);
                    } else if (object.value[x].nodeType === _Node.TEXT_NODE) {
                      value += object.value[x].nodeValue;
                    }
                  }
                }
                triple.object = {};
                if (object.type === RDF_OBJECT) {
                  if (object.value.indexOf("_:") === 0) {
                    triple.object.type = "blank node";
                  } else {
                    triple.object.type = "IRI";
                  }
                } else {
                  triple.object.type = "literal";
                  if (object.type === RDF_PLAIN_LITERAL) {
                    if (object.language) {
                      triple.object.datatype = RDF_LANGSTRING;
                      triple.object.language = object.language;
                    } else {
                      triple.object.datatype = XSD_STRING;
                    }
                  } else {
                    triple.object.datatype = object.type;
                  }
                }
                triple.object.value = value;
                dataset["@default"].push(triple);
              }
            }
          }
          return dataset;
        }
      };
      function getXMLSerializerClass() {
        if (typeof XMLSerializer === "undefined") {
          return require_dom_parser().XMLSerializer;
        }
        return XMLSerializer;
      }
    }
  });

  // node_modules/jsonld/lib/context.js
  var require_context2 = __commonJS({
    "node_modules/jsonld/lib/context.js"(exports, module) {
      "use strict";
      var util = require_util8();
      var JsonLdError = require_JsonLdError2();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString,
        isUndefined: _isUndefined
      } = require_types2();
      var {
        isAbsolute: _isAbsoluteIri,
        isRelative: _isRelativeIri,
        prependBase,
        parse: parseUrl
      } = require_url2();
      var {
        asArray: _asArray,
        compareShortestLeast: _compareShortestLeast
      } = require_util8();
      var INITIAL_CONTEXT_CACHE = /* @__PURE__ */ new Map();
      var INITIAL_CONTEXT_CACHE_MAX_SIZE = 1e4;
      var api = {};
      module.exports = api;
      api.process = async ({
        activeCtx,
        localCtx,
        options,
        propagate = true,
        overrideProtected = false
      }) => {
        if (_isObject(localCtx) && "@context" in localCtx && _isArray(localCtx["@context"])) {
          localCtx = localCtx["@context"];
        }
        const ctxs = _asArray(localCtx);
        if (ctxs.length === 0) {
          return activeCtx;
        }
        const resolved = await options.contextResolver.resolve({
          context: localCtx,
          documentLoader: options.documentLoader,
          base: options.base
        });
        if (_isObject(resolved[0].document) && typeof resolved[0].document["@propagate"] === "boolean") {
          propagate = resolved[0].document["@propagate"];
        }
        let rval = activeCtx;
        if (!propagate && !rval.previousContext) {
          rval = rval.clone();
          rval.previousContext = activeCtx;
        }
        for (const resolvedContext of resolved) {
          let { document: ctx } = resolvedContext;
          activeCtx = rval;
          if (ctx === null) {
            if (!overrideProtected && Object.keys(activeCtx.protected).length !== 0) {
              const protectedMode = options && options.protectedMode || "error";
              if (protectedMode === "error") {
                throw new JsonLdError("Tried to nullify a context with protected terms outside of a term definition.", "jsonld.SyntaxError", { code: "invalid context nullification" });
              } else if (protectedMode === "warn") {
                console.warn("WARNING: invalid context nullification");
                const oldActiveCtx = activeCtx;
                rval = activeCtx = api.getInitialContext(options).clone();
                for (const [term, _protected] of Object.entries(oldActiveCtx.protected)) {
                  if (_protected) {
                    activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);
                  }
                }
                activeCtx.protected = util.clone(oldActiveCtx.protected);
                resolvedContext.setProcessed(oldActiveCtx, rval);
                continue;
              }
              throw new JsonLdError("Invalid protectedMode.", "jsonld.SyntaxError", { code: "invalid protected mode", context: localCtx, protectedMode });
            }
            rval = activeCtx = api.getInitialContext(options).clone();
            continue;
          }
          const processed = resolvedContext.getProcessed(activeCtx);
          if (processed) {
            rval = activeCtx = processed;
            continue;
          }
          if (_isObject(ctx) && "@context" in ctx) {
            ctx = ctx["@context"];
          }
          if (!_isObject(ctx)) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context must be an object.", "jsonld.SyntaxError", { code: "invalid local context", context: ctx });
          }
          rval = rval.clone();
          const defined = /* @__PURE__ */ new Map();
          if ("@version" in ctx) {
            if (ctx["@version"] !== 1.1) {
              throw new JsonLdError("Unsupported JSON-LD version: " + ctx["@version"], "jsonld.UnsupportedVersion", { code: "invalid @version value", context: ctx });
            }
            if (activeCtx.processingMode && activeCtx.processingMode === "json-ld-1.0") {
              throw new JsonLdError("@version: " + ctx["@version"] + " not compatible with " + activeCtx.processingMode, "jsonld.ProcessingModeConflict", { code: "processing mode conflict", context: ctx });
            }
            rval.processingMode = "json-ld-1.1";
            rval["@version"] = ctx["@version"];
            defined.set("@version", true);
          }
          rval.processingMode = rval.processingMode || activeCtx.processingMode;
          if ("@base" in ctx) {
            let base = ctx["@base"];
            if (base === null) {
            } else if (_isAbsoluteIri(base)) {
              base = parseUrl(base);
            } else if (_isRelativeIri(base)) {
              base = parseUrl(prependBase(rval["@base"].href, base));
            } else {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@base" in a @context must be an absolute IRI, a relative IRI, or null.', "jsonld.SyntaxError", { code: "invalid base IRI", context: ctx });
            }
            rval["@base"] = base;
            defined.set("@base", true);
          }
          if ("@vocab" in ctx) {
            const value = ctx["@vocab"];
            if (value === null) {
              delete rval["@vocab"];
            } else if (!_isString(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be a string or null.', "jsonld.SyntaxError", { code: "invalid vocab mapping", context: ctx });
            } else if (!_isAbsoluteIri(value) && api.processingMode(rval, 1)) {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@vocab" in a @context must be an absolute IRI.', "jsonld.SyntaxError", { code: "invalid vocab mapping", context: ctx });
            } else {
              rval["@vocab"] = _expandIri(rval, value, { vocab: true, base: true }, void 0, void 0, options);
            }
            defined.set("@vocab", true);
          }
          if ("@language" in ctx) {
            const value = ctx["@language"];
            if (value === null) {
              delete rval["@language"];
            } else if (!_isString(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; the value of "@language" in a @context must be a string or null.', "jsonld.SyntaxError", { code: "invalid default language", context: ctx });
            } else {
              rval["@language"] = value.toLowerCase();
            }
            defined.set("@language", true);
          }
          if ("@propagate" in ctx) {
            const value = ctx["@propagate"];
            if (activeCtx.processingMode === "json-ld-1.0") {
              throw new JsonLdError("Invalid JSON-LD syntax; @propagate not compatible with " + activeCtx.processingMode, "jsonld.SyntaxError", { code: "invalid context member", context: ctx });
            }
            if (typeof value !== "boolean") {
              throw new JsonLdError("Invalid JSON-LD syntax; @propagate value must be a boolean.", "jsonld.SyntaxError", { code: "invalid @propagate value", context: localCtx });
            }
            defined.set("@propagate", true);
          }
          defined.set("@protected", ctx["@protected"] || false);
          for (const key in ctx) {
            api.createTermDefinition({
              activeCtx: rval,
              localCtx: ctx,
              term: key,
              defined,
              options,
              overrideProtected
            });
          }
          resolvedContext.setProcessed(activeCtx, rval);
        }
        return rval;
      };
      api.createTermDefinition = ({
        activeCtx,
        localCtx,
        term,
        defined,
        options,
        overrideProtected = false
      }) => {
        if (defined.has(term)) {
          if (defined.get(term)) {
            return;
          }
          throw new JsonLdError("Cyclical context definition detected.", "jsonld.CyclicalContext", { code: "cyclic IRI mapping", context: localCtx, term });
        }
        defined.set(term, false);
        let value;
        if (localCtx.hasOwnProperty(term)) {
          value = localCtx[term];
        }
        if (term === "@type" && _isObject(value) && value["@container"] === "@set" && api.processingMode(activeCtx, 1.1)) {
          const validKeys2 = ["@container", "@id", "@protected"];
          if (Object.keys(value).some((k) => !validKeys2.includes(k))) {
            throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: localCtx, term });
          }
        } else if (api.isKeyword(term)) {
          throw new JsonLdError("Invalid JSON-LD syntax; keywords cannot be overridden.", "jsonld.SyntaxError", { code: "keyword redefinition", context: localCtx, term });
        } else if (term === "") {
          throw new JsonLdError("Invalid JSON-LD syntax; a term cannot be an empty string.", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
        }
        const previousMapping = activeCtx.mappings.get(term);
        if (activeCtx.mappings.has(term)) {
          activeCtx.mappings.delete(term);
        }
        if (value === null || _isObject(value) && value["@id"] === null) {
          activeCtx.mappings.set(term, null);
          defined.set(term, true);
          return;
        }
        let simpleTerm = false;
        if (_isString(value)) {
          simpleTerm = true;
          value = { "@id": value };
        }
        if (!_isObject(value)) {
          throw new JsonLdError("Invalid JSON-LD syntax; @context term values must be strings or objects.", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
        }
        const mapping = {};
        activeCtx.mappings.set(term, mapping);
        mapping.reverse = false;
        const validKeys = ["@container", "@id", "@language", "@reverse", "@type"];
        if (api.processingMode(activeCtx, 1.1)) {
          validKeys.push("@context", "@index", "@nest", "@prefix", "@protected");
        }
        for (const kw in value) {
          if (!validKeys.includes(kw)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a term definition must not contain " + kw, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
        }
        const colon = term.indexOf(":");
        mapping._termHasColon = colon > 0;
        if ("@reverse" in value) {
          if ("@id" in value) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not contain @id.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
          }
          if ("@nest" in value) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @reverse term definition must not contain @nest.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
          }
          const reverse = value["@reverse"];
          if (!_isString(reverse)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
          const id2 = _expandIri(activeCtx, reverse, { vocab: true, base: false }, localCtx, defined, options);
          if (!_isAbsoluteIri(id2)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @context @reverse value must be an absolute IRI or a blank node identifier.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
          mapping["@id"] = id2;
          mapping.reverse = true;
        } else if ("@id" in value) {
          let id2 = value["@id"];
          if (!_isString(id2)) {
            throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an array of strings or a string.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
          }
          if (id2 !== term) {
            id2 = _expandIri(activeCtx, id2, { vocab: true, base: false }, localCtx, defined, options);
            if (!_isAbsoluteIri(id2) && !api.isKeyword(id2)) {
              throw new JsonLdError("Invalid JSON-LD syntax; a @context @id value must be an absolute IRI, a blank node identifier, or a keyword.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx });
            }
            mapping["@id"] = id2;
            mapping._prefix = simpleTerm && !mapping._termHasColon && id2.match(/[:\/\?#\[\]@]$/);
          }
        }
        if (!("@id" in mapping)) {
          if (mapping._termHasColon) {
            const prefix = term.substr(0, colon);
            if (localCtx.hasOwnProperty(prefix)) {
              api.createTermDefinition({
                activeCtx,
                localCtx,
                term: prefix,
                defined,
                options
              });
            }
            if (activeCtx.mappings.has(prefix)) {
              const suffix = term.substr(colon + 1);
              mapping["@id"] = activeCtx.mappings.get(prefix)["@id"] + suffix;
            } else {
              mapping["@id"] = term;
            }
          } else if (term == "@type") {
            mapping["@id"] = term;
          } else {
            if (!("@vocab" in activeCtx)) {
              throw new JsonLdError("Invalid JSON-LD syntax; @context terms must define an @id.", "jsonld.SyntaxError", { code: "invalid IRI mapping", context: localCtx, term });
            }
            mapping["@id"] = activeCtx["@vocab"] + term;
          }
        }
        if (value["@protected"] === true || defined.get("@protected") === true && value["@protected"] !== false) {
          activeCtx.protected[term] = true;
          mapping.protected = true;
        }
        defined.set(term, true);
        if ("@type" in value) {
          let type = value["@type"];
          if (!_isString(type)) {
            throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be a string.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
          }
          if (type === "@json" || type === "@none") {
            if (api.processingMode(activeCtx, 1)) {
              throw new JsonLdError(`Invalid JSON-LD syntax; an @context @type value must not be "${type}" in JSON-LD 1.0 mode.`, "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
            }
          } else if (type !== "@id" && type !== "@vocab") {
            type = _expandIri(activeCtx, type, { vocab: true, base: false }, localCtx, defined, options);
            if (!_isAbsoluteIri(type)) {
              throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an absolute IRI.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
            }
            if (type.indexOf("_:") === 0) {
              throw new JsonLdError("Invalid JSON-LD syntax; an @context @type value must be an IRI, not a blank node identifier.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
            }
          }
          mapping["@type"] = type;
        }
        if ("@container" in value) {
          const container = _isString(value["@container"]) ? [value["@container"]] : value["@container"] || [];
          const validContainers = ["@list", "@set", "@index", "@language"];
          let isValid = true;
          const hasSet = container.includes("@set");
          if (api.processingMode(activeCtx, 1.1)) {
            validContainers.push("@graph", "@id", "@type");
            if (container.includes("@list")) {
              if (container.length !== 1) {
                throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @list must have no other values", "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
              }
            } else if (container.includes("@graph")) {
              if (container.some((key) => key !== "@graph" && key !== "@id" && key !== "@index" && key !== "@set")) {
                throw new JsonLdError("Invalid JSON-LD syntax; @context @container with @graph must have no other values other than @id, @index, and @set", "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
              }
            } else {
              isValid &= container.length <= (hasSet ? 2 : 1);
            }
            if (container.includes("@type")) {
              mapping["@type"] = mapping["@type"] || "@id";
              if (!["@id", "@vocab"].includes(mapping["@type"])) {
                throw new JsonLdError("Invalid JSON-LD syntax; container: @type requires @type to be @id or @vocab.", "jsonld.SyntaxError", { code: "invalid type mapping", context: localCtx });
              }
            }
          } else {
            isValid &= !_isArray(value["@container"]);
            isValid &= container.length <= 1;
          }
          isValid &= container.every((c) => validContainers.includes(c));
          isValid &= !(hasSet && container.includes("@list"));
          if (!isValid) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @container value must be one of the following: " + validContainers.join(", "), "jsonld.SyntaxError", { code: "invalid container mapping", context: localCtx });
          }
          if (mapping.reverse && !container.every((c) => ["@index", "@set"].includes(c))) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @container value for a @reverse type definition must be @index or @set.", "jsonld.SyntaxError", { code: "invalid reverse property", context: localCtx });
          }
          mapping["@container"] = container;
        }
        if ("@index" in value) {
          if (!("@container" in value) || !mapping["@container"].includes("@index")) {
            throw new JsonLdError(`Invalid JSON-LD syntax; @index without @index in @container: "${value["@index"]}" on term "${term}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          if (!_isString(value["@index"]) || value["@index"].indexOf("@") === 0) {
            throw new JsonLdError(`Invalid JSON-LD syntax; @index must expand to an IRI: "${value["@index"]}" on term "${term}".`, "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          mapping["@index"] = value["@index"];
        }
        if ("@context" in value) {
          mapping["@context"] = value["@context"];
        }
        if ("@language" in value && !("@type" in value)) {
          let language = value["@language"];
          if (language !== null && !_isString(language)) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @language value must be a string or null.", "jsonld.SyntaxError", { code: "invalid language mapping", context: localCtx });
          }
          if (language !== null) {
            language = language.toLowerCase();
          }
          mapping["@language"] = language;
        }
        if ("@prefix" in value) {
          if (mapping._termHasColon) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @prefix used on a compact IRI term", "jsonld.SyntaxError", { code: "invalid term definition", context: localCtx });
          }
          if (typeof value["@prefix"] === "boolean") {
            mapping._prefix = value["@prefix"] === true;
          } else {
            throw new JsonLdError("Invalid JSON-LD syntax; @context value for @prefix must be boolean", "jsonld.SyntaxError", { code: "invalid @prefix value", context: localCtx });
          }
        }
        if ("@nest" in value) {
          const nest = value["@nest"];
          if (!_isString(nest) || nest !== "@nest" && nest.indexOf("@") === 0) {
            throw new JsonLdError("Invalid JSON-LD syntax; @context @nest value must be a string which is not a keyword other than @nest.", "jsonld.SyntaxError", { code: "invalid @nest value", context: localCtx });
          }
          mapping["@nest"] = nest;
        }
        const id = mapping["@id"];
        if (id === "@context" || id === "@preserve") {
          throw new JsonLdError("Invalid JSON-LD syntax; @context and @preserve cannot be aliased.", "jsonld.SyntaxError", { code: "invalid keyword alias", context: localCtx });
        }
        if (previousMapping && previousMapping.protected && !overrideProtected) {
          activeCtx.protected[term] = true;
          mapping.protected = true;
          if (!_deepCompare(previousMapping, mapping)) {
            const protectedMode = options && options.protectedMode || "error";
            if (protectedMode === "error") {
              throw new JsonLdError("Invalid JSON-LD syntax; tried to redefine a protected term.", "jsonld.SyntaxError", { code: "protected term redefinition", context: localCtx, term });
            } else if (protectedMode === "warn") {
              console.warn("WARNING: protected term redefinition", { term });
              return;
            }
            throw new JsonLdError("Invalid protectedMode.", "jsonld.SyntaxError", {
              code: "invalid protected mode",
              context: localCtx,
              term,
              protectedMode
            });
          }
        }
      };
      api.expandIri = (activeCtx, value, relativeTo, options) => {
        return _expandIri(activeCtx, value, relativeTo, void 0, void 0, options);
      };
      function _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {
        if (value === null || !_isString(value) || api.isKeyword(value)) {
          return value;
        }
        if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {
          api.createTermDefinition({
            activeCtx,
            localCtx,
            term: value,
            defined,
            options
          });
        }
        relativeTo = relativeTo || {};
        if (relativeTo.vocab) {
          const mapping = activeCtx.mappings.get(value);
          if (mapping === null) {
            return null;
          }
          if (mapping) {
            return mapping["@id"];
          }
        }
        const colon = value.indexOf(":");
        if (colon > 0) {
          const prefix = value.substr(0, colon);
          const suffix = value.substr(colon + 1);
          if (prefix === "_" || suffix.indexOf("//") === 0) {
            return value;
          }
          if (localCtx && localCtx.hasOwnProperty(prefix)) {
            api.createTermDefinition({
              activeCtx,
              localCtx,
              term: prefix,
              defined,
              options
            });
          }
          const mapping = activeCtx.mappings.get(prefix);
          if (mapping && mapping._prefix) {
            return mapping["@id"] + suffix;
          }
          if (_isAbsoluteIri(value)) {
            return value;
          }
        }
        if (relativeTo.vocab && "@vocab" in activeCtx) {
          return activeCtx["@vocab"] + value;
        }
        if (relativeTo.base) {
          return prependBase(activeCtx["@base"], value);
        }
        return value;
      }
      api.getInitialContext = (options) => {
        const base = parseUrl(options.base || "");
        const key = JSON.stringify({ base, processingMode: options.processingMode });
        const cached = INITIAL_CONTEXT_CACHE.get(key);
        if (cached) {
          return cached;
        }
        const initialContext = {
          "@base": base,
          processingMode: options.processingMode,
          mappings: /* @__PURE__ */ new Map(),
          inverse: null,
          getInverse: _createInverseContext,
          clone: _cloneActiveContext,
          revertToPreviousContext: _revertToPreviousContext,
          protected: {}
        };
        if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {
          INITIAL_CONTEXT_CACHE.clear();
        }
        INITIAL_CONTEXT_CACHE.set(key, initialContext);
        return initialContext;
        function _createInverseContext() {
          const activeCtx = this;
          if (activeCtx.inverse) {
            return activeCtx.inverse;
          }
          const inverse = activeCtx.inverse = {};
          const fastCurieMap = activeCtx.fastCurieMap = {};
          const irisToTerms = {};
          const defaultLanguage = activeCtx["@language"] || "@none";
          const mappings = activeCtx.mappings;
          const terms = [...mappings.keys()].sort(_compareShortestLeast);
          for (const term of terms) {
            const mapping = mappings.get(term);
            if (mapping === null) {
              continue;
            }
            let container = mapping["@container"] || "@none";
            container = [].concat(container).sort().join("");
            const ids = _asArray(mapping["@id"]);
            for (const iri of ids) {
              let entry = inverse[iri];
              const isKeyword = api.isKeyword(iri);
              if (!entry) {
                inverse[iri] = entry = {};
                if (!isKeyword && !mapping._termHasColon) {
                  irisToTerms[iri] = [term];
                  const fastCurieEntry = { iri, terms: irisToTerms[iri] };
                  if (iri[0] in fastCurieMap) {
                    fastCurieMap[iri[0]].push(fastCurieEntry);
                  } else {
                    fastCurieMap[iri[0]] = [fastCurieEntry];
                  }
                }
              } else if (!isKeyword && !mapping._termHasColon) {
                irisToTerms[iri].push(term);
              }
              if (!entry[container]) {
                entry[container] = {
                  "@language": {},
                  "@type": {},
                  "@any": {}
                };
              }
              entry = entry[container];
              _addPreferredTerm(term, entry["@any"], "@none");
              if (mapping.reverse) {
                _addPreferredTerm(term, entry["@type"], "@reverse");
              } else if (mapping["@type"] === "@none") {
                _addPreferredTerm(term, entry["@any"], "@none");
                _addPreferredTerm(term, entry["@language"], "@none");
                _addPreferredTerm(term, entry["@type"], "@none");
              } else if ("@type" in mapping) {
                _addPreferredTerm(term, entry["@type"], mapping["@type"]);
              } else if ("@language" in mapping) {
                const language = mapping["@language"] || "@null";
                _addPreferredTerm(term, entry["@language"], language);
              } else {
                _addPreferredTerm(term, entry["@language"], defaultLanguage);
                _addPreferredTerm(term, entry["@type"], "@none");
                _addPreferredTerm(term, entry["@language"], "@none");
              }
            }
          }
          for (const key2 in fastCurieMap) {
            _buildIriMap(fastCurieMap, key2, 1);
          }
          return inverse;
        }
        function _buildIriMap(iriMap, key2, idx) {
          const entries = iriMap[key2];
          const next = iriMap[key2] = {};
          let iri;
          let letter;
          for (const entry of entries) {
            iri = entry.iri;
            if (idx >= iri.length) {
              letter = "";
            } else {
              letter = iri[idx];
            }
            if (letter in next) {
              next[letter].push(entry);
            } else {
              next[letter] = [entry];
            }
          }
          for (const key3 in next) {
            if (key3 === "") {
              continue;
            }
            _buildIriMap(next, key3, idx + 1);
          }
        }
        function _addPreferredTerm(term, entry, typeOrLanguageValue) {
          if (!entry.hasOwnProperty(typeOrLanguageValue)) {
            entry[typeOrLanguageValue] = term;
          }
        }
        function _cloneActiveContext() {
          const child = {};
          child["@base"] = this["@base"];
          child.mappings = util.clone(this.mappings);
          child.clone = this.clone;
          child.inverse = null;
          child.getInverse = this.getInverse;
          child.protected = util.clone(this.protected);
          if (this.previousContext) {
            child.previousContext = this.previousContext.clone();
          }
          child.revertToPreviousContext = this.revertToPreviousContext;
          if ("@language" in this) {
            child["@language"] = this["@language"];
          }
          if ("@vocab" in this) {
            child["@vocab"] = this["@vocab"];
          }
          return child;
        }
        function _revertToPreviousContext() {
          if (!this.previousContext) {
            return this;
          }
          return this.previousContext.clone();
        }
      };
      api.getContextValue = (ctx, key, type) => {
        if (key === null) {
          if (type === "@context") {
            return void 0;
          }
          return null;
        }
        if (ctx.mappings.has(key)) {
          const entry = ctx.mappings.get(key);
          if (_isUndefined(type)) {
            return entry;
          }
          if (entry.hasOwnProperty(type)) {
            return entry[type];
          }
        }
        if (type === "@language" && ctx.hasOwnProperty(type)) {
          return ctx[type];
        }
        if (type === "@context") {
          return void 0;
        }
        return null;
      };
      api.processingMode = (activeCtx, version) => {
        if (version.toString() >= "1.1") {
          return !activeCtx.processingMode || activeCtx.processingMode >= "json-ld-" + version.toString();
        } else {
          return activeCtx.processingMode === "json-ld-1.0";
        }
      };
      api.isKeyword = (v) => {
        if (!_isString(v) || v[0] !== "@") {
          return false;
        }
        switch (v) {
          case "@base":
          case "@container":
          case "@context":
          case "@default":
          case "@embed":
          case "@explicit":
          case "@graph":
          case "@id":
          case "@index":
          case "@json":
          case "@language":
          case "@list":
          case "@nest":
          case "@none":
          case "@omitDefault":
          case "@prefix":
          case "@preserve":
          case "@protected":
          case "@requireAll":
          case "@reverse":
          case "@set":
          case "@type":
          case "@value":
          case "@version":
          case "@vocab":
            return true;
        }
        return false;
      };
      function _deepCompare(x1, x2) {
        if (!(x1 && typeof x1 === "object") || !(x2 && typeof x2 === "object")) {
          return x1 === x2;
        }
        const x1Array = Array.isArray(x1);
        if (x1Array !== Array.isArray(x2)) {
          return false;
        }
        if (x1Array) {
          if (x1.length !== x2.length) {
            return false;
          }
          for (let i = 0; i < x1.length; ++i) {
            if (!_deepCompare(x1[i], x2[i])) {
              return false;
            }
          }
          return true;
        }
        const k1s = Object.keys(x1);
        const k2s = Object.keys(x2);
        if (k1s.length !== k2s.length) {
          return false;
        }
        for (const k1 in x1) {
          let v1 = x1[k1];
          let v2 = x2[k1];
          if (k1 === "@container") {
            if (Array.isArray(v1) && Array.isArray(v2)) {
              v1 = v1.slice().sort();
              v2 = v2.slice().sort();
            }
          }
          if (!_deepCompare(v1, v2)) {
            return false;
          }
        }
        return true;
      }
    }
  });

  // node_modules/jsonld/lib/expand.js
  var require_expand2 = __commonJS({
    "node_modules/jsonld/lib/expand.js"(exports, module) {
      "use strict";
      var JsonLdError = require_JsonLdError2();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isEmptyObject: _isEmptyObject,
        isString: _isString,
        isUndefined: _isUndefined
      } = require_types2();
      var {
        isList: _isList,
        isValue: _isValue,
        isGraph: _isGraph
      } = require_graphTypes2();
      var {
        expandIri: _expandIri,
        getContextValue: _getContextValue,
        isKeyword: _isKeyword,
        process: _processContext,
        processingMode: _processingMode
      } = require_context2();
      var {
        isAbsolute: _isAbsoluteIri
      } = require_url2();
      var {
        addValue: _addValue,
        asArray: _asArray,
        getValues: _getValues,
        validateTypeValue: _validateTypeValue
      } = require_util8();
      var api = {};
      module.exports = api;
      api.expand = async ({
        activeCtx,
        activeProperty = null,
        element,
        options = {},
        insideList = false,
        insideIndex = false,
        typeScopedContext = null,
        expansionMap = () => void 0
      }) => {
        if (element === null || element === void 0) {
          return null;
        }
        if (activeProperty === "@default") {
          options = Object.assign({}, options, { isFrame: false });
        }
        if (!_isArray(element) && !_isObject(element)) {
          if (!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, { vocab: true }, options) === "@graph")) {
            const mapped = await expansionMap({
              unmappedValue: element,
              activeCtx,
              activeProperty,
              options,
              insideList
            });
            if (mapped === void 0) {
              return null;
            }
            return mapped;
          }
          return _expandValue({ activeCtx, activeProperty, value: element, options });
        }
        if (_isArray(element)) {
          let rval2 = [];
          const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
          insideList = insideList || container.includes("@list");
          for (let i = 0; i < element.length; ++i) {
            let e = await api.expand({
              activeCtx,
              activeProperty,
              element: element[i],
              options,
              expansionMap,
              insideIndex,
              typeScopedContext
            });
            if (insideList && _isArray(e)) {
              e = { "@list": e };
            }
            if (e === null) {
              e = await expansionMap({
                unmappedValue: element[i],
                activeCtx,
                activeProperty,
                parent: element,
                index: i,
                options,
                expandedParent: rval2,
                insideList
              });
              if (e === void 0) {
                continue;
              }
            }
            if (_isArray(e)) {
              rval2 = rval2.concat(e);
            } else {
              rval2.push(e);
            }
          }
          return rval2;
        }
        const expandedActiveProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
        const propertyScopedCtx = _getContextValue(activeCtx, activeProperty, "@context");
        typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);
        let keys = Object.keys(element).sort();
        let mustRevert = !insideIndex;
        if (mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes("@context")) {
          for (const key of keys) {
            const expandedProperty = _expandIri(typeScopedContext, key, { vocab: true }, options);
            if (expandedProperty === "@value") {
              mustRevert = false;
              activeCtx = typeScopedContext;
              break;
            }
            if (expandedProperty === "@id" && keys.length === 1) {
              mustRevert = false;
              break;
            }
          }
        }
        if (mustRevert) {
          activeCtx = activeCtx.revertToPreviousContext();
        }
        if (!_isUndefined(propertyScopedCtx)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: propertyScopedCtx,
            propagate: true,
            overrideProtected: true,
            options
          });
        }
        if ("@context" in element) {
          activeCtx = await _processContext({ activeCtx, localCtx: element["@context"], options });
        }
        typeScopedContext = activeCtx;
        let typeKey = null;
        for (const key of keys) {
          const expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
          if (expandedProperty === "@type") {
            typeKey = typeKey || key;
            const value = element[key];
            const types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];
            for (const type of types) {
              const ctx = _getContextValue(typeScopedContext, type, "@context");
              if (!_isUndefined(ctx)) {
                activeCtx = await _processContext({
                  activeCtx,
                  localCtx: ctx,
                  options,
                  propagate: false
                });
              }
            }
          }
        }
        let rval = {};
        await _expandObject({
          activeCtx,
          activeProperty,
          expandedActiveProperty,
          element,
          expandedParent: rval,
          options,
          insideList,
          typeScopedContext,
          typeKey,
          expansionMap
        });
        keys = Object.keys(rval);
        let count = keys.length;
        if ("@value" in rval) {
          if ("@type" in rval && "@language" in rval) {
            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may not contain both "@type" and "@language".', "jsonld.SyntaxError", { code: "invalid value object", element: rval });
          }
          let validCount = count - 1;
          if ("@type" in rval) {
            validCount -= 1;
          }
          if ("@index" in rval) {
            validCount -= 1;
          }
          if ("@language" in rval) {
            validCount -= 1;
          }
          if (validCount !== 0) {
            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" may only have an "@index" property and at most one other property which can be "@type" or "@language".', "jsonld.SyntaxError", { code: "invalid value object", element: rval });
          }
          const values = rval["@value"] === null ? [] : _asArray(rval["@value"]);
          const types = _getValues(rval, "@type");
          if (_processingMode(activeCtx, 1.1) && types.includes("@json") && types.length === 1) {
          } else if (values.length === 0) {
            const mapped = await expansionMap({
              unmappedValue: rval,
              activeCtx,
              activeProperty,
              element,
              options,
              insideList
            });
            if (mapped !== void 0) {
              rval = mapped;
            } else {
              rval = null;
            }
          } else if (!values.every((v) => _isString(v) || _isEmptyObject(v)) && "@language" in rval) {
            throw new JsonLdError("Invalid JSON-LD syntax; only strings may be language-tagged.", "jsonld.SyntaxError", { code: "invalid language-tagged value", element: rval });
          } else if (!types.every((t) => _isAbsoluteIri(t) && !(_isString(t) && t.indexOf("_:") === 0) || _isEmptyObject(t))) {
            throw new JsonLdError('Invalid JSON-LD syntax; an element containing "@value" and "@type" must have an absolute IRI for the value of "@type".', "jsonld.SyntaxError", { code: "invalid typed value", element: rval });
          }
        } else if ("@type" in rval && !_isArray(rval["@type"])) {
          rval["@type"] = [rval["@type"]];
        } else if ("@set" in rval || "@list" in rval) {
          if (count > 1 && !(count === 2 && "@index" in rval)) {
            throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property "@set" or "@list", then it can have at most one other property that is "@index".', "jsonld.SyntaxError", { code: "invalid set or list object", element: rval });
          }
          if ("@set" in rval) {
            rval = rval["@set"];
            keys = Object.keys(rval);
            count = keys.length;
          }
        } else if (count === 1 && "@language" in rval) {
          const mapped = await expansionMap(rval, {
            unmappedValue: rval,
            activeCtx,
            activeProperty,
            element,
            options,
            insideList
          });
          if (mapped !== void 0) {
            rval = mapped;
          } else {
            rval = null;
          }
        }
        if (_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === "@graph")) {
          if (count === 0 || "@value" in rval || "@list" in rval || count === 1 && "@id" in rval) {
            const mapped = await expansionMap({
              unmappedValue: rval,
              activeCtx,
              activeProperty,
              element,
              options,
              insideList
            });
            if (mapped !== void 0) {
              rval = mapped;
            } else {
              rval = null;
            }
          }
        }
        return rval;
      };
      async function _expandObject({
        activeCtx,
        activeProperty,
        expandedActiveProperty,
        element,
        expandedParent,
        options = {},
        insideList,
        typeScopedContext,
        typeKey,
        expansionMap
      }) {
        const keys = Object.keys(element).sort();
        const nests = [];
        let unexpandedValue;
        const isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], { vocab: true }, options) == "@json";
        for (const key of keys) {
          let value = element[key];
          let expandedValue;
          if (key === "@context") {
            continue;
          }
          let expandedProperty = _expandIri(activeCtx, key, { vocab: true }, options);
          if (expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {
            expandedProperty = expansionMap({
              unmappedProperty: key,
              activeCtx,
              activeProperty,
              parent: element,
              options,
              insideList,
              value,
              expandedParent
            });
            if (expandedProperty === void 0) {
              continue;
            }
          }
          if (_isKeyword(expandedProperty)) {
            if (expandedActiveProperty === "@reverse") {
              throw new JsonLdError("Invalid JSON-LD syntax; a keyword cannot be used as a @reverse property.", "jsonld.SyntaxError", { code: "invalid reverse property map", value });
            }
            if (expandedProperty in expandedParent) {
              throw new JsonLdError("Invalid JSON-LD syntax; colliding keywords detected.", "jsonld.SyntaxError", { code: "colliding keywords", keyword: expandedProperty });
            }
          }
          if (expandedProperty === "@id") {
            if (!_isString(value)) {
              if (!options.isFrame) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@id" value must a string.', "jsonld.SyntaxError", { code: "invalid @id value", value });
              }
              if (_isObject(value)) {
                if (!_isEmptyObject(value)) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value });
                }
              } else if (_isArray(value)) {
                if (!value.every((v) => _isString(v))) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value });
                }
              } else {
                throw new JsonLdError('Invalid JSON-LD syntax; "@id" value an empty object or array of strings, if framing', "jsonld.SyntaxError", { code: "invalid @id value", value });
              }
            }
            _addValue(expandedParent, "@id", _asArray(value).map((v) => _isString(v) ? _expandIri(activeCtx, v, { base: true }, options) : v), { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@type") {
            _validateTypeValue(value);
            _addValue(expandedParent, "@type", _asArray(value).map((v) => _isString(v) ? _expandIri(typeScopedContext, v, { base: true, vocab: true }, options) : v), { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@graph" && !(_isObject(value) || _isArray(value))) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@graph" value must not be an object or an array.', "jsonld.SyntaxError", { code: "invalid @graph value", value });
          }
          if (expandedProperty === "@value") {
            unexpandedValue = value;
            if (isJsonType && _processingMode(activeCtx, 1.1)) {
              expandedParent["@value"] = value;
            } else {
              _addValue(expandedParent, "@value", value, { propertyIsArray: options.isFrame });
            }
            continue;
          }
          if (expandedProperty === "@language") {
            if (value === null) {
              continue;
            }
            if (!_isString(value) && !options.isFrame) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@language" value must be a string.', "jsonld.SyntaxError", { code: "invalid language-tagged string", value });
            }
            value = _asArray(value).map((v) => _isString(v) ? v.toLowerCase() : v);
            _addValue(expandedParent, "@language", value, { propertyIsArray: options.isFrame });
            continue;
          }
          if (expandedProperty === "@index") {
            if (!_isString(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@index" value must be a string.', "jsonld.SyntaxError", { code: "invalid @index value", value });
            }
            _addValue(expandedParent, "@index", value);
            continue;
          }
          if (expandedProperty === "@reverse") {
            if (!_isObject(value)) {
              throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must be an object.', "jsonld.SyntaxError", { code: "invalid @reverse value", value });
            }
            expandedValue = await api.expand({
              activeCtx,
              activeProperty: "@reverse",
              element: value,
              options,
              expansionMap
            });
            if ("@reverse" in expandedValue) {
              for (const property in expandedValue["@reverse"]) {
                _addValue(expandedParent, property, expandedValue["@reverse"][property], { propertyIsArray: true });
              }
            }
            let reverseMap = expandedParent["@reverse"] || null;
            for (const property in expandedValue) {
              if (property === "@reverse") {
                continue;
              }
              if (reverseMap === null) {
                reverseMap = expandedParent["@reverse"] = {};
              }
              _addValue(reverseMap, property, [], { propertyIsArray: true });
              const items = expandedValue[property];
              for (let ii = 0; ii < items.length; ++ii) {
                const item = items[ii];
                if (_isValue(item) || _isList(item)) {
                  throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.', "jsonld.SyntaxError", { code: "invalid reverse property value", value: expandedValue });
                }
                _addValue(reverseMap, property, item, { propertyIsArray: true });
              }
            }
            continue;
          }
          if (expandedProperty === "@nest") {
            nests.push(key);
            continue;
          }
          let termCtx = activeCtx;
          const ctx = _getContextValue(activeCtx, key, "@context");
          if (!_isUndefined(ctx)) {
            termCtx = await _processContext({
              activeCtx,
              localCtx: ctx,
              propagate: true,
              overrideProtected: true,
              options
            });
          }
          const container = _getContextValue(termCtx, key, "@container") || [];
          if (container.includes("@language") && _isObject(value)) {
            expandedValue = _expandLanguageMap(termCtx, value, options);
          } else if (container.includes("@index") && _isObject(value)) {
            const asGraph = container.includes("@graph");
            const indexKey = _getContextValue(termCtx, key, "@index") || "@index";
            const propertyIndex = indexKey !== "@index" && _expandIri(activeCtx, indexKey, { vocab: true }, options);
            expandedValue = await _expandIndexMap({
              activeCtx: termCtx,
              options,
              activeProperty: key,
              value,
              expansionMap,
              asGraph,
              indexKey,
              propertyIndex
            });
          } else if (container.includes("@id") && _isObject(value)) {
            const asGraph = container.includes("@graph");
            expandedValue = await _expandIndexMap({
              activeCtx: termCtx,
              options,
              activeProperty: key,
              value,
              expansionMap,
              asGraph,
              indexKey: "@id"
            });
          } else if (container.includes("@type") && _isObject(value)) {
            expandedValue = await _expandIndexMap({
              activeCtx: termCtx.revertToPreviousContext(),
              options,
              activeProperty: key,
              value,
              expansionMap,
              asGraph: false,
              indexKey: "@type"
            });
          } else {
            const isList = expandedProperty === "@list";
            if (isList || expandedProperty === "@set") {
              let nextActiveProperty = activeProperty;
              if (isList && expandedActiveProperty === "@graph") {
                nextActiveProperty = null;
              }
              expandedValue = await api.expand({
                activeCtx: termCtx,
                activeProperty: nextActiveProperty,
                element: value,
                options,
                insideList: isList,
                expansionMap
              });
            } else if (_getContextValue(activeCtx, key, "@type") === "@json") {
              expandedValue = {
                "@type": "@json",
                "@value": value
              };
            } else {
              expandedValue = await api.expand({
                activeCtx: termCtx,
                activeProperty: key,
                element: value,
                options,
                insideList: false,
                expansionMap
              });
            }
          }
          if (expandedValue === null && expandedProperty !== "@value") {
            expandedValue = expansionMap({
              unmappedValue: value,
              expandedProperty,
              activeCtx: termCtx,
              activeProperty,
              parent: element,
              options,
              insideList,
              key,
              expandedParent
            });
            if (expandedValue === void 0) {
              continue;
            }
          }
          if (expandedProperty !== "@list" && !_isList(expandedValue) && container.includes("@list")) {
            expandedValue = { "@list": _asArray(expandedValue) };
          }
          if (container.includes("@graph") && !container.some((key2) => key2 === "@id" || key2 === "@index")) {
            expandedValue = _asArray(expandedValue).map((v) => ({ "@graph": _asArray(v) }));
          }
          if (termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {
            const reverseMap = expandedParent["@reverse"] = expandedParent["@reverse"] || {};
            expandedValue = _asArray(expandedValue);
            for (let ii = 0; ii < expandedValue.length; ++ii) {
              const item = expandedValue[ii];
              if (_isValue(item) || _isList(item)) {
                throw new JsonLdError('Invalid JSON-LD syntax; "@reverse" value must not be a @value or an @list.', "jsonld.SyntaxError", { code: "invalid reverse property value", value: expandedValue });
              }
              _addValue(reverseMap, expandedProperty, item, { propertyIsArray: true });
            }
            continue;
          }
          _addValue(expandedParent, expandedProperty, expandedValue, {
            propertyIsArray: true
          });
        }
        if ("@value" in expandedParent) {
          if (expandedParent["@type"] === "@json" && _processingMode(activeCtx, 1.1)) {
          } else if ((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame) {
            throw new JsonLdError('Invalid JSON-LD syntax; "@value" value must not be an object or an array.', "jsonld.SyntaxError", { code: "invalid value object value", value: unexpandedValue });
          }
        }
        for (const key of nests) {
          const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];
          for (const nv of nestedValues) {
            if (!_isObject(nv) || Object.keys(nv).some((k) => _expandIri(activeCtx, k, { vocab: true }, options) === "@value")) {
              throw new JsonLdError("Invalid JSON-LD syntax; nested value must be a node object.", "jsonld.SyntaxError", { code: "invalid @nest value", value: nv });
            }
            await _expandObject({
              activeCtx,
              activeProperty,
              expandedActiveProperty,
              element: nv,
              expandedParent,
              options,
              insideList,
              typeKey,
              expansionMap
            });
          }
        }
      }
      function _expandValue({ activeCtx, activeProperty, value, options }) {
        if (value === null || value === void 0) {
          return null;
        }
        const expandedProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
        if (expandedProperty === "@id") {
          return _expandIri(activeCtx, value, { base: true }, options);
        } else if (expandedProperty === "@type") {
          return _expandIri(activeCtx, value, { vocab: true, base: true }, options);
        }
        const type = _getContextValue(activeCtx, activeProperty, "@type");
        if ((type === "@id" || expandedProperty === "@graph") && _isString(value)) {
          return { "@id": _expandIri(activeCtx, value, { base: true }, options) };
        }
        if (type === "@vocab" && _isString(value)) {
          return {
            "@id": _expandIri(activeCtx, value, { vocab: true, base: true }, options)
          };
        }
        if (_isKeyword(expandedProperty)) {
          return value;
        }
        const rval = {};
        if (type && !["@id", "@vocab", "@none"].includes(type)) {
          rval["@type"] = type;
        } else if (_isString(value)) {
          const language = _getContextValue(activeCtx, activeProperty, "@language");
          if (language !== null) {
            rval["@language"] = language;
          }
        }
        if (!["boolean", "number", "string"].includes(typeof value)) {
          value = value.toString();
        }
        rval["@value"] = value;
        return rval;
      }
      function _expandLanguageMap(activeCtx, languageMap, options) {
        const rval = [];
        const keys = Object.keys(languageMap).sort();
        for (const key of keys) {
          const expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
          let val = languageMap[key];
          if (!_isArray(val)) {
            val = [val];
          }
          for (const item of val) {
            if (item === null) {
              continue;
            }
            if (!_isString(item)) {
              throw new JsonLdError("Invalid JSON-LD syntax; language map values must be strings.", "jsonld.SyntaxError", { code: "invalid language map value", languageMap });
            }
            const val2 = { "@value": item };
            if (expandedKey !== "@none") {
              val2["@language"] = key.toLowerCase();
            }
            rval.push(val2);
          }
        }
        return rval;
      }
      async function _expandIndexMap({
        activeCtx,
        options,
        activeProperty,
        value,
        expansionMap,
        asGraph,
        indexKey,
        propertyIndex
      }) {
        const rval = [];
        const keys = Object.keys(value).sort();
        const isTypeIndex = indexKey === "@type";
        for (let key of keys) {
          if (isTypeIndex) {
            const ctx = _getContextValue(activeCtx, key, "@context");
            if (!_isUndefined(ctx)) {
              activeCtx = await _processContext({
                activeCtx,
                localCtx: ctx,
                propagate: false,
                options
              });
            }
          }
          let val = value[key];
          if (!_isArray(val)) {
            val = [val];
          }
          val = await api.expand({
            activeCtx,
            activeProperty,
            element: val,
            options,
            insideList: false,
            insideIndex: true,
            expansionMap
          });
          let expandedKey;
          if (propertyIndex) {
            if (key === "@none") {
              expandedKey = "@none";
            } else {
              expandedKey = _expandValue({ activeCtx, activeProperty: indexKey, value: key, options });
            }
          } else {
            expandedKey = _expandIri(activeCtx, key, { vocab: true }, options);
          }
          if (indexKey === "@id") {
            key = _expandIri(activeCtx, key, { base: true }, options);
          } else if (isTypeIndex) {
            key = expandedKey;
          }
          for (let item of val) {
            if (asGraph && !_isGraph(item)) {
              item = { "@graph": [item] };
            }
            if (indexKey === "@type") {
              if (expandedKey === "@none") {
              } else if (item["@type"]) {
                item["@type"] = [key].concat(item["@type"]);
              } else {
                item["@type"] = [key];
              }
            } else if (_isValue(item) && !["@language", "@type", "@index"].includes(indexKey)) {
              throw new JsonLdError(`Invalid JSON-LD syntax; Attempt to add illegal key to value object: "${indexKey}".`, "jsonld.SyntaxError", { code: "invalid value object", value: item });
            } else if (propertyIndex) {
              if (expandedKey !== "@none") {
                _addValue(item, propertyIndex, expandedKey, {
                  propertyIsArray: true,
                  prependValue: true
                });
              }
            } else if (expandedKey !== "@none" && !(indexKey in item)) {
              item[indexKey] = key;
            }
            rval.push(item);
          }
        }
        return rval;
      }
    }
  });

  // node_modules/jsonld/lib/nodeMap.js
  var require_nodeMap2 = __commonJS({
    "node_modules/jsonld/lib/nodeMap.js"(exports, module) {
      "use strict";
      var { isKeyword } = require_context2();
      var graphTypes = require_graphTypes2();
      var types = require_types2();
      var util = require_util8();
      var JsonLdError = require_JsonLdError2();
      var api = {};
      module.exports = api;
      api.createMergedNodeMap = (input, options) => {
        options = options || {};
        const issuer = options.issuer || new util.IdentifierIssuer("_:b");
        const graphs = { "@default": {} };
        api.createNodeMap(input, graphs, "@default", issuer);
        return api.mergeNodeMaps(graphs);
      };
      api.createNodeMap = (input, graphs, graph, issuer, name, list) => {
        if (types.isArray(input)) {
          for (const node of input) {
            api.createNodeMap(node, graphs, graph, issuer, void 0, list);
          }
          return;
        }
        if (!types.isObject(input)) {
          if (list) {
            list.push(input);
          }
          return;
        }
        if (graphTypes.isValue(input)) {
          if ("@type" in input) {
            let type = input["@type"];
            if (type.indexOf("_:") === 0) {
              input["@type"] = type = issuer.getId(type);
            }
          }
          if (list) {
            list.push(input);
          }
          return;
        } else if (list && graphTypes.isList(input)) {
          const _list = [];
          api.createNodeMap(input["@list"], graphs, graph, issuer, name, _list);
          list.push({ "@list": _list });
          return;
        }
        if ("@type" in input) {
          const types2 = input["@type"];
          for (const type of types2) {
            if (type.indexOf("_:") === 0) {
              issuer.getId(type);
            }
          }
        }
        if (types.isUndefined(name)) {
          name = graphTypes.isBlankNode(input) ? issuer.getId(input["@id"]) : input["@id"];
        }
        if (list) {
          list.push({ "@id": name });
        }
        const subjects = graphs[graph];
        const subject = subjects[name] = subjects[name] || {};
        subject["@id"] = name;
        const properties = Object.keys(input).sort();
        for (let property of properties) {
          if (property === "@id") {
            continue;
          }
          if (property === "@reverse") {
            const referencedNode = { "@id": name };
            const reverseMap = input["@reverse"];
            for (const reverseProperty in reverseMap) {
              const items = reverseMap[reverseProperty];
              for (const item of items) {
                let itemName = item["@id"];
                if (graphTypes.isBlankNode(item)) {
                  itemName = issuer.getId(itemName);
                }
                api.createNodeMap(item, graphs, graph, issuer, itemName);
                util.addValue(subjects[itemName], reverseProperty, referencedNode, { propertyIsArray: true, allowDuplicate: false });
              }
            }
            continue;
          }
          if (property === "@graph") {
            if (!(name in graphs)) {
              graphs[name] = {};
            }
            api.createNodeMap(input[property], graphs, name, issuer);
            continue;
          }
          if (property !== "@type" && isKeyword(property)) {
            if (property === "@index" && property in subject && (input[property] !== subject[property] || input[property]["@id"] !== subject[property]["@id"])) {
              throw new JsonLdError("Invalid JSON-LD syntax; conflicting @index property detected.", "jsonld.SyntaxError", { code: "conflicting indexes", subject });
            }
            subject[property] = input[property];
            continue;
          }
          const objects = input[property];
          if (property.indexOf("_:") === 0) {
            property = issuer.getId(property);
          }
          if (objects.length === 0) {
            util.addValue(subject, property, [], { propertyIsArray: true });
            continue;
          }
          for (let o of objects) {
            if (property === "@type") {
              o = o.indexOf("_:") === 0 ? issuer.getId(o) : o;
            }
            if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {
              const id = graphTypes.isBlankNode(o) ? issuer.getId(o["@id"]) : o["@id"];
              util.addValue(subject, property, { "@id": id }, { propertyIsArray: true, allowDuplicate: false });
              api.createNodeMap(o, graphs, graph, issuer, id);
            } else if (graphTypes.isValue(o)) {
              util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
            } else if (graphTypes.isList(o)) {
              const _list = [];
              api.createNodeMap(o["@list"], graphs, graph, issuer, name, _list);
              o = { "@list": _list };
              util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
            } else {
              api.createNodeMap(o, graphs, graph, issuer, name);
              util.addValue(subject, property, o, { propertyIsArray: true, allowDuplicate: false });
            }
          }
        }
      };
      api.mergeNodeMapGraphs = (graphs) => {
        const merged = {};
        for (const name of Object.keys(graphs).sort()) {
          for (const id of Object.keys(graphs[name]).sort()) {
            const node = graphs[name][id];
            if (!(id in merged)) {
              merged[id] = { "@id": id };
            }
            const mergedNode = merged[id];
            for (const property of Object.keys(node).sort()) {
              if (isKeyword(property)) {
                mergedNode[property] = util.clone(node[property]);
              } else {
                for (const value of node[property]) {
                  util.addValue(mergedNode, property, util.clone(value), { propertyIsArray: true, allowDuplicate: false });
                }
              }
            }
          }
        }
        return merged;
      };
      api.mergeNodeMaps = (graphs) => {
        const defaultGraph = graphs["@default"];
        const graphNames = Object.keys(graphs).sort();
        for (const graphName of graphNames) {
          if (graphName === "@default") {
            continue;
          }
          const nodeMap = graphs[graphName];
          let subject = defaultGraph[graphName];
          if (!subject) {
            defaultGraph[graphName] = subject = {
              "@id": graphName,
              "@graph": []
            };
          } else if (!("@graph" in subject)) {
            subject["@graph"] = [];
          }
          const graph = subject["@graph"];
          for (const id of Object.keys(nodeMap).sort()) {
            const node = nodeMap[id];
            if (!graphTypes.isSubjectReference(node)) {
              graph.push(node);
            }
          }
        }
        return defaultGraph;
      };
    }
  });

  // node_modules/jsonld/lib/flatten.js
  var require_flatten2 = __commonJS({
    "node_modules/jsonld/lib/flatten.js"(exports, module) {
      "use strict";
      var {
        isSubjectReference: _isSubjectReference
      } = require_graphTypes2();
      var {
        createMergedNodeMap: _createMergedNodeMap
      } = require_nodeMap2();
      var api = {};
      module.exports = api;
      api.flatten = (input) => {
        const defaultGraph = _createMergedNodeMap(input);
        const flattened = [];
        const keys = Object.keys(defaultGraph).sort();
        for (let ki = 0; ki < keys.length; ++ki) {
          const node = defaultGraph[keys[ki]];
          if (!_isSubjectReference(node)) {
            flattened.push(node);
          }
        }
        return flattened;
      };
    }
  });

  // node_modules/jsonld/lib/fromRdf.js
  var require_fromRdf2 = __commonJS({
    "node_modules/jsonld/lib/fromRdf.js"(exports, module) {
      "use strict";
      var JsonLdError = require_JsonLdError2();
      var graphTypes = require_graphTypes2();
      var types = require_types2();
      var util = require_util8();
      var {
        RDF_LIST,
        RDF_FIRST,
        RDF_REST,
        RDF_NIL,
        RDF_TYPE,
        RDF_JSON_LITERAL,
        XSD_BOOLEAN,
        XSD_DOUBLE,
        XSD_INTEGER,
        XSD_STRING
      } = require_constants4();
      var api = {};
      module.exports = api;
      api.fromRDF = async (dataset, { useRdfType = false, useNativeTypes = false }) => {
        const defaultGraph = {};
        const graphMap = { "@default": defaultGraph };
        const referencedOnce = {};
        for (const quad of dataset) {
          const name = quad.graph.termType === "DefaultGraph" ? "@default" : quad.graph.value;
          if (!(name in graphMap)) {
            graphMap[name] = {};
          }
          if (name !== "@default" && !(name in defaultGraph)) {
            defaultGraph[name] = { "@id": name };
          }
          const nodeMap = graphMap[name];
          const s = quad.subject.value;
          const p = quad.predicate.value;
          const o = quad.object;
          if (!(s in nodeMap)) {
            nodeMap[s] = { "@id": s };
          }
          const node = nodeMap[s];
          const objectIsNode = o.termType.endsWith("Node");
          if (objectIsNode && !(o.value in nodeMap)) {
            nodeMap[o.value] = { "@id": o.value };
          }
          if (p === RDF_TYPE && !useRdfType && objectIsNode) {
            util.addValue(node, "@type", o.value, { propertyIsArray: true });
            continue;
          }
          const value = _RDFToObject(o, useNativeTypes);
          util.addValue(node, p, value, { propertyIsArray: true });
          if (objectIsNode) {
            if (o.value === RDF_NIL) {
              const object = nodeMap[o.value];
              if (!("usages" in object)) {
                object.usages = [];
              }
              object.usages.push({
                node,
                property: p,
                value
              });
            } else if (o.value in referencedOnce) {
              referencedOnce[o.value] = false;
            } else {
              referencedOnce[o.value] = {
                node,
                property: p,
                value
              };
            }
          }
        }
        for (const name in graphMap) {
          const graphObject = graphMap[name];
          if (!(RDF_NIL in graphObject)) {
            continue;
          }
          const nil = graphObject[RDF_NIL];
          if (!nil.usages) {
            continue;
          }
          for (let usage of nil.usages) {
            let node = usage.node;
            let property = usage.property;
            let head = usage.value;
            const list = [];
            const listNodes = [];
            let nodeKeyCount = Object.keys(node).length;
            while (property === RDF_REST && types.isObject(referencedOnce[node["@id"]]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node["@type"]) && node["@type"].length === 1 && node["@type"][0] === RDF_LIST)) {
              list.push(node[RDF_FIRST][0]);
              listNodes.push(node["@id"]);
              usage = referencedOnce[node["@id"]];
              node = usage.node;
              property = usage.property;
              head = usage.value;
              nodeKeyCount = Object.keys(node).length;
              if (!graphTypes.isBlankNode(node)) {
                break;
              }
            }
            delete head["@id"];
            head["@list"] = list.reverse();
            for (const listNode of listNodes) {
              delete graphObject[listNode];
            }
          }
          delete nil.usages;
        }
        const result = [];
        const subjects = Object.keys(defaultGraph).sort();
        for (const subject of subjects) {
          const node = defaultGraph[subject];
          if (subject in graphMap) {
            const graph = node["@graph"] = [];
            const graphObject = graphMap[subject];
            const graphSubjects = Object.keys(graphObject).sort();
            for (const graphSubject of graphSubjects) {
              const node2 = graphObject[graphSubject];
              if (!graphTypes.isSubjectReference(node2)) {
                graph.push(node2);
              }
            }
          }
          if (!graphTypes.isSubjectReference(node)) {
            result.push(node);
          }
        }
        return result;
      };
      function _RDFToObject(o, useNativeTypes) {
        if (o.termType.endsWith("Node")) {
          return { "@id": o.value };
        }
        const rval = { "@value": o.value };
        if (o.language) {
          rval["@language"] = o.language;
        } else {
          let type = o.datatype.value;
          if (!type) {
            type = XSD_STRING;
          }
          if (type === RDF_JSON_LITERAL) {
            type = "@json";
            try {
              rval["@value"] = JSON.parse(rval["@value"]);
            } catch (e) {
              throw new JsonLdError("JSON literal could not be parsed.", "jsonld.InvalidJsonLiteral", { code: "invalid JSON literal", value: rval["@value"], cause: e });
            }
          }
          if (useNativeTypes) {
            if (type === XSD_BOOLEAN) {
              if (rval["@value"] === "true") {
                rval["@value"] = true;
              } else if (rval["@value"] === "false") {
                rval["@value"] = false;
              }
            } else if (types.isNumeric(rval["@value"])) {
              if (type === XSD_INTEGER) {
                const i = parseInt(rval["@value"], 10);
                if (i.toFixed(0) === rval["@value"]) {
                  rval["@value"] = i;
                }
              } else if (type === XSD_DOUBLE) {
                rval["@value"] = parseFloat(rval["@value"]);
              }
            }
            if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {
              rval["@type"] = type;
            }
          } else if (type !== XSD_STRING) {
            rval["@type"] = type;
          }
        }
        return rval;
      }
    }
  });

  // node_modules/jsonld/lib/toRdf.js
  var require_toRdf2 = __commonJS({
    "node_modules/jsonld/lib/toRdf.js"(exports, module) {
      "use strict";
      var { createNodeMap } = require_nodeMap2();
      var { isKeyword } = require_context2();
      var graphTypes = require_graphTypes2();
      var jsonCanonicalize = require_canonicalize();
      var types = require_types2();
      var util = require_util8();
      var {
        RDF_FIRST,
        RDF_REST,
        RDF_NIL,
        RDF_TYPE,
        RDF_JSON_LITERAL,
        RDF_LANGSTRING,
        XSD_BOOLEAN,
        XSD_DOUBLE,
        XSD_INTEGER,
        XSD_STRING
      } = require_constants4();
      var {
        isAbsolute: _isAbsoluteIri
      } = require_url2();
      var api = {};
      module.exports = api;
      api.toRDF = (input, options) => {
        const issuer = new util.IdentifierIssuer("_:b");
        const nodeMap = { "@default": {} };
        createNodeMap(input, nodeMap, "@default", issuer);
        const dataset = [];
        const graphNames = Object.keys(nodeMap).sort();
        for (const graphName of graphNames) {
          let graphTerm;
          if (graphName === "@default") {
            graphTerm = { termType: "DefaultGraph", value: "" };
          } else if (_isAbsoluteIri(graphName)) {
            if (graphName.startsWith("_:")) {
              graphTerm = { termType: "BlankNode" };
            } else {
              graphTerm = { termType: "NamedNode" };
            }
            graphTerm.value = graphName;
          } else {
            continue;
          }
          _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);
        }
        return dataset;
      };
      function _graphToRDF(dataset, graph, graphTerm, issuer, options) {
        const ids = Object.keys(graph).sort();
        for (const id of ids) {
          const node = graph[id];
          const properties = Object.keys(node).sort();
          for (let property of properties) {
            const items = node[property];
            if (property === "@type") {
              property = RDF_TYPE;
            } else if (isKeyword(property)) {
              continue;
            }
            for (const item of items) {
              const subject = {
                termType: id.startsWith("_:") ? "BlankNode" : "NamedNode",
                value: id
              };
              if (!_isAbsoluteIri(id)) {
                continue;
              }
              const predicate = {
                termType: property.startsWith("_:") ? "BlankNode" : "NamedNode",
                value: property
              };
              if (!_isAbsoluteIri(property)) {
                continue;
              }
              if (predicate.termType === "BlankNode" && !options.produceGeneralizedRdf) {
                continue;
              }
              const object = _objectToRDF(item, issuer, dataset, graphTerm);
              if (object) {
                dataset.push({
                  subject,
                  predicate,
                  object,
                  graph: graphTerm
                });
              }
            }
          }
        }
      }
      function _listToRDF(list, issuer, dataset, graphTerm) {
        const first = { termType: "NamedNode", value: RDF_FIRST };
        const rest = { termType: "NamedNode", value: RDF_REST };
        const nil = { termType: "NamedNode", value: RDF_NIL };
        const last = list.pop();
        const result = last ? { termType: "BlankNode", value: issuer.getId() } : nil;
        let subject = result;
        for (const item of list) {
          const object = _objectToRDF(item, issuer, dataset, graphTerm);
          const next = { termType: "BlankNode", value: issuer.getId() };
          dataset.push({
            subject,
            predicate: first,
            object,
            graph: graphTerm
          });
          dataset.push({
            subject,
            predicate: rest,
            object: next,
            graph: graphTerm
          });
          subject = next;
        }
        if (last) {
          const object = _objectToRDF(last, issuer, dataset, graphTerm);
          dataset.push({
            subject,
            predicate: first,
            object,
            graph: graphTerm
          });
          dataset.push({
            subject,
            predicate: rest,
            object: nil,
            graph: graphTerm
          });
        }
        return result;
      }
      function _objectToRDF(item, issuer, dataset, graphTerm) {
        const object = {};
        if (graphTypes.isValue(item)) {
          object.termType = "Literal";
          object.value = void 0;
          object.datatype = {
            termType: "NamedNode"
          };
          let value = item["@value"];
          const datatype = item["@type"] || null;
          if (datatype === "@json") {
            object.value = jsonCanonicalize(value);
            object.datatype.value = RDF_JSON_LITERAL;
          } else if (types.isBoolean(value)) {
            object.value = value.toString();
            object.datatype.value = datatype || XSD_BOOLEAN;
          } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {
            if (!types.isDouble(value)) {
              value = parseFloat(value);
            }
            object.value = value.toExponential(15).replace(/(\d)0*e\+?/, "$1E");
            object.datatype.value = datatype || XSD_DOUBLE;
          } else if (types.isNumber(value)) {
            object.value = value.toFixed(0);
            object.datatype.value = datatype || XSD_INTEGER;
          } else if ("@language" in item) {
            object.value = value;
            object.datatype.value = datatype || RDF_LANGSTRING;
            object.language = item["@language"];
          } else {
            object.value = value;
            object.datatype.value = datatype || XSD_STRING;
          }
        } else if (graphTypes.isList(item)) {
          const _list = _listToRDF(item["@list"], issuer, dataset, graphTerm);
          object.termType = _list.termType;
          object.value = _list.value;
        } else {
          const id = types.isObject(item) ? item["@id"] : item;
          object.termType = id.startsWith("_:") ? "BlankNode" : "NamedNode";
          object.value = id;
        }
        if (object.termType === "NamedNode" && !_isAbsoluteIri(object.value)) {
          return null;
        }
        return object;
      }
    }
  });

  // node_modules/jsonld/lib/frame.js
  var require_frame2 = __commonJS({
    "node_modules/jsonld/lib/frame.js"(exports, module) {
      "use strict";
      var { isKeyword } = require_context2();
      var graphTypes = require_graphTypes2();
      var types = require_types2();
      var util = require_util8();
      var JsonLdError = require_JsonLdError2();
      var {
        createNodeMap: _createNodeMap,
        mergeNodeMapGraphs: _mergeNodeMapGraphs
      } = require_nodeMap2();
      var api = {};
      module.exports = api;
      api.frameMergedOrDefault = (input, frame, options) => {
        const state = {
          options,
          graph: "@default",
          graphMap: { "@default": {} },
          graphStack: [],
          subjectStack: [],
          link: {},
          bnodeMap: {}
        };
        const issuer = new util.IdentifierIssuer("_:b");
        _createNodeMap(input, state.graphMap, "@default", issuer);
        if (options.merged) {
          state.graphMap["@merged"] = _mergeNodeMapGraphs(state.graphMap);
          state.graph = "@merged";
        }
        state.subjects = state.graphMap[state.graph];
        const framed = [];
        api.frame(state, Object.keys(state.subjects).sort(), frame, framed);
        if (options.pruneBlankNodeIdentifiers) {
          options.bnodesToClear = Object.keys(state.bnodeMap).filter((id) => state.bnodeMap[id].length === 1);
        }
        return framed;
      };
      api.frame = (state, subjects, frame, parent, property = null) => {
        _validateFrame(frame);
        frame = frame[0];
        const options = state.options;
        const flags = {
          embed: _getFrameFlag(frame, options, "embed"),
          explicit: _getFrameFlag(frame, options, "explicit"),
          requireAll: _getFrameFlag(frame, options, "requireAll")
        };
        const matches = _filterSubjects(state, subjects, frame, flags);
        const ids = Object.keys(matches).sort();
        for (const id of ids) {
          const subject = matches[id];
          if (flags.embed === "@link" && id in state.link) {
            _addFrameOutput(parent, property, state.link[id]);
            continue;
          }
          if (property === null) {
            state.uniqueEmbeds = { [state.graph]: {} };
          } else {
            state.uniqueEmbeds[state.graph] = state.uniqueEmbeds[state.graph] || {};
          }
          const output = {};
          output["@id"] = id;
          if (id.indexOf("_:") === 0) {
            util.addValue(state.bnodeMap, id, output, { propertyIsArray: true });
          }
          state.link[id] = output;
          if (flags.embed === "@never" || _createsCircularReference(subject, state.graph, state.subjectStack)) {
            _addFrameOutput(parent, property, output);
            continue;
          }
          if (flags.embed === "@last") {
            if (id in state.uniqueEmbeds[state.graph]) {
              _removeEmbed(state, id);
            }
            state.uniqueEmbeds[state.graph][id] = { parent, property };
          }
          state.subjectStack.push({ subject, graph: state.graph });
          if (id in state.graphMap) {
            let recurse = false;
            let subframe = null;
            if (!("@graph" in frame)) {
              recurse = state.graph !== "@merged";
              subframe = {};
            } else {
              subframe = frame["@graph"][0];
              if (!types.isObject(subframe)) {
                subframe = {};
              }
              recurse = !(id === "@merged" || id === "@default");
            }
            if (recurse) {
              state.graphStack.push(state.graph);
              state.graph = id;
              api.frame(state, Object.keys(state.graphMap[id]).sort(), [subframe], output, "@graph");
              state.graph = state.graphStack.pop;
            }
          }
          for (const prop of Object.keys(subject).sort()) {
            if (isKeyword(prop)) {
              output[prop] = util.clone(subject[prop]);
              if (prop === "@type") {
                for (const type of subject["@type"]) {
                  if (type.indexOf("_:") === 0) {
                    util.addValue(state.bnodeMap, type, output, { propertyIsArray: true });
                  }
                }
              }
              continue;
            }
            if (flags.explicit && !(prop in frame)) {
              continue;
            }
            for (let o of subject[prop]) {
              const subframe = prop in frame ? frame[prop] : _createImplicitFrame(flags);
              if (graphTypes.isList(o)) {
                const list = { "@list": [] };
                _addFrameOutput(output, prop, list);
                const src = o["@list"];
                for (const n in src) {
                  o = src[n];
                  if (graphTypes.isSubjectReference(o)) {
                    const subframe2 = prop in frame ? frame[prop][0]["@list"] : _createImplicitFrame(flags);
                    api.frame(state, [o["@id"]], subframe2, list, "@list");
                  } else {
                    _addFrameOutput(list, "@list", util.clone(o));
                  }
                }
                continue;
              }
              if (graphTypes.isSubjectReference(o)) {
                api.frame(state, [o["@id"]], subframe, output, prop);
              } else if (_valueMatch(subframe[0], o)) {
                _addFrameOutput(output, prop, util.clone(o));
              }
            }
          }
          for (const prop of Object.keys(frame).sort()) {
            if (isKeyword(prop)) {
              continue;
            }
            const next = frame[prop][0] || {};
            const omitDefaultOn = _getFrameFlag(next, options, "omitDefault");
            if (!omitDefaultOn && !(prop in output)) {
              let preserve = "@null";
              if ("@default" in next) {
                preserve = util.clone(next["@default"]);
              }
              if (!types.isArray(preserve)) {
                preserve = [preserve];
              }
              output[prop] = [{ "@preserve": preserve }];
            }
          }
          if ("@reverse" in frame) {
            for (const reverseProp of Object.keys(frame["@reverse"]).sort()) {
              const subframe = frame["@reverse"][reverseProp];
              for (const subject2 of Object.keys(state.subjects)) {
                const nodeValues = util.getValues(state.subjects[subject2], reverseProp);
                if (nodeValues.some((v) => v["@id"] === id)) {
                  output["@reverse"] = output["@reverse"] || {};
                  util.addValue(output["@reverse"], reverseProp, [], { propertyIsArray: true });
                  api.frame(state, [subject2], subframe, output["@reverse"][reverseProp], property);
                }
              }
            }
          }
          _addFrameOutput(parent, property, output);
          state.subjectStack.pop();
        }
      };
      function _createImplicitFrame(flags) {
        const frame = {};
        for (const key in flags) {
          if (flags[key] !== void 0) {
            frame["@" + key] = [flags[key]];
          }
        }
        return [frame];
      }
      function _createsCircularReference(subjectToEmbed, graph, subjectStack) {
        for (let i = subjectStack.length - 1; i >= 0; --i) {
          const subject = subjectStack[i];
          if (subject.graph === graph && subject.subject["@id"] === subjectToEmbed["@id"]) {
            return true;
          }
        }
        return false;
      }
      function _getFrameFlag(frame, options, name) {
        const flag = "@" + name;
        let rval = flag in frame ? frame[flag][0] : options[name];
        if (name === "embed") {
          if (rval === true) {
            rval = "@last";
          } else if (rval === false) {
            rval = "@never";
          } else if (rval !== "@always" && rval !== "@never" && rval !== "@link") {
            rval = "@last";
          }
        }
        return rval;
      }
      function _validateFrame(frame) {
        if (!types.isArray(frame) || frame.length !== 1 || !types.isObject(frame[0])) {
          throw new JsonLdError("Invalid JSON-LD syntax; a JSON-LD frame must be a single object.", "jsonld.SyntaxError", { frame });
        }
      }
      function _filterSubjects(state, subjects, frame, flags) {
        const rval = {};
        for (const id of subjects) {
          const subject = state.graphMap[state.graph][id];
          if (_filterSubject(state, subject, frame, flags)) {
            rval[id] = subject;
          }
        }
        return rval;
      }
      function _filterSubject(state, subject, frame, flags) {
        let wildcard = true;
        let matchesSome = false;
        for (const key in frame) {
          let matchThis = false;
          const nodeValues = util.getValues(subject, key);
          const isEmpty = util.getValues(frame, key).length === 0;
          if (isKeyword(key)) {
            if (key !== "@id" && key !== "@type") {
              continue;
            }
            wildcard = false;
            if (key === "@id") {
              if (frame["@id"].length >= 0 && !types.isEmptyObject(frame["@id"][0])) {
                return frame["@id"].includes(nodeValues[0]);
              }
              matchThis = true;
              continue;
            }
            if ("@type" in frame) {
              if (isEmpty) {
                if (nodeValues.length > 0) {
                  return false;
                }
                matchThis = true;
              } else if (frame["@type"].length === 1 && types.isEmptyObject(frame["@type"][0])) {
                matchThis = nodeValues.length > 0;
              } else {
                for (const type of frame["@type"]) {
                  if (nodeValues.some((tt) => tt === type)) {
                    return true;
                  }
                }
                return false;
              }
            }
          }
          const thisFrame = util.getValues(frame, key)[0];
          let hasDefault = false;
          if (thisFrame) {
            _validateFrame([thisFrame]);
            hasDefault = "@default" in thisFrame;
          }
          wildcard = false;
          if (nodeValues.length === 0 && hasDefault) {
            continue;
          }
          if (nodeValues.length > 0 && isEmpty) {
            return false;
          }
          if (thisFrame === void 0) {
            if (nodeValues.length > 0) {
              return false;
            }
            matchThis = true;
          } else if (types.isObject(thisFrame)) {
            matchThis = nodeValues.length > 0;
          } else {
            if (graphTypes.isValue(thisFrame)) {
              matchThis = nodeValues.some((nv) => _valueMatch(thisFrame, nv));
            } else if (graphTypes.isSubject(thisFrame) || graphTypes.isSubjectReference(thisFrame)) {
              matchThis = nodeValues.some((nv) => _nodeMatch(state, thisFrame, nv, flags));
            } else if (graphTypes.isList(thisFrame)) {
              const listValue = thisFrame["@list"][0];
              if (graphTypes.isList(nodeValues[0])) {
                const nodeListValues = nodeValues[0]["@list"];
                if (graphTypes.isValue(listValue)) {
                  matchThis = nodeListValues.some((lv) => _valueMatch(listValue, lv));
                } else if (graphTypes.isSubject(listValue) || graphTypes.isSubjectReference(listValue)) {
                  matchThis = nodeListValues.some((lv) => _nodeMatch(state, listValue, lv, flags));
                }
              } else {
                matchThis = false;
              }
            }
          }
          if (!matchThis && flags.requireAll) {
            return false;
          }
          matchesSome = matchesSome || matchThis;
        }
        return wildcard || matchesSome;
      }
      function _removeEmbed(state, id) {
        const embeds = state.uniqueEmbeds[state.graph];
        const embed = embeds[id];
        const parent = embed.parent;
        const property = embed.property;
        const subject = { "@id": id };
        if (types.isArray(parent)) {
          for (let i = 0; i < parent.length; ++i) {
            if (util.compareValues(parent[i], subject)) {
              parent[i] = subject;
              break;
            }
          }
        } else {
          const useArray = types.isArray(parent[property]);
          util.removeValue(parent, property, subject, { propertyIsArray: useArray });
          util.addValue(parent, property, subject, { propertyIsArray: useArray });
        }
        const removeDependents = (id2) => {
          const ids = Object.keys(embeds);
          for (const next of ids) {
            if (next in embeds && types.isObject(embeds[next].parent) && embeds[next].parent["@id"] === id2) {
              delete embeds[next];
              removeDependents(next);
            }
          }
        };
        removeDependents(id);
      }
      function _addFrameOutput(parent, property, output) {
        if (types.isObject(parent)) {
          util.addValue(parent, property, output, { propertyIsArray: true });
        } else {
          parent.push(output);
        }
      }
      function _nodeMatch(state, pattern, value, flags) {
        if (!("@id" in value)) {
          return false;
        }
        const nodeObject = state.subjects[value["@id"]];
        return nodeObject && _filterSubject(state, nodeObject, pattern, flags);
      }
      function _valueMatch(pattern, value) {
        const v1 = value["@value"];
        const t1 = value["@type"];
        const l1 = value["@language"];
        const v2 = pattern["@value"] ? types.isArray(pattern["@value"]) ? pattern["@value"] : [pattern["@value"]] : [];
        const t2 = pattern["@type"] ? types.isArray(pattern["@type"]) ? pattern["@type"] : [pattern["@type"]] : [];
        const l2 = pattern["@language"] ? types.isArray(pattern["@language"]) ? pattern["@language"] : [pattern["@language"]] : [];
        if (v2.length === 0 && t2.length === 0 && l2.length === 0) {
          return true;
        }
        if (!(v2.includes(v1) || types.isEmptyObject(v2[0]))) {
          return false;
        }
        if (!(!t1 && t2.length === 0 || t2.includes(t1) || t1 && types.isEmptyObject(t2[0]))) {
          return false;
        }
        if (!(!l1 && l2.length === 0 || l2.includes(l1) || l1 && types.isEmptyObject(l2[0]))) {
          return false;
        }
        return true;
      }
    }
  });

  // node_modules/jsonld/lib/compact.js
  var require_compact2 = __commonJS({
    "node_modules/jsonld/lib/compact.js"(exports, module) {
      "use strict";
      var JsonLdError = require_JsonLdError2();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString,
        isUndefined: _isUndefined
      } = require_types2();
      var {
        isList: _isList,
        isValue: _isValue,
        isGraph: _isGraph,
        isSimpleGraph: _isSimpleGraph,
        isSubjectReference: _isSubjectReference
      } = require_graphTypes2();
      var {
        expandIri: _expandIri,
        getContextValue: _getContextValue,
        isKeyword: _isKeyword,
        process: _processContext,
        processingMode: _processingMode
      } = require_context2();
      var {
        removeBase: _removeBase
      } = require_url2();
      var {
        addValue: _addValue,
        asArray: _asArray,
        compareShortestLeast: _compareShortestLeast
      } = require_util8();
      var api = {};
      module.exports = api;
      api.compact = async ({
        activeCtx,
        activeProperty = null,
        element,
        options = {},
        compactionMap = () => void 0
      }) => {
        if (_isArray(element)) {
          let rval = [];
          for (let i = 0; i < element.length; ++i) {
            let compacted = await api.compact({
              activeCtx,
              activeProperty,
              element: element[i],
              options,
              compactionMap
            });
            if (compacted === null) {
              compacted = await compactionMap({
                unmappedValue: element[i],
                activeCtx,
                activeProperty,
                parent: element,
                index: i,
                options
              });
              if (compacted === void 0) {
                continue;
              }
            }
            rval.push(compacted);
          }
          if (options.compactArrays && rval.length === 1) {
            const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
            if (container.length === 0) {
              rval = rval[0];
            }
          }
          return rval;
        }
        const ctx = _getContextValue(activeCtx, activeProperty, "@context");
        if (!_isUndefined(ctx)) {
          activeCtx = await _processContext({
            activeCtx,
            localCtx: ctx,
            propagate: true,
            overrideProtected: true,
            options
          });
        }
        if (_isObject(element)) {
          if (options.link && "@id" in element && options.link.hasOwnProperty(element["@id"])) {
            const linked = options.link[element["@id"]];
            for (let i = 0; i < linked.length; ++i) {
              if (linked[i].expanded === element) {
                return linked[i].compacted;
              }
            }
          }
          if (_isValue(element) || _isSubjectReference(element)) {
            const rval2 = api.compactValue({ activeCtx, activeProperty, value: element, options });
            if (options.link && _isSubjectReference(element)) {
              if (!options.link.hasOwnProperty(element["@id"])) {
                options.link[element["@id"]] = [];
              }
              options.link[element["@id"]].push({ expanded: element, compacted: rval2 });
            }
            return rval2;
          }
          if (_isList(element)) {
            const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
            if (container.includes("@list")) {
              return api.compact({
                activeCtx,
                activeProperty,
                element: element["@list"],
                options,
                compactionMap
              });
            }
          }
          const insideReverse = activeProperty === "@reverse";
          const rval = {};
          const inputCtx = activeCtx;
          if (!_isValue(element) && !_isSubjectReference(element)) {
            activeCtx = activeCtx.revertToPreviousContext();
          }
          const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, "@context");
          if (!_isUndefined(propertyScopedCtx)) {
            activeCtx = await _processContext({
              activeCtx,
              localCtx: propertyScopedCtx,
              propagate: true,
              overrideProtected: true,
              options
            });
          }
          if (options.link && "@id" in element) {
            if (!options.link.hasOwnProperty(element["@id"])) {
              options.link[element["@id"]] = [];
            }
            options.link[element["@id"]].push({ expanded: element, compacted: rval });
          }
          let types = element["@type"] || [];
          if (types.length > 1) {
            types = Array.from(types).sort();
          }
          const typeContext = activeCtx;
          for (const type of types) {
            const compactedType = api.compactIri({ activeCtx: typeContext, iri: type, relativeTo: { vocab: true } });
            const ctx2 = _getContextValue(inputCtx, compactedType, "@context");
            if (!_isUndefined(ctx2)) {
              activeCtx = await _processContext({
                activeCtx,
                localCtx: ctx2,
                options,
                propagate: false
              });
            }
          }
          const keys = Object.keys(element).sort();
          for (const expandedProperty of keys) {
            const expandedValue = element[expandedProperty];
            if (expandedProperty === "@id") {
              let compactedValue = _asArray(expandedValue).map((expandedIri) => api.compactIri({
                activeCtx,
                iri: expandedIri,
                relativeTo: { vocab: false }
              }));
              if (compactedValue.length === 1) {
                compactedValue = compactedValue[0];
              }
              const alias = api.compactIri({ activeCtx, iri: "@id", relativeTo: { vocab: true } });
              rval[alias] = compactedValue;
              continue;
            }
            if (expandedProperty === "@type") {
              let compactedValue = _asArray(expandedValue).map((expandedIri) => api.compactIri({
                activeCtx: inputCtx,
                iri: expandedIri,
                relativeTo: { vocab: true }
              }));
              if (compactedValue.length === 1) {
                compactedValue = compactedValue[0];
              }
              const alias = api.compactIri({ activeCtx, iri: "@type", relativeTo: { vocab: true } });
              const container = _getContextValue(activeCtx, alias, "@container") || [];
              const typeAsSet = container.includes("@set") && _processingMode(activeCtx, 1.1);
              const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;
              _addValue(rval, alias, compactedValue, { propertyIsArray: isArray });
              continue;
            }
            if (expandedProperty === "@reverse") {
              const compactedValue = await api.compact({
                activeCtx,
                activeProperty: "@reverse",
                element: expandedValue,
                options,
                compactionMap
              });
              for (const compactedProperty in compactedValue) {
                if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {
                  const value = compactedValue[compactedProperty];
                  const container = _getContextValue(activeCtx, compactedProperty, "@container") || [];
                  const useArray = container.includes("@set") || !options.compactArrays;
                  _addValue(rval, compactedProperty, value, { propertyIsArray: useArray });
                  delete compactedValue[compactedProperty];
                }
              }
              if (Object.keys(compactedValue).length > 0) {
                const alias = api.compactIri({
                  activeCtx,
                  iri: expandedProperty,
                  relativeTo: { vocab: true }
                });
                _addValue(rval, alias, compactedValue);
              }
              continue;
            }
            if (expandedProperty === "@preserve") {
              const compactedValue = await api.compact({
                activeCtx,
                activeProperty,
                element: expandedValue,
                options,
                compactionMap
              });
              if (!(_isArray(compactedValue) && compactedValue.length === 0)) {
                _addValue(rval, expandedProperty, compactedValue);
              }
              continue;
            }
            if (expandedProperty === "@index") {
              const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
              if (container.includes("@index")) {
                continue;
              }
              const alias = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                relativeTo: { vocab: true }
              });
              _addValue(rval, alias, expandedValue);
              continue;
            }
            if (expandedProperty !== "@graph" && expandedProperty !== "@list" && _isKeyword(expandedProperty)) {
              const alias = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                relativeTo: { vocab: true }
              });
              _addValue(rval, alias, expandedValue);
              continue;
            }
            if (!_isArray(expandedValue)) {
              throw new JsonLdError("JSON-LD expansion error; expanded value must be an array.", "jsonld.SyntaxError");
            }
            if (expandedValue.length === 0) {
              const itemActiveProperty = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                value: expandedValue,
                relativeTo: { vocab: true },
                reverse: insideReverse
              });
              const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
              let nestResult = rval;
              if (nestProperty) {
                _checkNestProperty(activeCtx, nestProperty, options);
                if (!_isObject(rval[nestProperty])) {
                  rval[nestProperty] = {};
                }
                nestResult = rval[nestProperty];
              }
              _addValue(nestResult, itemActiveProperty, expandedValue, {
                propertyIsArray: true
              });
            }
            for (const expandedItem of expandedValue) {
              const itemActiveProperty = api.compactIri({
                activeCtx,
                iri: expandedProperty,
                value: expandedItem,
                relativeTo: { vocab: true },
                reverse: insideReverse
              });
              const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)["@nest"] : null;
              let nestResult = rval;
              if (nestProperty) {
                _checkNestProperty(activeCtx, nestProperty, options);
                if (!_isObject(rval[nestProperty])) {
                  rval[nestProperty] = {};
                }
                nestResult = rval[nestProperty];
              }
              const container = _getContextValue(activeCtx, itemActiveProperty, "@container") || [];
              const isGraph = _isGraph(expandedItem);
              const isList = _isList(expandedItem);
              let inner;
              if (isList) {
                inner = expandedItem["@list"];
              } else if (isGraph) {
                inner = expandedItem["@graph"];
              }
              let compactedItem = await api.compact({
                activeCtx,
                activeProperty: itemActiveProperty,
                element: isList || isGraph ? inner : expandedItem,
                options,
                compactionMap
              });
              if (isList) {
                if (!_isArray(compactedItem)) {
                  compactedItem = [compactedItem];
                }
                if (!container.includes("@list")) {
                  compactedItem = {
                    [api.compactIri({
                      activeCtx,
                      iri: "@list",
                      relativeTo: { vocab: true }
                    })]: compactedItem
                  };
                  if ("@index" in expandedItem) {
                    compactedItem[api.compactIri({
                      activeCtx,
                      iri: "@index",
                      relativeTo: { vocab: true }
                    })] = expandedItem["@index"];
                  }
                } else {
                  _addValue(nestResult, itemActiveProperty, compactedItem, {
                    valueIsArray: true,
                    allowDuplicate: true
                  });
                  continue;
                }
              }
              if (isGraph) {
                if (container.includes("@graph") && (container.includes("@id") || container.includes("@index") && _isSimpleGraph(expandedItem))) {
                  let mapObject;
                  if (nestResult.hasOwnProperty(itemActiveProperty)) {
                    mapObject = nestResult[itemActiveProperty];
                  } else {
                    nestResult[itemActiveProperty] = mapObject = {};
                  }
                  const key = (container.includes("@id") ? expandedItem["@id"] : expandedItem["@index"]) || api.compactIri({ activeCtx, iri: "@none", vocab: true });
                  _addValue(mapObject, key, compactedItem, {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  });
                } else if (container.includes("@graph") && _isSimpleGraph(expandedItem)) {
                  if (_isArray(compactedItem) && compactedItem.length > 1) {
                    compactedItem = { "@included": compactedItem };
                  }
                  _addValue(nestResult, itemActiveProperty, compactedItem, {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  });
                } else {
                  if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {
                    compactedItem = compactedItem[0];
                  }
                  compactedItem = {
                    [api.compactIri({
                      activeCtx,
                      iri: "@graph",
                      relativeTo: { vocab: true }
                    })]: compactedItem
                  };
                  if ("@id" in expandedItem) {
                    compactedItem[api.compactIri({
                      activeCtx,
                      iri: "@id",
                      relativeTo: { vocab: true }
                    })] = expandedItem["@id"];
                  }
                  if ("@index" in expandedItem) {
                    compactedItem[api.compactIri({
                      activeCtx,
                      iri: "@index",
                      relativeTo: { vocab: true }
                    })] = expandedItem["@index"];
                  }
                  _addValue(nestResult, itemActiveProperty, compactedItem, {
                    propertyIsArray: !options.compactArrays || container.includes("@set")
                  });
                }
              } else if (container.includes("@language") || container.includes("@index") || container.includes("@id") || container.includes("@type")) {
                let mapObject;
                if (nestResult.hasOwnProperty(itemActiveProperty)) {
                  mapObject = nestResult[itemActiveProperty];
                } else {
                  nestResult[itemActiveProperty] = mapObject = {};
                }
                let key;
                if (container.includes("@language")) {
                  if (_isValue(compactedItem)) {
                    compactedItem = compactedItem["@value"];
                  }
                  key = expandedItem["@language"];
                } else if (container.includes("@index")) {
                  const indexKey = _getContextValue(activeCtx, itemActiveProperty, "@index") || "@index";
                  const containerKey = api.compactIri({ activeCtx, iri: indexKey, vocab: true });
                  if (indexKey === "@index") {
                    key = expandedItem["@index"];
                    delete compactedItem[containerKey];
                  } else {
                    let others;
                    [key, ...others] = _asArray(compactedItem[indexKey] || []);
                    if (!_isString(key)) {
                      key = null;
                    } else {
                      switch (others.length) {
                        case 0:
                          delete compactedItem[indexKey];
                          break;
                        case 1:
                          compactedItem[indexKey] = others[0];
                          break;
                        default:
                          compactedItem[indexKey] = others;
                          break;
                      }
                    }
                  }
                } else if (container.includes("@id")) {
                  const idKey = api.compactIri({ activeCtx, iri: "@id", vocab: true });
                  key = compactedItem[idKey];
                  delete compactedItem[idKey];
                } else if (container.includes("@type")) {
                  const typeKey = api.compactIri({
                    activeCtx,
                    iri: "@type",
                    vocab: true
                  });
                  let types2;
                  [key, ...types2] = _asArray(compactedItem[typeKey] || []);
                  switch (types2.length) {
                    case 0:
                      delete compactedItem[typeKey];
                      break;
                    case 1:
                      compactedItem[typeKey] = types2[0];
                      break;
                    default:
                      compactedItem[typeKey] = types2;
                      break;
                  }
                  if (Object.keys(compactedItem).length === 1 && "@id" in expandedItem) {
                    compactedItem = await api.compact({
                      activeCtx,
                      activeProperty: itemActiveProperty,
                      element: { "@id": expandedItem["@id"] },
                      options,
                      compactionMap
                    });
                  }
                }
                if (!key) {
                  key = api.compactIri({ activeCtx, iri: "@none", vocab: true });
                }
                _addValue(mapObject, key, compactedItem, {
                  propertyIsArray: container.includes("@set")
                });
              } else {
                const isArray = !options.compactArrays || container.includes("@set") || container.includes("@list") || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === "@list" || expandedProperty === "@graph";
                _addValue(nestResult, itemActiveProperty, compactedItem, { propertyIsArray: isArray });
              }
            }
          }
          return rval;
        }
        return element;
      };
      api.compactIri = ({
        activeCtx,
        iri,
        value = null,
        relativeTo = { vocab: false },
        reverse = false
      }) => {
        if (iri === null) {
          return iri;
        }
        if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {
          activeCtx = activeCtx.previousContext;
        }
        const inverseCtx = activeCtx.getInverse();
        if (_isKeyword(iri) && iri in inverseCtx && "@none" in inverseCtx[iri] && "@type" in inverseCtx[iri]["@none"] && "@none" in inverseCtx[iri]["@none"]["@type"]) {
          return inverseCtx[iri]["@none"]["@type"]["@none"];
        }
        if (relativeTo.vocab && iri in inverseCtx) {
          const defaultLanguage = activeCtx["@language"] || "@none";
          const containers = [];
          if (_isObject(value) && "@index" in value && !("@graph" in value)) {
            containers.push("@index", "@index@set");
          }
          if (_isObject(value) && "@preserve" in value) {
            value = value["@preserve"][0];
          }
          if (_isGraph(value)) {
            if ("@index" in value) {
              containers.push("@graph@index", "@graph@index@set", "@index", "@index@set");
            }
            if ("@id" in value) {
              containers.push("@graph@id", "@graph@id@set");
            }
            containers.push("@graph", "@graph@set", "@set");
            if (!("@index" in value)) {
              containers.push("@graph@index", "@graph@index@set", "@index", "@index@set");
            }
            if (!("@id" in value)) {
              containers.push("@graph@id", "@graph@id@set");
            }
          } else if (_isObject(value) && !_isValue(value)) {
            containers.push("@id", "@id@set", "@type", "@set@type");
          }
          let typeOrLanguage = "@language";
          let typeOrLanguageValue = "@null";
          if (reverse) {
            typeOrLanguage = "@type";
            typeOrLanguageValue = "@reverse";
            containers.push("@set");
          } else if (_isList(value)) {
            if (!("@index" in value)) {
              containers.push("@list");
            }
            const list = value["@list"];
            if (list.length === 0) {
              typeOrLanguage = "@any";
              typeOrLanguageValue = "@none";
            } else {
              let commonLanguage = list.length === 0 ? defaultLanguage : null;
              let commonType = null;
              for (let i = 0; i < list.length; ++i) {
                const item = list[i];
                let itemLanguage = "@none";
                let itemType = "@none";
                if (_isValue(item)) {
                  if ("@language" in item) {
                    itemLanguage = item["@language"];
                  } else if ("@type" in item) {
                    itemType = item["@type"];
                  } else {
                    itemLanguage = "@null";
                  }
                } else {
                  itemType = "@id";
                }
                if (commonLanguage === null) {
                  commonLanguage = itemLanguage;
                } else if (itemLanguage !== commonLanguage && _isValue(item)) {
                  commonLanguage = "@none";
                }
                if (commonType === null) {
                  commonType = itemType;
                } else if (itemType !== commonType) {
                  commonType = "@none";
                }
                if (commonLanguage === "@none" && commonType === "@none") {
                  break;
                }
              }
              commonLanguage = commonLanguage || "@none";
              commonType = commonType || "@none";
              if (commonType !== "@none") {
                typeOrLanguage = "@type";
                typeOrLanguageValue = commonType;
              } else {
                typeOrLanguageValue = commonLanguage;
              }
            }
          } else {
            if (_isValue(value)) {
              if ("@language" in value && !("@index" in value)) {
                containers.push("@language", "@language@set");
                typeOrLanguageValue = value["@language"];
              } else if ("@type" in value) {
                typeOrLanguage = "@type";
                typeOrLanguageValue = value["@type"];
              }
            } else {
              typeOrLanguage = "@type";
              typeOrLanguageValue = "@id";
            }
            containers.push("@set");
          }
          containers.push("@none");
          if (_isObject(value) && !("@index" in value)) {
            containers.push("@index", "@index@set");
          }
          if (_isValue(value) && Object.keys(value).length === 1) {
            containers.push("@language", "@language@set");
          }
          const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);
          if (term !== null) {
            return term;
          }
        }
        if (relativeTo.vocab) {
          if ("@vocab" in activeCtx) {
            const vocab = activeCtx["@vocab"];
            if (iri.indexOf(vocab) === 0 && iri !== vocab) {
              const suffix = iri.substr(vocab.length);
              if (!activeCtx.mappings.has(suffix)) {
                return suffix;
              }
            }
          }
        }
        let choice = null;
        const partialMatches = [];
        let iriMap = activeCtx.fastCurieMap;
        const maxPartialLength = iri.length - 1;
        for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {
          iriMap = iriMap[iri[i]];
          if ("" in iriMap) {
            partialMatches.push(iriMap[""][0]);
          }
        }
        for (let i = partialMatches.length - 1; i >= 0; --i) {
          const entry = partialMatches[i];
          const terms = entry.terms;
          for (const term of terms) {
            const curie = term + ":" + iri.substr(entry.iri.length);
            const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)["@id"] === iri);
            if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {
              choice = curie;
            }
          }
        }
        if (choice !== null) {
          return choice;
        }
        for (const [term, td] of activeCtx.mappings) {
          if (td && td._prefix && iri.startsWith(term + ":")) {
            throw new JsonLdError(`Absolute IRI "${iri}" confused with prefix "${term}".`, "jsonld.SyntaxError", { code: "IRI confused with prefix", context: activeCtx });
          }
        }
        if (!relativeTo.vocab) {
          return _removeBase(activeCtx["@base"], iri);
        }
        return iri;
      };
      api.compactValue = ({ activeCtx, activeProperty, value, options }) => {
        if (_isValue(value)) {
          const type2 = _getContextValue(activeCtx, activeProperty, "@type");
          const language = _getContextValue(activeCtx, activeProperty, "@language");
          const container = _getContextValue(activeCtx, activeProperty, "@container") || [];
          const preserveIndex = "@index" in value && !container.includes("@index");
          if (!preserveIndex && type2 !== "@none") {
            if (value["@type"] === type2 || value["@language"] === language) {
              return value["@value"];
            }
          }
          const keyCount = Object.keys(value).length;
          const isValueOnlyKey = keyCount === 1 || keyCount === 2 && "@index" in value && !preserveIndex;
          const hasDefaultLanguage = "@language" in activeCtx;
          const isValueString = _isString(value["@value"]);
          const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)["@language"] === null;
          if (isValueOnlyKey && type2 !== "@none" && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {
            return value["@value"];
          }
          const rval = {};
          if (preserveIndex) {
            rval[api.compactIri({
              activeCtx,
              iri: "@index",
              relativeTo: { vocab: true }
            })] = value["@index"];
          }
          if ("@type" in value) {
            rval[api.compactIri({
              activeCtx,
              iri: "@type",
              relativeTo: { vocab: true }
            })] = api.compactIri({ activeCtx, iri: value["@type"], relativeTo: { vocab: true } });
          } else if ("@language" in value) {
            rval[api.compactIri({
              activeCtx,
              iri: "@language",
              relativeTo: { vocab: true }
            })] = value["@language"];
          }
          rval[api.compactIri({
            activeCtx,
            iri: "@value",
            relativeTo: { vocab: true }
          })] = value["@value"];
          return rval;
        }
        const expandedProperty = _expandIri(activeCtx, activeProperty, { vocab: true }, options);
        const type = _getContextValue(activeCtx, activeProperty, "@type");
        const compacted = api.compactIri({ activeCtx, iri: value["@id"], relativeTo: { vocab: type === "@vocab" } });
        if (type === "@id" || type === "@vocab" || expandedProperty === "@graph") {
          return compacted;
        }
        return {
          [api.compactIri({
            activeCtx,
            iri: "@id",
            relativeTo: { vocab: true }
          })]: compacted
        };
      };
      api.removePreserve = (ctx, input, options) => {
        if (_isArray(input)) {
          const output = [];
          for (let i = 0; i < input.length; ++i) {
            const result = api.removePreserve(ctx, input[i], options);
            if (result !== null) {
              output.push(result);
            }
          }
          input = output;
        } else if (_isObject(input)) {
          if ("@preserve" in input) {
            if (input["@preserve"] === "@null") {
              return null;
            }
            return input["@preserve"];
          }
          if (_isValue(input)) {
            return input;
          }
          if (_isList(input)) {
            input["@list"] = api.removePreserve(ctx, input["@list"], options);
            return input;
          }
          const idAlias = api.compactIri({
            activeCtx: ctx,
            iri: "@id",
            relativeTo: { vocab: true }
          });
          if (input.hasOwnProperty(idAlias)) {
            const id = input[idAlias];
            if (options.link.hasOwnProperty(id)) {
              const idx = options.link[id].indexOf(input);
              if (idx !== -1) {
                return options.link[id][idx];
              }
              options.link[id].push(input);
            } else {
              options.link[id] = [input];
            }
          }
          const graphAlias = api.compactIri({
            activeCtx: ctx,
            iri: "@graph",
            relativeTo: { vocab: true }
          });
          for (const prop in input) {
            if (prop === idAlias && options.bnodesToClear.includes(input[prop])) {
              delete input[idAlias];
              continue;
            }
            let result = api.removePreserve(ctx, input[prop], options);
            const container = _getContextValue(ctx, prop, "@container") || [];
            if (options.compactArrays && _isArray(result) && result.length === 1 && container.length === 0 && prop !== graphAlias) {
              result = result[0];
            }
            input[prop] = result;
          }
        }
        return input;
      };
      function _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {
        if (typeOrLanguageValue === null) {
          typeOrLanguageValue = "@null";
        }
        const prefs = [];
        if ((typeOrLanguageValue === "@id" || typeOrLanguageValue === "@reverse") && _isObject(value) && "@id" in value) {
          if (typeOrLanguageValue === "@reverse") {
            prefs.push("@reverse");
          }
          const term = api.compactIri({ activeCtx, iri: value["@id"], relativeTo: { vocab: true } });
          if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)["@id"] === value["@id"]) {
            prefs.push.apply(prefs, ["@vocab", "@id"]);
          } else {
            prefs.push.apply(prefs, ["@id", "@vocab"]);
          }
        } else {
          prefs.push(typeOrLanguageValue);
        }
        prefs.push("@none");
        const containerMap = activeCtx.inverse[iri];
        for (const container of containers) {
          if (!(container in containerMap)) {
            continue;
          }
          const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];
          for (const pref of prefs) {
            if (!(pref in typeOrLanguageValueMap)) {
              continue;
            }
            return typeOrLanguageValueMap[pref];
          }
        }
        return null;
      }
      function _checkNestProperty(activeCtx, nestProperty, options) {
        if (_expandIri(activeCtx, nestProperty, { vocab: true }, options) !== "@nest") {
          throw new JsonLdError("JSON-LD compact error; nested property must have an @nest value resolving to @nest.", "jsonld.SyntaxError", { code: "invalid @nest value" });
        }
      }
    }
  });

  // node_modules/jsonld/lib/RequestQueue.js
  var require_RequestQueue2 = __commonJS({
    "node_modules/jsonld/lib/RequestQueue.js"(exports, module) {
      "use strict";
      module.exports = class RequestQueue {
        constructor() {
          this._requests = {};
        }
        wrapLoader(loader) {
          const self2 = this;
          self2._loader = loader;
          return function() {
            return self2.add.apply(self2, arguments);
          };
        }
        async add(url) {
          let promise = this._requests[url];
          if (promise) {
            return Promise.resolve(promise);
          }
          promise = this._requests[url] = this._loader(url);
          try {
            return await promise;
          } finally {
            delete this._requests[url];
          }
        }
      };
    }
  });

  // (disabled):node_modules/request/index.js
  var require_request = __commonJS({
    "(disabled):node_modules/request/index.js"() {
    }
  });

  // (disabled):http
  var require_http = __commonJS({
    "(disabled):http"() {
    }
  });

  // node_modules/jsonld/lib/documentLoaders/node.js
  var require_node = __commonJS({
    "node_modules/jsonld/lib/documentLoaders/node.js"(exports, module) {
      "use strict";
      var { parseLinkHeader, buildHeaders } = require_util8();
      var { LINK_HEADER_REL } = require_constants4();
      var JsonLdError = require_JsonLdError2();
      var RequestQueue = require_RequestQueue2();
      module.exports = ({
        secure,
        strictSSL = true,
        maxRedirects = -1,
        request,
        headers = {}
      } = { strictSSL: true, maxRedirects: -1, headers: {} }) => {
        headers = buildHeaders(headers);
        request = request || require_request();
        const http = require_http();
        const queue = new RequestQueue();
        return queue.wrapLoader(function(url) {
          return loadDocument(url, []);
        });
        async function loadDocument(url, redirects) {
          if (url.indexOf("http:") !== 0 && url.indexOf("https:") !== 0) {
            throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are supported.', "jsonld.InvalidUrl", { code: "loading document failed", url });
          }
          if (secure && url.indexOf("https") !== 0) {
            throw new JsonLdError(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`, "jsonld.InvalidUrl", { code: "loading document failed", url });
          }
          let doc = null;
          if (doc !== null) {
            return doc;
          }
          let result;
          try {
            result = await _request(request, {
              url,
              headers,
              strictSSL,
              followRedirect: false
            });
          } catch (e) {
            throw new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", { code: "loading document failed", url, cause: e });
          }
          const { res, body } = result;
          doc = { contextUrl: null, documentUrl: url, document: body || null };
          const statusText = http.STATUS_CODES[res.statusCode];
          if (res.statusCode >= 400) {
            throw new JsonLdError(`URL "${url}" could not be dereferenced: ${statusText}`, "jsonld.InvalidUrl", {
              code: "loading document failed",
              url,
              httpStatusCode: res.statusCode
            });
          }
          if (res.headers.link && res.headers["content-type"] !== "application/ld+json") {
            const linkHeader = parseLinkHeader(res.headers.link)[LINK_HEADER_REL];
            if (Array.isArray(linkHeader)) {
              throw new JsonLdError("URL could not be dereferenced, it has more than one associated HTTP Link Header.", "jsonld.InvalidUrl", { code: "multiple context link headers", url });
            }
            if (linkHeader) {
              doc.contextUrl = linkHeader.target;
            }
          }
          if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
            if (redirects.length === maxRedirects) {
              throw new JsonLdError("URL could not be dereferenced; there were too many redirects.", "jsonld.TooManyRedirects", {
                code: "loading document failed",
                url,
                httpStatusCode: res.statusCode,
                redirects
              });
            }
            if (redirects.indexOf(url) !== -1) {
              throw new JsonLdError("URL could not be dereferenced; infinite redirection was detected.", "jsonld.InfiniteRedirectDetected", {
                code: "recursive context inclusion",
                url,
                httpStatusCode: res.statusCode,
                redirects
              });
            }
            redirects.push(url);
            return loadDocument(res.headers.location, redirects);
          }
          redirects.push(url);
          return doc;
        }
      };
      function _request(request, options) {
        return new Promise((resolve, reject) => {
          request(options, (err, res, body) => {
            if (err) {
              reject(err);
            } else {
              resolve({ res, body });
            }
          });
        });
      }
    }
  });

  // node_modules/jsonld/lib/documentLoaders/xhr.js
  var require_xhr2 = __commonJS({
    "node_modules/jsonld/lib/documentLoaders/xhr.js"(exports, module) {
      "use strict";
      var { parseLinkHeader, buildHeaders } = require_util8();
      var { LINK_HEADER_REL } = require_constants4();
      var JsonLdError = require_JsonLdError2();
      var RequestQueue = require_RequestQueue2();
      var REGEX_LINK_HEADER = /(^|(\r\n))link:/i;
      module.exports = ({
        secure,
        headers = {},
        xhr
      } = { headers: {} }) => {
        headers = buildHeaders(headers);
        const queue = new RequestQueue();
        return queue.wrapLoader(loader);
        async function loader(url) {
          if (url.indexOf("http:") !== 0 && url.indexOf("https:") !== 0) {
            throw new JsonLdError('URL could not be dereferenced; only "http" and "https" URLs are supported.', "jsonld.InvalidUrl", { code: "loading document failed", url });
          }
          if (secure && url.indexOf("https") !== 0) {
            throw new JsonLdError(`URL could not be dereferenced; secure mode is enabled and the URL's scheme is not "https".`, "jsonld.InvalidUrl", { code: "loading document failed", url });
          }
          let req;
          try {
            req = await _get(xhr, url, headers);
          } catch (e) {
            throw new JsonLdError("URL could not be dereferenced, an error occurred.", "jsonld.LoadDocumentError", { code: "loading document failed", url, cause: e });
          }
          if (req.status >= 400) {
            throw new JsonLdError("URL could not be dereferenced: " + req.statusText, "jsonld.LoadDocumentError", {
              code: "loading document failed",
              url,
              httpStatusCode: req.status
            });
          }
          const doc = { contextUrl: null, documentUrl: url, document: req.response };
          const contentType = req.getResponseHeader("Content-Type");
          let linkHeader;
          if (REGEX_LINK_HEADER.test(req.getAllResponseHeaders())) {
            linkHeader = req.getResponseHeader("Link");
          }
          if (linkHeader && contentType !== "application/ld+json") {
            linkHeader = parseLinkHeader(linkHeader)[LINK_HEADER_REL];
            if (Array.isArray(linkHeader)) {
              throw new JsonLdError("URL could not be dereferenced, it has more than one associated HTTP Link Header.", "jsonld.InvalidUrl", { code: "multiple context link headers", url });
            }
            if (linkHeader) {
              doc.contextUrl = linkHeader.target;
            }
          }
          return doc;
        }
      };
      function _get(xhr, url, headers) {
        xhr = xhr || XMLHttpRequest;
        const req = new xhr();
        return new Promise((resolve, reject) => {
          req.onload = () => resolve(req);
          req.onerror = (err) => reject(err);
          req.open("GET", url, true);
          for (const k in headers) {
            req.setRequestHeader(k, headers[k]);
          }
          req.send();
        });
      }
    }
  });

  // node_modules/jsonld/lib/JsonLdProcessor.js
  var require_JsonLdProcessor2 = __commonJS({
    "node_modules/jsonld/lib/JsonLdProcessor.js"(exports, module) {
      "use strict";
      module.exports = (jsonld) => {
        class JsonLdProcessor {
          toString() {
            return "[object JsonLdProcessor]";
          }
        }
        Object.defineProperty(JsonLdProcessor, "prototype", {
          writable: false,
          enumerable: false
        });
        Object.defineProperty(JsonLdProcessor.prototype, "constructor", {
          writable: true,
          enumerable: false,
          configurable: true,
          value: JsonLdProcessor
        });
        JsonLdProcessor.compact = function(input, ctx) {
          if (arguments.length < 2) {
            return Promise.reject(new TypeError("Could not compact, too few arguments."));
          }
          return jsonld.compact(input, ctx);
        };
        JsonLdProcessor.expand = function(input) {
          if (arguments.length < 1) {
            return Promise.reject(new TypeError("Could not expand, too few arguments."));
          }
          return jsonld.expand(input);
        };
        JsonLdProcessor.flatten = function(input) {
          if (arguments.length < 1) {
            return Promise.reject(new TypeError("Could not flatten, too few arguments."));
          }
          return jsonld.flatten(input);
        };
        return JsonLdProcessor;
      };
    }
  });

  // node_modules/jsonld/lib/jsonld.js
  var require_jsonld2 = __commonJS({
    "node_modules/jsonld/lib/jsonld.js"(exports, module) {
      var canonize = require_lib4();
      var util = require_util8();
      var ContextResolver = require_ContextResolver2();
      var IdentifierIssuer = util.IdentifierIssuer;
      var JsonLdError = require_JsonLdError2();
      var LRU = require_lru_cache2();
      var NQuads = require_NQuads4();
      var Rdfa = require_Rdfa();
      var { expand: _expand } = require_expand2();
      var { flatten: _flatten } = require_flatten2();
      var { fromRDF: _fromRDF } = require_fromRdf2();
      var { toRDF: _toRDF } = require_toRdf2();
      var {
        frameMergedOrDefault: _frameMergedOrDefault
      } = require_frame2();
      var {
        isArray: _isArray,
        isObject: _isObject,
        isString: _isString
      } = require_types2();
      var {
        isSubjectReference: _isSubjectReference
      } = require_graphTypes2();
      var {
        getInitialContext: _getInitialContext,
        process: _processContext
      } = require_context2();
      var {
        compact: _compact,
        compactIri: _compactIri,
        removePreserve: _removePreserve
      } = require_compact2();
      var {
        createNodeMap: _createNodeMap,
        createMergedNodeMap: _createMergedNodeMap,
        mergeNodeMaps: _mergeNodeMaps
      } = require_nodeMap2();
      var _nodejs = typeof process !== "undefined" && process.versions && process.versions.node;
      var _browser = !_nodejs && (typeof window !== "undefined" || typeof self !== "undefined");
      var wrapper = function(jsonld) {
        const _rdfParsers = {};
        const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;
        const _resolvedContextCache = new LRU({ max: RESOLVED_CONTEXT_CACHE_MAX_SIZE });
        jsonld.compact = async function(input, ctx, options) {
          if (arguments.length < 2) {
            throw new TypeError("Could not compact, too few arguments.");
          }
          if (ctx === null) {
            throw new JsonLdError("The compaction context must not be null.", "jsonld.CompactError", { code: "invalid local context" });
          }
          if (input === null) {
            return null;
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            compactArrays: true,
            compactToRelative: true,
            graph: false,
            skipExpansion: false,
            link: false,
            issuer: new IdentifierIssuer("_:b"),
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (options.link) {
            options.skipExpansion = true;
          }
          if (!options.compactToRelative) {
            delete options.base;
          }
          let expanded;
          if (options.skipExpansion) {
            expanded = input;
          } else {
            expanded = await jsonld.expand(input, options);
          }
          const activeCtx = await jsonld.processContext(_getInitialContext(options), ctx, options);
          let compacted = await _compact({
            activeCtx,
            element: expanded,
            options,
            compactionMap: options.compactionMap
          });
          if (options.compactArrays && !options.graph && _isArray(compacted)) {
            if (compacted.length === 1) {
              compacted = compacted[0];
            } else if (compacted.length === 0) {
              compacted = {};
            }
          } else if (options.graph && _isObject(compacted)) {
            compacted = [compacted];
          }
          if (_isObject(ctx) && "@context" in ctx) {
            ctx = ctx["@context"];
          }
          ctx = util.clone(ctx);
          if (!_isArray(ctx)) {
            ctx = [ctx];
          }
          const tmp = ctx;
          ctx = [];
          for (let i = 0; i < tmp.length; ++i) {
            if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {
              ctx.push(tmp[i]);
            }
          }
          const hasContext = ctx.length > 0;
          if (ctx.length === 1) {
            ctx = ctx[0];
          }
          if (_isArray(compacted)) {
            const graphAlias = _compactIri({
              activeCtx,
              iri: "@graph",
              relativeTo: { vocab: true }
            });
            const graph = compacted;
            compacted = {};
            if (hasContext) {
              compacted["@context"] = ctx;
            }
            compacted[graphAlias] = graph;
          } else if (_isObject(compacted) && hasContext) {
            const graph = compacted;
            compacted = { "@context": ctx };
            for (const key in graph) {
              compacted[key] = graph[key];
            }
          }
          if (options.framing) {
            const graph = _compactIri({
              activeCtx,
              iri: "@graph",
              relativeTo: { vocab: true }
            });
            options.link = {};
            compacted[graph] = _removePreserve(activeCtx, compacted[graph], options);
          }
          return compacted;
        };
        jsonld.expand = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not expand, too few arguments.");
          }
          options = _setDefaults(options, {
            keepFreeFloatingNodes: false,
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (options.expansionMap === false) {
            options.expansionMap = void 0;
          }
          const toResolve = {};
          const contextsToProcess = [];
          if ("expandContext" in options) {
            const expandContext = util.clone(options.expandContext);
            if (_isObject(expandContext) && "@context" in expandContext) {
              toResolve.expandContext = expandContext;
            } else {
              toResolve.expandContext = { "@context": expandContext };
            }
            contextsToProcess.push(toResolve.expandContext);
          }
          let defaultBase;
          if (!_isString(input)) {
            toResolve.input = util.clone(input);
          } else {
            const remoteDoc = await jsonld.get(input, options);
            defaultBase = remoteDoc.documentUrl;
            toResolve.input = remoteDoc.document;
            if (remoteDoc.contextUrl) {
              toResolve.remoteContext = { "@context": remoteDoc.contextUrl };
              contextsToProcess.push(toResolve.remoteContext);
            }
          }
          if (!("base" in options)) {
            options.base = defaultBase || "";
          }
          let activeCtx = _getInitialContext(options);
          for (const localCtx of contextsToProcess) {
            activeCtx = await _processContext({ activeCtx, localCtx, options });
          }
          let expanded = await _expand({
            activeCtx,
            element: toResolve.input,
            options,
            expansionMap: options.expansionMap
          });
          if (_isObject(expanded) && "@graph" in expanded && Object.keys(expanded).length === 1) {
            expanded = expanded["@graph"];
          } else if (expanded === null) {
            expanded = [];
          }
          if (!_isArray(expanded)) {
            expanded = [expanded];
          }
          return expanded;
        };
        jsonld.flatten = async function(input, ctx, options) {
          if (arguments.length < 1) {
            return new TypeError("Could not flatten, too few arguments.");
          }
          if (typeof ctx === "function") {
            ctx = null;
          } else {
            ctx = ctx || null;
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          const expanded = await jsonld.expand(input, options);
          const flattened = _flatten(expanded);
          if (ctx === null) {
            return flattened;
          }
          options.graph = true;
          options.skipExpansion = true;
          const compacted = await jsonld.compact(flattened, ctx, options);
          return compacted;
        };
        jsonld.frame = async function(input, frame, options) {
          if (arguments.length < 2) {
            throw new TypeError("Could not frame, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            embed: "@last",
            explicit: false,
            requireAll: true,
            omitDefault: false,
            pruneBlankNodeIdentifiers: true,
            bnodesToClear: [],
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (_isString(frame)) {
            const remoteDoc = await jsonld.get(frame, options);
            frame = remoteDoc.document;
            if (remoteDoc.contextUrl) {
              let ctx = frame["@context"];
              if (!ctx) {
                ctx = remoteDoc.contextUrl;
              } else if (_isArray(ctx)) {
                ctx.push(remoteDoc.contextUrl);
              } else {
                ctx = [ctx, remoteDoc.contextUrl];
              }
              frame["@context"] = ctx;
            }
          }
          const frameContext = frame ? frame["@context"] || {} : {};
          const expanded = await jsonld.expand(input, options);
          const opts = { ...options };
          opts.isFrame = true;
          opts.keepFreeFloatingNodes = true;
          const expandedFrame = await jsonld.expand(frame, opts);
          opts.merged = !("@graph" in frame);
          const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);
          opts.graph = true;
          opts.skipExpansion = true;
          opts.link = {};
          opts.framing = true;
          const compacted = await jsonld.compact(framed, frameContext, opts);
          return compacted;
        };
        jsonld.link = async function(input, ctx, options) {
          const frame = {};
          if (ctx) {
            frame["@context"] = ctx;
          }
          frame["@embed"] = "@link";
          return jsonld.frame(input, frame, options);
        };
        jsonld.normalize = jsonld.canonize = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not canonize, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            algorithm: "URDNA2015",
            skipExpansion: false,
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if ("inputFormat" in options) {
            if (options.inputFormat !== "application/n-quads" && options.inputFormat !== "application/nquads") {
              throw new JsonLdError("Unknown canonicalization input format.", "jsonld.CanonizeError");
            }
            const parsedInput = NQuads.parse(input);
            return canonize.canonize(parsedInput, options);
          }
          const opts = { ...options };
          delete opts.format;
          opts.produceGeneralizedRdf = false;
          const dataset = await jsonld.toRDF(input, opts);
          return canonize.canonize(dataset, options);
        };
        jsonld.fromRDF = async function(dataset, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not convert from RDF, too few arguments.");
          }
          options = _setDefaults(options, {
            format: _isString(dataset) ? "application/n-quads" : void 0
          });
          const { format } = options;
          let { rdfParser } = options;
          if (format) {
            rdfParser = rdfParser || _rdfParsers[format];
            if (!rdfParser) {
              throw new JsonLdError("Unknown input format.", "jsonld.UnknownFormat", { format });
            }
          } else {
            rdfParser = () => dataset;
          }
          const parsedDataset = await rdfParser(dataset);
          return _fromRDF(parsedDataset, options);
        };
        jsonld.toRDF = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not convert to RDF, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            skipExpansion: false,
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          let expanded;
          if (options.skipExpansion) {
            expanded = input;
          } else {
            expanded = await jsonld.expand(input, options);
          }
          const dataset = _toRDF(expanded, options);
          if (options.format) {
            if (options.format === "application/n-quads" || options.format === "application/nquads") {
              return await NQuads.serialize(dataset);
            }
            throw new JsonLdError("Unknown output format.", "jsonld.UnknownFormat", { format: options.format });
          }
          return dataset;
        };
        jsonld.createNodeMap = async function(input, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not create node map, too few arguments.");
          }
          options = _setDefaults(options, {
            base: _isString(input) ? input : "",
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          const expanded = await jsonld.expand(input, options);
          return _createMergedNodeMap(expanded, options);
        };
        jsonld.merge = async function(docs, ctx, options) {
          if (arguments.length < 1) {
            throw new TypeError("Could not merge, too few arguments.");
          }
          if (!_isArray(docs)) {
            throw new TypeError('Could not merge, "docs" must be an array.');
          }
          if (typeof ctx === "function") {
            ctx = null;
          } else {
            ctx = ctx || null;
          }
          options = _setDefaults(options, {
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          const expanded = await Promise.all(docs.map((doc) => {
            const opts = { ...options };
            return jsonld.expand(doc, opts);
          }));
          let mergeNodes = true;
          if ("mergeNodes" in options) {
            mergeNodes = options.mergeNodes;
          }
          const issuer = options.issuer || new IdentifierIssuer("_:b");
          const graphs = { "@default": {} };
          for (let i = 0; i < expanded.length; ++i) {
            const doc = util.relabelBlankNodes(expanded[i], {
              issuer: new IdentifierIssuer("_:b" + i + "-")
            });
            const _graphs = mergeNodes || i === 0 ? graphs : { "@default": {} };
            _createNodeMap(doc, _graphs, "@default", issuer);
            if (_graphs !== graphs) {
              for (const graphName in _graphs) {
                const _nodeMap = _graphs[graphName];
                if (!(graphName in graphs)) {
                  graphs[graphName] = _nodeMap;
                  continue;
                }
                const nodeMap = graphs[graphName];
                for (const key in _nodeMap) {
                  if (!(key in nodeMap)) {
                    nodeMap[key] = _nodeMap[key];
                  }
                }
              }
            }
          }
          const defaultGraph = _mergeNodeMaps(graphs);
          const flattened = [];
          const keys = Object.keys(defaultGraph).sort();
          for (let ki = 0; ki < keys.length; ++ki) {
            const node = defaultGraph[keys[ki]];
            if (!_isSubjectReference(node)) {
              flattened.push(node);
            }
          }
          if (ctx === null) {
            return flattened;
          }
          options.graph = true;
          options.skipExpansion = true;
          const compacted = await jsonld.compact(flattened, ctx, options);
          return compacted;
        };
        Object.defineProperty(jsonld, "documentLoader", {
          get: () => jsonld._documentLoader,
          set: (v) => jsonld._documentLoader = v
        });
        jsonld.documentLoader = async (url) => {
          throw new JsonLdError("Could not retrieve a JSON-LD document from the URL. URL dereferencing not implemented.", "jsonld.LoadDocumentError", { code: "loading document failed", url });
        };
        jsonld.get = async function(url, options) {
          let load;
          if (typeof options.documentLoader === "function") {
            load = options.documentLoader;
          } else {
            load = jsonld.documentLoader;
          }
          const remoteDoc = await load(url);
          try {
            if (!remoteDoc.document) {
              throw new JsonLdError("No remote document found at the given URL.", "jsonld.NullRemoteDocument");
            }
            if (_isString(remoteDoc.document)) {
              remoteDoc.document = JSON.parse(remoteDoc.document);
            }
          } catch (e) {
            throw new JsonLdError("Could not retrieve a JSON-LD document from the URL.", "jsonld.LoadDocumentError", {
              code: "loading document failed",
              cause: e,
              remoteDoc
            });
          }
          return remoteDoc;
        };
        jsonld.processContext = async function(activeCtx, localCtx, options) {
          options = _setDefaults(options, {
            base: "",
            contextResolver: new ContextResolver({ sharedCache: _resolvedContextCache })
          });
          if (localCtx === null) {
            return _getInitialContext(options);
          }
          localCtx = util.clone(localCtx);
          if (!(_isObject(localCtx) && "@context" in localCtx)) {
            localCtx = { "@context": localCtx };
          }
          return _processContext({ activeCtx, localCtx, options });
        };
        jsonld.getContextValue = require_context2().getContextValue;
        jsonld.documentLoaders = {};
        jsonld.documentLoaders.node = require_node();
        jsonld.documentLoaders.xhr = require_xhr2();
        jsonld.useDocumentLoader = function(type) {
          if (!(type in jsonld.documentLoaders)) {
            throw new JsonLdError('Unknown document loader type: "' + type + '"', "jsonld.UnknownDocumentLoader", { type });
          }
          jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));
        };
        jsonld.registerRDFParser = function(contentType, parser) {
          _rdfParsers[contentType] = parser;
        };
        jsonld.unregisterRDFParser = function(contentType) {
          delete _rdfParsers[contentType];
        };
        jsonld.registerRDFParser("application/n-quads", NQuads.parse);
        jsonld.registerRDFParser("application/nquads", NQuads.parse);
        jsonld.registerRDFParser("rdfa-api", Rdfa.parse);
        jsonld.url = require_url2();
        jsonld.util = util;
        Object.assign(jsonld, util);
        jsonld.promises = jsonld;
        jsonld.RequestQueue = require_RequestQueue2();
        jsonld.JsonLdProcessor = require_JsonLdProcessor2()(jsonld);
        if (_browser && typeof global.JsonLdProcessor === "undefined") {
          Object.defineProperty(global, "JsonLdProcessor", {
            writable: true,
            enumerable: false,
            configurable: true,
            value: jsonld.JsonLdProcessor
          });
        }
        if (_nodejs) {
          jsonld.useDocumentLoader("node");
        } else if (typeof XMLHttpRequest !== "undefined") {
          jsonld.useDocumentLoader("xhr");
        }
        function _setDefaults(options, {
          documentLoader = jsonld.documentLoader,
          ...defaults
        }) {
          return Object.assign({}, { documentLoader }, defaults, options);
        }
        return jsonld;
      };
      var factory = function() {
        return wrapper(function() {
          return factory();
        });
      };
      wrapper(factory);
      module.exports = factory;
    }
  });

  // certificate-signer-library/credentials.json
  var require_credentials = __commonJS({
    "certificate-signer-library/credentials.json"(exports, module) {
      module.exports = {
        "@context": {
          "@version": 1.1,
          "@protected": true,
          id: "@id",
          type: "@type",
          VerifiableCredential: {
            "@id": "https://www.w3.org/2018/credentials#VerifiableCredential",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              id: "@id",
              type: "@type",
              cred: "https://www.w3.org/2018/credentials#",
              sec: "https://w3id.org/security#",
              xsd: "http://www.w3.org/2001/XMLSchema#",
              credentialSchema: {
                "@id": "cred:credentialSchema",
                "@type": "@id",
                "@context": {
                  "@version": 1.1,
                  "@protected": true,
                  id: "@id",
                  type: "@type",
                  cred: "https://www.w3.org/2018/credentials#",
                  JsonSchemaValidator2018: "cred:JsonSchemaValidator2018"
                }
              },
              credentialStatus: { "@id": "cred:credentialStatus", "@type": "@id" },
              credentialSubject: { "@id": "cred:credentialSubject", "@type": "@id" },
              evidence: { "@id": "cred:evidence", "@type": "@id" },
              expirationDate: { "@id": "cred:expirationDate", "@type": "xsd:dateTime" },
              holder: { "@id": "cred:holder", "@type": "@id" },
              issued: { "@id": "cred:issued", "@type": "xsd:dateTime" },
              issuer: { "@id": "cred:issuer", "@type": "@id" },
              issuanceDate: { "@id": "cred:issuanceDate", "@type": "xsd:dateTime" },
              proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
              refreshService: {
                "@id": "cred:refreshService",
                "@type": "@id",
                "@context": {
                  "@version": 1.1,
                  "@protected": true,
                  id: "@id",
                  type: "@type",
                  cred: "https://www.w3.org/2018/credentials#",
                  ManualRefreshService2018: "cred:ManualRefreshService2018"
                }
              },
              termsOfUse: { "@id": "cred:termsOfUse", "@type": "@id" },
              validFrom: { "@id": "cred:validFrom", "@type": "xsd:dateTime" },
              validUntil: { "@id": "cred:validUntil", "@type": "xsd:dateTime" }
            }
          },
          VerifiablePresentation: {
            "@id": "https://www.w3.org/2018/credentials#VerifiablePresentation",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              id: "@id",
              type: "@type",
              cred: "https://www.w3.org/2018/credentials#",
              sec: "https://w3id.org/security#",
              holder: { "@id": "cred:holder", "@type": "@id" },
              proof: { "@id": "sec:proof", "@type": "@id", "@container": "@graph" },
              verifiableCredential: { "@id": "cred:verifiableCredential", "@type": "@id", "@container": "@graph" }
            }
          },
          EcdsaSecp256k1Signature2019: {
            "@id": "https://w3id.org/security#EcdsaSecp256k1Signature2019",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              id: "@id",
              type: "@type",
              sec: "https://w3id.org/security#",
              xsd: "http://www.w3.org/2001/XMLSchema#",
              challenge: "sec:challenge",
              created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" },
              domain: "sec:domain",
              expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
              jws: "sec:jws",
              nonce: "sec:nonce",
              proofPurpose: {
                "@id": "sec:proofPurpose",
                "@type": "@vocab",
                "@context": {
                  "@version": 1.1,
                  "@protected": true,
                  id: "@id",
                  type: "@type",
                  sec: "https://w3id.org/security#",
                  assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" },
                  authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" }
                }
              },
              proofValue: "sec:proofValue",
              verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" }
            }
          },
          EcdsaSecp256r1Signature2019: {
            "@id": "https://w3id.org/security#EcdsaSecp256r1Signature2019",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              id: "@id",
              type: "@type",
              sec: "https://w3id.org/security#",
              xsd: "http://www.w3.org/2001/XMLSchema#",
              challenge: "sec:challenge",
              created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" },
              domain: "sec:domain",
              expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
              jws: "sec:jws",
              nonce: "sec:nonce",
              proofPurpose: {
                "@id": "sec:proofPurpose",
                "@type": "@vocab",
                "@context": {
                  "@version": 1.1,
                  "@protected": true,
                  id: "@id",
                  type: "@type",
                  sec: "https://w3id.org/security#",
                  assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" },
                  authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" }
                }
              },
              proofValue: "sec:proofValue",
              verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" }
            }
          },
          Ed25519Signature2018: {
            "@id": "https://w3id.org/security#Ed25519Signature2018",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              id: "@id",
              type: "@type",
              sec: "https://w3id.org/security#",
              xsd: "http://www.w3.org/2001/XMLSchema#",
              challenge: "sec:challenge",
              created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" },
              domain: "sec:domain",
              expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
              jws: "sec:jws",
              nonce: "sec:nonce",
              proofPurpose: {
                "@id": "sec:proofPurpose",
                "@type": "@vocab",
                "@context": {
                  "@version": 1.1,
                  "@protected": true,
                  id: "@id",
                  type: "@type",
                  sec: "https://w3id.org/security#",
                  assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" },
                  authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" }
                }
              },
              proofValue: "sec:proofValue",
              verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" }
            }
          },
          RsaSignature2018: {
            "@id": "https://w3id.org/security#RsaSignature2018",
            "@context": {
              "@version": 1.1,
              "@protected": true,
              challenge: "sec:challenge",
              created: { "@id": "http://purl.org/dc/terms/created", "@type": "xsd:dateTime" },
              domain: "sec:domain",
              expires: { "@id": "sec:expiration", "@type": "xsd:dateTime" },
              jws: "sec:jws",
              nonce: "sec:nonce",
              proofPurpose: {
                "@id": "sec:proofPurpose",
                "@type": "@vocab",
                "@context": {
                  "@version": 1.1,
                  "@protected": true,
                  id: "@id",
                  type: "@type",
                  sec: "https://w3id.org/security#",
                  assertionMethod: { "@id": "sec:assertionMethod", "@type": "@id", "@container": "@set" },
                  authentication: { "@id": "sec:authenticationMethod", "@type": "@id", "@container": "@set" }
                }
              },
              proofValue: "sec:proofValue",
              verificationMethod: { "@id": "sec:verificationMethod", "@type": "@id" }
            }
          },
          proof: { "@id": "https://w3id.org/security#proof", "@type": "@id", "@container": "@graph" }
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/constants.js
  var require_constants5 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/constants.js"(exports, module) {
      "use strict";
      var { constants: securityConstants } = require_js();
      module.exports = {
        SECURITY_CONTEXT_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
        SECURITY_CONTEXT_V1_URL: securityConstants.SECURITY_CONTEXT_V1_URL,
        SECURITY_CONTEXT_V2_URL: securityConstants.SECURITY_CONTEXT_V2_URL,
        SECURITY_PROOF_URL: "https://w3id.org/security#proof",
        SECURITY_SIGNATURE_URL: "https://w3id.org/security#signature"
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/contexts.js
  var require_contexts2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/contexts.js"(exports, module) {
      "use strict";
      var constants = require_constants5();
      var { contexts: securityContexts } = require_js();
      module.exports = {
        [constants.SECURITY_CONTEXT_V1_URL]: securityContexts.get(constants.SECURITY_CONTEXT_V1_URL),
        [constants.SECURITY_CONTEXT_V2_URL]: securityContexts.get(constants.SECURITY_CONTEXT_V2_URL)
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/documentLoader.js
  var require_documentLoader2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/documentLoader.js"(exports, module) {
      "use strict";
      var contexts = require_contexts2();
      var api = {};
      module.exports = api;
      api.extendContextLoader = (documentLoader) => {
        return async (url) => {
          const context = contexts[url];
          if (context !== void 0) {
            return {
              contextUrl: null,
              documentUrl: url,
              document: context
            };
          }
          return documentLoader(url);
        };
      };
      api.strictDocumentLoader = api.extendContextLoader((url) => {
        throw new Error(`${url} not found.`);
      });
    }
  });

  // node_modules/vc-js/node_modules/serialize-error/index.js
  var require_serialize_error2 = __commonJS({
    "node_modules/vc-js/node_modules/serialize-error/index.js"(exports, module) {
      "use strict";
      var { inspect } = require_util6();
      var NonError = class extends Error {
        constructor(message) {
          super(inspect(message));
          this.name = "NonError";
          Error.captureStackTrace(this, NonError);
        }
      };
      var commonProperties = [
        "name",
        "message",
        "stack",
        "code"
      ];
      var destroyCircular = (from, seen, to_) => {
        const to = to_ || (Array.isArray(from) ? [] : {});
        seen.push(from);
        for (const [key, value] of Object.entries(from)) {
          if (typeof value === "function") {
            continue;
          }
          if (!value || typeof value !== "object") {
            to[key] = value;
            continue;
          }
          if (!seen.includes(from[key])) {
            to[key] = destroyCircular(from[key], seen.slice());
            continue;
          }
          to[key] = "[Circular]";
        }
        for (const property of commonProperties) {
          if (typeof from[property] === "string") {
            to[property] = from[property];
          }
        }
        return to;
      };
      var serializeError = (value) => {
        if (typeof value === "object" && value !== null) {
          return destroyCircular(value, []);
        }
        if (typeof value === "function") {
          return `[Function: ${value.name || "anonymous"}]`;
        }
        return value;
      };
      var deserializeError = (value) => {
        if (value instanceof Error) {
          return value;
        }
        if (typeof value === "object" && value !== null && !Array.isArray(value)) {
          const newError = new Error();
          destroyCircular(value, [], newError);
          return newError;
        }
        return new NonError(value);
      };
      module.exports = {
        serializeError,
        deserializeError
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/expansionMap.js
  var require_expansionMap2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/expansionMap.js"(exports, module) {
      "use strict";
      module.exports = (info) => {
        if (info.unmappedProperty) {
          throw new Error('The property "' + info.unmappedProperty + '" in the input was not defined in the context.');
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js
  var require_ProofPurpose2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/ProofPurpose.js"(exports, module) {
      "use strict";
      module.exports = class ProofPurpose {
        constructor({ term, date, maxTimestampDelta = Infinity } = {}) {
          if (term === void 0) {
            throw new Error('"term" is required.');
          }
          if (maxTimestampDelta !== void 0 && typeof maxTimestampDelta !== "number") {
            throw new TypeError('"maxTimestampDelta" must be a number.');
          }
          this.term = term;
          if (date !== void 0) {
            this.date = new Date(date);
            if (isNaN(this.date)) {
              throw TypeError(`"date" "${date}" is not a valid date.`);
            }
          }
          this.maxTimestampDelta = maxTimestampDelta;
        }
        async validate(proof, {
          document: document2,
          suite,
          verificationMethod,
          documentLoader,
          expansionMap
        }) {
          try {
            if (this.maxTimestampDelta !== Infinity) {
              const expected = (this.date || new Date()).getTime();
              const delta = this.maxTimestampDelta * 1e3;
              const created = new Date(proof.created).getTime();
              if (!(created >= expected - delta && created <= expected + delta)) {
                throw new Error("The proof's created timestamp is out of range.");
              }
            }
            return { valid: true };
          } catch (error) {
            return { valid: false, error };
          }
        }
        async update(proof, { document: document2, suite, documentLoader, expansionMap }) {
          proof.proofPurpose = this.term;
          return proof;
        }
        async match(proof, { document: document2, documentLoader, expansionMap }) {
          return proof.proofPurpose === this.term;
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js
  var require_ControllerProofPurpose2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/ControllerProofPurpose.js"(exports, module) {
      "use strict";
      var constants = require_constants5();
      var jsonld = require_jsonld2();
      var ProofPurpose = require_ProofPurpose2();
      module.exports = class ControllerProofPurpose extends ProofPurpose {
        constructor({ term, controller, date, maxTimestampDelta = Infinity } = {}) {
          super({ term, date, maxTimestampDelta });
          if (controller !== void 0) {
            if (typeof controller !== "object") {
              throw new TypeError('"controller" must be an object.');
            }
            this.controller = controller;
          }
        }
        async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
          try {
            const result = await super.validate(proof, { verificationMethod, documentLoader, expansionMap });
            if (!result.valid) {
              throw result.error;
            }
            const { id: verificationId } = verificationMethod;
            if (this.controller) {
              result.controller = this.controller;
            } else {
              const { controller, owner } = verificationMethod;
              let controllerId;
              if (controller) {
                if (typeof controller === "object") {
                  controllerId = controller.id;
                } else if (typeof controller !== "string") {
                  throw new TypeError('"controller" must be a string representing a URL.');
                } else {
                  controllerId = controller;
                }
              } else if (owner) {
                if (typeof owner === "object") {
                  controllerId = owner.id;
                } else if (typeof owner !== "string") {
                  throw new TypeError('"owner" must be a string representing a URL.');
                } else {
                  controllerId = owner;
                }
              }
              const { "@graph": [framed = {}] } = await jsonld.frame(controllerId, {
                "@context": constants.SECURITY_CONTEXT_URL,
                id: controllerId,
                [this.term]: {
                  "@embed": "@never",
                  id: verificationId
                }
              }, { documentLoader, compactToRelative: false });
              result.controller = framed;
            }
            const verificationMethods = jsonld.getValues(result.controller, this.term);
            result.valid = verificationMethods.some((vm) => vm === verificationId || typeof vm === "object" && vm.id === verificationId);
            if (!result.valid) {
              throw new Error(`Verification method "${verificationMethod.id}" not authorized by controller for proof purpose "${this.term}".`);
            }
            return result;
          } catch (error) {
            return { valid: false, error };
          }
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/PublicKeyProofPurpose.js
  var require_PublicKeyProofPurpose = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/PublicKeyProofPurpose.js"(exports, module) {
      "use strict";
      var ControllerProofPurpose = require_ControllerProofPurpose2();
      module.exports = class PublicKeyProofPurpose extends ControllerProofPurpose {
        constructor({ controller, date, maxTimestampDelta = Infinity } = {}) {
          super({ term: "publicKey", controller, date, maxTimestampDelta });
        }
        async update(proof) {
          return proof;
        }
        async match(proof) {
          return proof.proofPurpose === void 0;
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/ProofSet.js
  var require_ProofSet2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/ProofSet.js"(exports, module) {
      "use strict";
      var constants = require_constants5();
      var jsonld = require_jsonld2();
      var { extendContextLoader, strictDocumentLoader } = require_documentLoader2();
      var { serializeError } = require_serialize_error2();
      var strictExpansionMap = require_expansionMap2();
      var PublicKeyProofPurpose = require_PublicKeyProofPurpose();
      module.exports = class ProofSet {
        async add(document2, {
          suite,
          purpose,
          documentLoader,
          expansionMap,
          compactProof = true
        } = {}) {
          if (!suite) {
            throw new TypeError('"options.suite" is required.');
          }
          if (!purpose) {
            throw new TypeError('"options.purpose" is required.');
          }
          if (suite.legacy) {
            if (!(purpose instanceof PublicKeyProofPurpose)) {
              throw new TypeError(`The "${suite.type}" suite requires "options.purpose" to be an instance of "PublicKeyProofPurpose".`);
            }
          }
          if (documentLoader) {
            documentLoader = extendContextLoader(documentLoader);
          } else {
            documentLoader = strictDocumentLoader;
          }
          if (expansionMap !== false) {
            expansionMap = strictExpansionMap;
          }
          if (typeof document2 === "string") {
            document2 = await documentLoader(document2);
          }
          let input;
          if (compactProof) {
            input = await jsonld.compact(document2, constants.SECURITY_CONTEXT_URL, { documentLoader, expansionMap, compactToRelative: false });
          } else {
            input = { ...document2 };
          }
          const proofProperty = suite.legacy ? "signature" : "proof";
          delete input[proofProperty];
          const proof = await suite.createProof({
            document: input,
            purpose,
            documentLoader,
            expansionMap,
            compactProof
          });
          if (compactProof) {
            let expandedProof;
            if (suite.legacy) {
              expandedProof = {
                [constants.SECURITY_SIGNATURE_URL]: proof
              };
            } else {
              expandedProof = {
                [constants.SECURITY_PROOF_URL]: { "@graph": proof }
              };
            }
            const { types, alias } = await _getTypeInfo({ document: document2, documentLoader, expansionMap });
            expandedProof["@type"] = types;
            const ctx = jsonld.getValues(document2, "@context");
            const compactProof2 = await jsonld.compact(expandedProof, ctx, { documentLoader, expansionMap, compactToRelative: false });
            delete compactProof2[alias];
            delete compactProof2["@context"];
            const key = Object.keys(compactProof2)[0];
            jsonld.addValue(document2, key, compactProof2[key]);
          } else {
            delete proof["@context"];
            jsonld.addValue(document2, proofProperty, proof);
          }
          return document2;
        }
        async verify(document2, {
          suite,
          purpose,
          documentLoader,
          expansionMap,
          compactProof = true
        } = {}) {
          if (!suite) {
            throw new TypeError('"options.suite" is required.');
          }
          if (!purpose) {
            throw new TypeError('"options.purpose" is required.');
          }
          const suites = Array.isArray(suite) ? suite : [suite];
          if (suites.length === 0) {
            throw new TypeError("At least one suite is required.");
          }
          const legacy = suites.some((s) => s.legacy);
          if (legacy) {
            if (suites.some((s) => !s.legacy)) {
              throw new Error("Legacy suites may not be combined with current suites.");
            } else if (!(purpose instanceof PublicKeyProofPurpose)) {
              throw new TypeError('"options.purpose" must be an instance of "PublicKeyProofPurpose"to use a legacy suite.');
            }
          }
          if (documentLoader) {
            documentLoader = extendContextLoader(documentLoader);
          } else {
            documentLoader = strictDocumentLoader;
          }
          if (expansionMap !== false) {
            expansionMap = strictExpansionMap;
          }
          try {
            if (typeof document2 === "string") {
              document2 = await documentLoader(document2);
            } else {
              document2 = { ...document2 };
            }
            const { proofSet, document: doc } = await _getProofs({
              document: document2,
              legacy,
              documentLoader,
              expansionMap,
              compactProof
            });
            document2 = doc;
            const results = await _verify({
              document: document2,
              suites,
              proofSet,
              purpose,
              documentLoader,
              expansionMap,
              compactProof
            });
            if (results.length === 0) {
              throw new Error("Could not verify any proofs; no proofs matched the required suite and purpose.");
            }
            const verified = results.some((r) => r.verified);
            if (!verified) {
              const errors = [].concat(...results.filter((r) => r.error).map((r) => r.error));
              const result = { verified, results };
              if (errors.length > 0) {
                result.error = errors;
              }
              return result;
            }
            return { verified, results };
          } catch (error) {
            _addToJSON(error);
            return { verified: false, error };
          }
        }
      };
      async function _getProofs({
        document: document2,
        legacy,
        documentLoader,
        expansionMap,
        compactProof
      }) {
        const proofProperty = legacy ? "signature" : "proof";
        let proofSet;
        if (compactProof) {
          document2 = await jsonld.compact(document2, constants.SECURITY_CONTEXT_URL, { documentLoader, expansionMap, compactToRelative: false });
        }
        proofSet = jsonld.getValues(document2, proofProperty);
        delete document2[proofProperty];
        if (proofSet.length === 0) {
          throw new Error("No matching proofs found in the given document.");
        }
        proofSet = proofSet.map((proof) => ({
          "@context": constants.SECURITY_CONTEXT_URL,
          ...proof
        }));
        return { proofSet, document: document2 };
      }
      async function _verify({
        document: document2,
        suites,
        proofSet,
        purpose,
        documentLoader,
        expansionMap,
        compactProof
      }) {
        const result = await Promise.all(proofSet.map((proof) => purpose.match(proof, { document: document2, documentLoader, expansionMap })));
        const matches = proofSet.filter((value, index) => result[index]);
        if (matches.length === 0) {
          return [];
        }
        return (await Promise.all(matches.map(async (proof) => {
          for (const s of suites) {
            if (await s.matchProof({ proof, document: document2, documentLoader, expansionMap })) {
              return s.verifyProof({
                proof,
                document: document2,
                purpose,
                documentLoader,
                expansionMap,
                compactProof
              }).catch((error) => ({ verified: false, error }));
            }
          }
        }))).map((r, i) => {
          if (!r) {
            return null;
          }
          if (r.error) {
            _addToJSON(r.error);
          }
          return { proof: matches[i], ...r };
        }).filter((r) => r);
      }
      function _addToJSON(error) {
        Object.defineProperty(error, "toJSON", {
          value: function() {
            return serializeError(this);
          },
          configurable: true,
          writable: true
        });
      }
      async function _getTypeInfo({ document: document2, documentLoader, expansionMap }) {
        const ctx = jsonld.getValues(document2, "@context");
        const compacted = await jsonld.compact({ "@type": "_:b0" }, ctx, { documentLoader, expansionMap });
        delete compacted["@context"];
        const alias = Object.keys(compacted)[0];
        const toExpand = { "@context": ctx };
        toExpand["@type"] = jsonld.getValues(document2, "@type").concat(jsonld.getValues(document2, alias));
        const expanded = (await jsonld.expand(toExpand, { documentLoader, expansionMap }))[0] || {};
        return { types: jsonld.getValues(expanded, "@type"), alias };
      }
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/VerificationError.js
  var require_VerificationError2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/VerificationError.js"(exports, module) {
      "use strict";
      var VerificationError = class extends Error {
        constructor(errors) {
          super("Verification error(s).");
          this.name = "VerificationError";
          this.errors = [].concat(errors);
        }
      };
      module.exports = VerificationError;
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/env.js
  var require_env2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/env.js"(exports, module) {
      "use strict";
      var nodejs = typeof process !== "undefined" && process.versions && process.versions.node;
      var browser = !nodejs && (typeof window !== "undefined" || typeof self !== "undefined");
      module.exports = {
        nodejs,
        browser
      };
    }
  });

  // (disabled):node_modules/base64url/index.js
  var require_base64url2 = __commonJS({
    "(disabled):node_modules/base64url/index.js"() {
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/util.js
  var require_util9 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/util.js"(exports, module) {
      "use strict";
      var env = require_env2();
      var forge = require_lib2();
      var api = {};
      module.exports = api;
      api.createJws = createJwsFactory();
      api.w3cDate = (date) => {
        if (date === void 0 || date === null) {
          date = new Date();
        } else if (typeof date === "number" || typeof date === "string") {
          date = new Date(date);
        }
        const str = date.toISOString();
        return str.substr(0, str.length - 5) + "Z";
      };
      api.encodeBase64Url = base64urlEncodeFactory();
      api.decodeBase64Url = base64urlDecodeFactory();
      api.decodeBase64UrlToString = base64urlDecodeToStringFactory();
      api.sha256 = sha256Factory();
      api.concat = concatFactory();
      api.stringToBytes = stringToBytesFactory();
      function stringToBytesFactory() {
        if (env.nodejs) {
          return (string, encoding) => {
            const buffer = Buffer.from(string, encoding);
            return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
          };
        }
        return (string, encoding) => {
          const buffer = new forge.util.ByteBuffer(string, encoding);
          return forge.util.binary.raw.decode(buffer.getBytes());
        };
      }
      function concatFactory() {
        if (env.nodejs) {
          return (b1, b2) => {
            const buffer = Buffer.concat([
              Buffer.from(b1.buffer, b1.byteOffset, b1.length),
              Buffer.from(b2.buffer, b2.byteOffset, b2.length)
            ]);
            return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
          };
        }
        return (b1, b2) => {
          const rval = new Uint8Array(b1.length + b2.length);
          rval.set(b1, 0);
          rval.set(b2, b1.length);
          return rval;
        };
      }
      function sha256Factory() {
        if (env.nodejs) {
          const crypto = require_crypto();
          return (string, encoding) => {
            const hash = crypto.createHash("sha256");
            hash.update(string, encoding);
            const buffer = hash.digest();
            return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
          };
        }
        return (string, encoding) => {
          const md = forge.md.sha256.create();
          md.update(string, encoding || "utf8");
          const buffer = md.digest();
          return forge.util.binary.raw.decode(buffer.getBytes());
        };
      }
      function createJwsFactory() {
        if (env.nodejs) {
          return ({ encodedHeader, verifyData }) => {
            const buffer = Buffer.concat([
              Buffer.from(encodedHeader + ".", "utf8"),
              Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length)
            ]);
            return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.length);
          };
        }
        return ({ encodedHeader, verifyData }) => {
          const buffer = new forge.util.ByteBuffer(encodedHeader + ".", "utf8");
          const binaryString = forge.util.binary.raw.encode(verifyData);
          buffer.putBytes(binaryString);
          return forge.util.binary.raw.decode(buffer.getBytes());
        };
      }
      function base64urlEncodeFactory() {
        if (env.nodejs) {
          const base64url = require_base64url2();
          return (data) => {
            if (typeof data === "string") {
              return base64url(data);
            }
            return base64url(Buffer.from(data.buffer, data.byteOffset, data.length));
          };
        }
        return (data) => {
          let binaryString;
          if (typeof data === "string") {
            binaryString = forge.util.encodeUtf8(data);
          } else {
            binaryString = forge.util.binary.raw.encode(data);
          }
          const enc = forge.util.encode64(binaryString);
          return enc.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
        };
      }
      function base64urlDecodeFactory() {
        if (env.nodejs) {
          const base64url = require_base64url2();
          return (string) => {
            const buffer = base64url.toBuffer(string);
            return new Uint8Array(buffer.buffer, buffer.offset, buffer.length);
          };
        }
        return (string) => {
          let base64 = string.replace(/-/g, "+").replace(/_/g, "/");
          const mod4 = base64.length % 4;
          if (mod4 === 0) {
          } else if (mod4 === 2) {
            base64 = base64 + "==";
          } else if (mod4 === 3) {
            base64 = base64 + "=";
          } else {
            throw new Error("Illegal base64 string.");
          }
          return forge.util.binary.base64.decode(base64);
        };
      }
      function base64urlDecodeToStringFactory() {
        if (env.nodejs) {
          const base64url = require_base64url2();
          return (string) => base64url.decode(string);
        }
        return (string) => {
          let base64 = string.replace(/-/g, "+").replace(/_/g, "/");
          const mod4 = base64.length % 4;
          if (mod4 === 0) {
          } else if (mod4 === 2) {
            base64 = base64 + "==";
          } else if (mod4 === 3) {
            base64 = base64 + "=";
          } else {
            throw new Error("Illegal base64 string.");
          }
          const binaryString = forge.util.decode64(base64);
          return forge.util.decodeUtf8(binaryString);
        };
      }
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js
  var require_LinkedDataProof2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/LinkedDataProof.js"(exports, module) {
      "use strict";
      module.exports = class LinkedDataProof {
        constructor({ type } = {}) {
          if (typeof type !== "string") {
            throw new TypeError('A LinkedDataProof must have a "type".');
          }
          this.type = type;
        }
        async createProof({ document: document2, purpose, documentLoader, expansionMap, compactProof }) {
          throw new Error('"createProof" must be implemented in a derived class.');
        }
        async verifyProof({ proof, document: document2, purpose, documentLoader, expansionMap }) {
          throw new Error('"verifyProof" must be implemented in a derived class.');
        }
        async matchProof({ proof, document: document2, purpose, documentLoader, expansionMap }) {
          return proof.type === this.type;
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js
  var require_LinkedDataSignature2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature.js"(exports, module) {
      "use strict";
      var constants = require_constants5();
      var jsonld = require_jsonld2();
      var util = require_util9();
      var LinkedDataProof = require_LinkedDataProof2();
      module.exports = class LinkedDataSignature extends LinkedDataProof {
        constructor({
          type,
          creator,
          verificationMethod,
          proof,
          date,
          useNativeCanonize
        } = {}) {
          if (verificationMethod !== void 0 && typeof verificationMethod !== "string") {
            throw new TypeError('"verificationMethod" must be a URL string.');
          }
          super({ type });
          this.creator = creator;
          this.verificationMethod = verificationMethod;
          this.proof = proof;
          if (date !== void 0) {
            this.date = new Date(date);
            if (isNaN(this.date)) {
              throw TypeError(`"date" "${date}" is not a valid date.`);
            }
          }
          this.useNativeCanonize = useNativeCanonize;
        }
        async createProof({ document: document2, purpose, documentLoader, expansionMap, compactProof }) {
          let proof;
          if (this.proof) {
            proof = await jsonld.compact(this.proof, constants.SECURITY_CONTEXT_URL, { documentLoader, expansionMap, compactToRelative: false });
          } else {
            proof = { "@context": constants.SECURITY_CONTEXT_URL };
          }
          proof.type = this.type;
          let date = this.date;
          if (proof.created === void 0 && date === void 0) {
            date = new Date();
          }
          if (date !== void 0 && typeof date !== "string") {
            date = util.w3cDate(date);
          }
          if (date !== void 0) {
            proof.created = date;
          }
          if (this.verificationMethod !== void 0) {
            proof.verificationMethod = this.verificationMethod;
          }
          if (this.creator !== void 0) {
            proof.creator = this.creator;
          }
          proof = await this.updateProof({
            document: document2,
            proof,
            purpose,
            documentLoader,
            expansionMap,
            compactProof
          });
          proof = await purpose.update(proof, { document: document2, suite: this, documentLoader, expansionMap });
          const verifyData = await this.createVerifyData({ document: document2, proof, documentLoader, expansionMap, compactProof });
          proof = await this.sign({ verifyData, document: document2, proof, documentLoader, expansionMap });
          return proof;
        }
        async updateProof({ proof }) {
          return proof;
        }
        async verifyProof({
          proof,
          document: document2,
          purpose,
          documentLoader,
          expansionMap,
          compactProof
        }) {
          try {
            const verifyData = await this.createVerifyData({ document: document2, proof, documentLoader, expansionMap, compactProof });
            const verificationMethod = await this.getVerificationMethod({ proof, document: document2, documentLoader, expansionMap });
            const verified = await this.verifySignature({
              verifyData,
              verificationMethod,
              document: document2,
              proof,
              documentLoader,
              expansionMap
            });
            if (!verified) {
              throw new Error("Invalid signature.");
            }
            const purposeResult = await purpose.validate(proof, {
              document: document2,
              suite: this,
              verificationMethod,
              documentLoader,
              expansionMap
            });
            if (!purposeResult.valid) {
              throw purposeResult.error;
            }
            return { verified: true, purposeResult };
          } catch (error) {
            return { verified: false, error };
          }
        }
        async canonize(input, { documentLoader, expansionMap, skipExpansion }) {
          return jsonld.canonize(input, {
            algorithm: "URDNA2015",
            format: "application/n-quads",
            documentLoader,
            expansionMap,
            skipExpansion,
            useNative: this.useNativeCanonize
          });
        }
        async canonizeProof(proof, { documentLoader, expansionMap }) {
          proof = { ...proof };
          delete proof.jws;
          delete proof.signatureValue;
          delete proof.proofValue;
          return this.canonize(proof, {
            documentLoader,
            expansionMap,
            skipExpansion: false
          });
        }
        async createVerifyData({
          document: document2,
          proof,
          documentLoader,
          expansionMap
        }) {
          const c14nProofOptions = await this.canonizeProof(proof, { documentLoader, expansionMap });
          const c14nDocument = await this.canonize(document2, {
            documentLoader,
            expansionMap
          });
          return util.concat(util.sha256(c14nProofOptions), util.sha256(c14nDocument));
        }
        async getVerificationMethod({ proof, documentLoader }) {
          let { verificationMethod } = proof;
          if (!verificationMethod) {
            const { creator } = proof;
            verificationMethod = creator;
          }
          if (typeof verificationMethod === "object") {
            verificationMethod = verificationMethod.id;
          }
          if (!verificationMethod) {
            throw new Error('No "verificationMethod" or "creator" found in proof.');
          }
          const { "@graph": [framed] } = await jsonld.frame(verificationMethod, {
            "@context": constants.SECURITY_CONTEXT_URL,
            "@embed": "@always",
            id: verificationMethod
          }, { documentLoader, compactToRelative: false });
          if (!framed) {
            throw new Error(`Verification method ${verificationMethod} not found.`);
          }
          if (framed.revoked !== void 0) {
            throw new Error("The verification method has been revoked.");
          }
          return framed;
        }
        async sign() {
          throw new Error("Must be implemented by a derived class.");
        }
        async verifySignature() {
          throw new Error("Must be implemented by a derived class.");
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/JwsLinkedDataSignature.js
  var require_JwsLinkedDataSignature = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/JwsLinkedDataSignature.js"(exports, module) {
      "use strict";
      var LinkedDataSignature = require_LinkedDataSignature2();
      var jsonld = require_jsonld2();
      var util = require_util9();
      module.exports = class JwsLinkedDataSignature extends LinkedDataSignature {
        constructor({
          type,
          alg,
          LDKeyClass,
          creator,
          verificationMethod,
          signer,
          key,
          proof,
          date,
          useNativeCanonize
        } = {}) {
          super({ type, creator, verificationMethod, proof, date, useNativeCanonize });
          this.alg = alg;
          this.LDKeyClass = LDKeyClass;
          this.signer = signer;
          if (key) {
            if (verificationMethod === void 0 && creator === void 0) {
              const publicKey = key.publicNode();
              if (publicKey.owner) {
                this.creator = publicKey.id;
              } else {
                this.verificationMethod = publicKey.id;
              }
            }
            this.key = key;
            if (typeof key.signer === "function") {
              this.signer = key.signer();
            }
            if (typeof key.verifier === "function") {
              this.verifier = key.verifier();
            }
          }
        }
        async sign({ verifyData, proof }) {
          if (!(this.signer && typeof this.signer.sign === "function")) {
            throw new Error("A signer API has not been specified.");
          }
          const header = {
            alg: this.alg,
            b64: false,
            crit: ["b64"]
          };
          const encodedHeader = util.encodeBase64Url(JSON.stringify(header));
          const data = util.createJws({ encodedHeader, verifyData });
          const signature = await this.signer.sign({ data });
          const encodedSignature = util.encodeBase64Url(signature);
          proof.jws = encodedHeader + ".." + encodedSignature;
          return proof;
        }
        async verifySignature({ verifyData, verificationMethod, proof }) {
          if (!(proof.jws && typeof proof.jws === "string" && proof.jws.includes("."))) {
            throw new TypeError('The proof does not include a valid "jws" property.');
          }
          const [encodedHeader, , encodedSignature] = proof.jws.split(".");
          let header;
          try {
            header = JSON.parse(util.decodeBase64UrlToString(encodedHeader));
          } catch (e) {
            throw new Error("Could not parse JWS header; " + e);
          }
          if (!(header && typeof header === "object")) {
            throw new Error("Invalid JWS header.");
          }
          if (!(header.alg === this.alg && header.b64 === false && Array.isArray(header.crit) && header.crit.length === 1 && header.crit[0] === "b64") && Object.keys(header).length === 3) {
            throw new Error(`Invalid JWS header parameters for ${this.type}.`);
          }
          const signature = util.decodeBase64Url(encodedSignature);
          const data = util.createJws({ encodedHeader, verifyData });
          let { verifier } = this;
          if (!verifier) {
            const key = await this.LDKeyClass.from(verificationMethod);
            verifier = key.verifier();
          }
          return verifier.verify({ data, signature });
        }
        async assertVerificationMethod({ verificationMethod }) {
          if (!jsonld.hasValue(verificationMethod, "type", this.requiredKeyType)) {
            throw new Error(`Invalid key type. Key type must be "${this.requiredKeyType}".`);
          }
        }
        async getVerificationMethod({ proof, documentLoader }) {
          if (this.key) {
            return this.key.publicNode();
          }
          const verificationMethod = await super.getVerificationMethod({ proof, documentLoader });
          await this.assertVerificationMethod({ verificationMethod });
          return verificationMethod;
        }
        async matchProof({ proof, document: document2, purpose, documentLoader, expansionMap }) {
          if (!await super.matchProof({ proof, document: document2, purpose, documentLoader, expansionMap })) {
            return false;
          }
          if (!this.key) {
            return true;
          }
          let { verificationMethod } = proof;
          if (!verificationMethod) {
            verificationMethod = proof.creator;
          }
          if (typeof verificationMethod === "object") {
            return verificationMethod.id === this.key.id;
          }
          return verificationMethod === this.key.id;
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/Ed25519Signature2018.js
  var require_Ed25519Signature2018 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/Ed25519Signature2018.js"(exports, module) {
      "use strict";
      var { Ed25519KeyPair } = require_lib3();
      var JwsLinkedDataSignature = require_JwsLinkedDataSignature();
      module.exports = class Ed25519Signature2018 extends JwsLinkedDataSignature {
        constructor({
          signer,
          key,
          creator,
          verificationMethod,
          proof,
          date,
          useNativeCanonize
        } = {}) {
          super({
            type: "Ed25519Signature2018",
            alg: "EdDSA",
            LDKeyClass: Ed25519KeyPair,
            creator,
            verificationMethod,
            signer,
            key,
            proof,
            date,
            useNativeCanonize
          });
          this.requiredKeyType = "Ed25519VerificationKey2018";
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature2015.js
  var require_LinkedDataSignature2015 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/LinkedDataSignature2015.js"(exports, module) {
      "use strict";
      var env = require_env2();
      var forge = require_lib2();
      var LinkedDataSignature = require_LinkedDataSignature2();
      module.exports = class LinkedDataSignature2015 extends LinkedDataSignature {
        constructor({
          type = "LinkedDataSignature2015",
          privateKeyPem,
          publicKeyPem,
          creator,
          date,
          domain,
          nonce,
          useNativeCanonize
        } = {}) {
          if (domain !== void 0 && typeof domain !== "string") {
            throw new TypeError('"domain" must be a string.');
          }
          if (nonce !== void 0 && typeof nonce !== "string") {
            throw new TypeError('"nonce" must be a string.');
          }
          super({ type, creator, date, domain, nonce, useNativeCanonize });
          this.legacy = true;
          this.privateKeyPem = privateKeyPem;
          this.publicKeyPem = publicKeyPem;
          this.nonce = nonce;
          this.domain = domain;
        }
        async updateProof({ proof }) {
          if (this.domain !== void 0) {
            proof.domain = this.domain;
          }
          if (this.nonce !== void 0) {
            proof.nonce = this.nonce;
          }
          return proof;
        }
        async verifyProof({
          proof,
          document: document2,
          purpose,
          documentLoader,
          expansionMap,
          compactProof
        }) {
          try {
            if (this.domain !== void 0 && proof.domain !== this.domain) {
              throw new Error(`The domain is not as expected; domain="${proof.domain}", expected="${this.domain}"`);
            }
            return super.verifyProof({
              proof,
              document: document2,
              purpose,
              documentLoader,
              expansionMap,
              compactProof
            });
          } catch (error) {
            return { verified: false, error };
          }
        }
        async createVerifyData({
          document: document2,
          proof,
          documentLoader,
          expansionMap
        }) {
          const c14n = await this.canonize(document2, {
            documentLoader,
            expansionMap
          });
          let verifyData = "";
          const headers = {
            "http://purl.org/dc/elements/1.1/created": proof.created,
            "https://w3id.org/security#domain": proof.domain,
            "https://w3id.org/security#nonce": proof.nonce
          };
          const keys = Object.keys(headers).sort();
          for (let i = 0; i < keys.length; ++i) {
            const key = keys[i];
            const value = headers[key];
            if (!(value === null || value === void 0)) {
              verifyData += key + ": " + value + "\n";
            }
          }
          verifyData += c14n;
          const buffer = new forge.util.ByteBuffer(verifyData, "utf8");
          return forge.util.binary.raw.decode(buffer.getBytes());
        }
        async sign({ verifyData, proof }) {
          const { privateKeyPem } = this;
          if (typeof privateKeyPem !== "string") {
            throw new TypeError('"privateKeyPem" must be a PEM formatted string.');
          }
          let signature;
          if (env.nodejs) {
            const crypto = require_crypto();
            const signer = crypto.createSign("RSA-SHA256");
            signer.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));
            signature = signer.sign(privateKeyPem, "base64");
          } else {
            const privateKey = forge.pki.privateKeyFromPem(privateKeyPem);
            const md = forge.md.sha256.create();
            md.update(forge.util.binary.raw.encode(verifyData), "binary");
            signature = forge.util.encode64(privateKey.sign(md));
          }
          proof.signatureValue = signature;
          return proof;
        }
        async verifySignature({ verifyData, proof }) {
          const { publicKeyPem } = this;
          if (typeof publicKeyPem !== "string") {
            throw new TypeError('Could not verify signature; invalid "publicKeyPem".');
          }
          if (env.nodejs) {
            const crypto = require_crypto();
            const verifier = crypto.createVerify("RSA-SHA256");
            verifier.update(Buffer.from(verifyData.buffer, verifyData.byteOffset, verifyData.length));
            return verifier.verify(publicKeyPem, proof.signatureValue, "base64");
          }
          const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
          const md = forge.md.sha256.create();
          md.update(forge.util.binary.raw.encode(verifyData), "binary");
          try {
            return publicKey.verify(md.digest().bytes(), forge.util.decode64(proof.signatureValue));
          } catch (e) {
            return false;
          }
        }
        async getVerificationMethod({ proof, documentLoader }) {
          const verificationMethod = await super.getVerificationMethod({ proof, documentLoader });
          if (!this.publicKeyPem) {
            this.publicKeyPem = verificationMethod.publicKeyPem;
          }
          return verificationMethod;
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/GraphSignature2012.js
  var require_GraphSignature2012 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/GraphSignature2012.js"(exports, module) {
      "use strict";
      var jsonld = require_jsonld2();
      var forge = require_lib2();
      var LinkedDataSignature2015 = require_LinkedDataSignature2015();
      module.exports = class GraphSignature2012 extends LinkedDataSignature2015 {
        constructor({
          privateKeyPem,
          publicKeyPem,
          creator,
          date,
          domain,
          nonce
        } = {}) {
          super({
            type: "GraphSignature2012",
            privateKeyPem,
            publicKeyPem,
            creator,
            date,
            domain,
            nonce
          });
        }
        async canonize(input, { documentLoader, expansionMap, skipExpansion }) {
          return jsonld.canonize(input, {
            algorithm: "URGNA2012",
            format: "application/n-quads",
            documentLoader,
            expansionMap,
            skipExpansion
          });
        }
        async createVerifyData({
          document: document2,
          proof,
          documentLoader,
          expansionMap
        }) {
          const c14n = await this.canonize(document2, {
            documentLoader,
            expansionMap
          });
          let verifyData = "";
          if (proof.nonce !== null && proof.nonce !== void 0) {
            verifyData += proof.nonce;
          }
          verifyData += proof.created;
          verifyData += c14n;
          if (proof.domain !== null && proof.domain !== void 0) {
            verifyData += "@" + proof.domain;
          }
          const buffer = new forge.util.ByteBuffer(verifyData, "utf8");
          return forge.util.binary.raw.decode(buffer.getBytes());
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/RsaSignature2018.js
  var require_RsaSignature2018 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites/RsaSignature2018.js"(exports, module) {
      "use strict";
      var { RSAKeyPair } = require_lib3();
      var JwsLinkedDataSignature = require_JwsLinkedDataSignature();
      module.exports = class RsaSignature2018 extends JwsLinkedDataSignature {
        constructor({
          signer,
          key,
          creator,
          verificationMethod,
          proof,
          date,
          useNativeCanonize
        } = {}) {
          super({
            type: "RsaSignature2018",
            alg: "PS256",
            LDKeyClass: RSAKeyPair,
            creator,
            verificationMethod,
            signer,
            key,
            proof,
            date,
            useNativeCanonize
          });
          this.requiredKeyType = "RsaVerificationKey2018";
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/suites.js
  var require_suites2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/suites.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.suites = {
        Ed25519Signature2018: require_Ed25519Signature2018(),
        JwsLinkedDataSignature: require_JwsLinkedDataSignature(),
        LinkedDataProof: require_LinkedDataProof2(),
        LinkedDataSignature: require_LinkedDataSignature2(),
        LinkedDataSignature2015: require_LinkedDataSignature2015(),
        GraphSignature2012: require_GraphSignature2012(),
        RsaSignature2018: require_RsaSignature2018()
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js
  var require_AssertionProofPurpose2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/AssertionProofPurpose.js"(exports, module) {
      "use strict";
      var ControllerProofPurpose = require_ControllerProofPurpose2();
      module.exports = class AssertionProofPurpose extends ControllerProofPurpose {
        constructor({
          term = "assertionMethod",
          controller,
          date,
          maxTimestampDelta = Infinity
        } = {}) {
          super({ term, controller, date, maxTimestampDelta });
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js
  var require_AuthenticationProofPurpose2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes/AuthenticationProofPurpose.js"(exports, module) {
      "use strict";
      var ControllerProofPurpose = require_ControllerProofPurpose2();
      module.exports = class AuthenticationProofPurpose extends ControllerProofPurpose {
        constructor({
          term = "authentication",
          controller,
          challenge,
          date,
          domain,
          maxTimestampDelta = Infinity
        } = {}) {
          super({ term, controller, date, maxTimestampDelta });
          if (typeof challenge !== "string") {
            throw new TypeError('"challenge" must be a string.');
          }
          if (domain !== void 0 && typeof domain !== "string") {
            throw new TypeError('"domain" must be a string.');
          }
          this.challenge = challenge;
          this.domain = domain;
        }
        async validate(proof, { verificationMethod, documentLoader, expansionMap }) {
          try {
            if (proof.challenge !== this.challenge) {
              throw new Error(`The challenge is not as expected; challenge="${proof.challenge}", expected="${this.challenge}"`);
            }
            if (this.domain !== void 0 && proof.domain !== this.domain) {
              throw new Error(`The domain is not as expected; domain="${proof.domain}", expected="${this.domain}"`);
            }
            return super.validate(proof, { verificationMethod, documentLoader, expansionMap });
          } catch (error) {
            return { valid: false, error };
          }
        }
        async update(proof, { document: document2, suite, documentLoader, expansionMap }) {
          proof = await super.update(proof, { document: document2, suite, documentLoader, expansionMap });
          proof.challenge = this.challenge;
          if (this.domain !== void 0) {
            proof.domain = this.domain;
          }
          return proof;
        }
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes.js
  var require_purposes2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/purposes.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      api.purposes = {
        AssertionProofPurpose: require_AssertionProofPurpose2(),
        AuthenticationProofPurpose: require_AuthenticationProofPurpose2(),
        ControllerProofPurpose: require_ControllerProofPurpose2(),
        ProofPurpose: require_ProofPurpose2(),
        PublicKeyProofPurpose: require_PublicKeyProofPurpose()
      };
    }
  });

  // node_modules/vc-js/node_modules/jsonld-signatures/lib/jsonld-signatures.js
  var require_jsonld_signatures2 = __commonJS({
    "node_modules/vc-js/node_modules/jsonld-signatures/lib/jsonld-signatures.js"(exports, module) {
      "use strict";
      var api = {};
      module.exports = api;
      var constants = require_constants5();
      Object.assign(api, constants);
      var ProofSet = require_ProofSet2();
      var VerificationError = require_VerificationError2();
      api.sign = async function sign(document2, {
        suite,
        purpose,
        documentLoader,
        expansionMap,
        compactProof
      } = {}) {
        try {
          return await new ProofSet().add(document2, { suite, purpose, documentLoader, expansionMap, compactProof });
        } catch (e) {
          if (!documentLoader && e.name === "jsonld.InvalidUrl") {
            const { details: { url } } = e;
            const err = new Error(`A URL "${url}" could not be fetched; you need to pass "documentLoader" or resolve the URL before calling "sign".`);
            err.cause = e;
            throw err;
          }
          throw e;
        }
      };
      api.verify = async function verify(document2, {
        suite,
        purpose,
        documentLoader,
        expansionMap,
        compactProof
      } = {}) {
        const result = await new ProofSet().verify(document2, { suite, purpose, documentLoader, expansionMap, compactProof });
        const { error } = result;
        if (error) {
          if (!documentLoader && error.name === "jsonld.InvalidUrl") {
            const { details: { url } } = error;
            const urlError = new Error(`A URL "${url}" could not be fetched; you need to pass "documentLoader" or resolve the URL before calling "verify".`);
            result.error = new VerificationError(urlError);
          } else {
            result.error = new VerificationError(error);
          }
        }
        return result;
      };
      api.suites = require_suites2().suites;
      api.purposes = require_purposes2().purposes;
      Object.assign(api, require_lib3());
      Object.assign(api, require_documentLoader2());
    }
  });

  // node_modules/vc-js/lib/CredentialIssuancePurpose.js
  var require_CredentialIssuancePurpose = __commonJS({
    "node_modules/vc-js/lib/CredentialIssuancePurpose.js"(exports, module) {
      "use strict";
      var jsonld = require_jsonld2();
      var { AssertionProofPurpose } = require_jsonld_signatures2().purposes;
      var CredentialIssuancePurpose = class extends AssertionProofPurpose {
        constructor({ controller, date, maxTimestampDelta } = {}) {
          super({ controller, date, maxTimestampDelta });
        }
        async validate(proof, {
          document: document2,
          suite,
          verificationMethod,
          documentLoader,
          expansionMap
        }) {
          try {
            const result = await super.validate(proof, {
              document: document2,
              suite,
              verificationMethod,
              documentLoader,
              expansionMap
            });
            if (!result.valid) {
              throw result.error;
            }
            const issuer = jsonld.getValues(document2, "https://www.w3.org/2018/credentials#issuer");
            if (!issuer || issuer.length === 0) {
              throw new Error("Credential issuer is required.");
            }
            if (result.controller.id !== issuer[0].id) {
              throw new Error("Credential issuer must match the verification method controller.");
            }
            return { valid: true };
          } catch (error) {
            return { valid: false, error };
          }
        }
      };
      module.exports = CredentialIssuancePurpose;
    }
  });

  // node_modules/credentials-context/js/constants.js
  var require_constants6 = __commonJS({
    "node_modules/credentials-context/js/constants.js"(exports) {
      "use strict";
      exports.CREDENTIALS_CONTEXT_V1_URL = "https://www.w3.org/2018/credentials/v1";
    }
  });

  // node_modules/credentials-context/js/index.js
  var require_js2 = __commonJS({
    "node_modules/credentials-context/js/index.js"(exports) {
      "use strict";
      var constants = require_constants6();
      var path = require_path();
      exports.constants = constants;
      var contexts = exports.contexts = /* @__PURE__ */ new Map();
      function _read(_path) {
        return JSON.parse({});
      }
      contexts.set(constants.CREDENTIALS_CONTEXT_V1_URL, _read("../contexts/credentials-v1.jsonld"));
    }
  });

  // node_modules/vc-js/lib/contexts/vc-examples-v1.js
  var require_vc_examples_v1 = __commonJS({
    "node_modules/vc-js/lib/contexts/vc-examples-v1.js"(exports, module) {
      module.exports = {
        "@context": [
          {
            "@version": 1.1
          },
          "https://www.w3.org/ns/odrl.jsonld",
          {
            "ex": "https://example.org/examples#",
            "schema": "http://schema.org/",
            "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
            "3rdPartyCorrelation": "ex:3rdPartyCorrelation",
            "AllVerifiers": "ex:AllVerifiers",
            "Archival": "ex:Archival",
            "BachelorDegree": "ex:BachelorDegree",
            "Child": "ex:Child",
            "CLCredentialDefinition2019": "ex:CLCredentialDefinition2019",
            "CLSignature2019": "ex:CLSignature2019",
            "IssuerPolicy": "ex:IssuerPolicy",
            "HolderPolicy": "ex:HolderPolicy",
            "Mother": "ex:Mother",
            "RelationshipCredential": "ex:RelationshipCredential",
            "UniversityDegreeCredential": "ex:UniversityDegreeCredential",
            "ZkpExampleSchema2018": "ex:ZkpExampleSchema2018",
            "alumniOf": { "@id": "schema:alumniOf", "@type": "rdf:HTML" },
            "child": { "@id": "ex:child", "@type": "@id" },
            "degree": "ex:degree",
            "name": { "@id": "schema:name", "@type": "rdf:HTML" },
            "parent": { "@id": "ex:parent", "@type": "@id" },
            "referenceId": "ex:referenceId",
            "documentPresence": "ex:documentPresence",
            "evidenceDocument": "ex:evidenceDocument",
            "subjectPresence": "ex:subjectPresence",
            "verifier": { "@id": "ex:verifier", "@type": "@id" }
          }
        ]
      };
    }
  });

  // node_modules/vc-js/lib/contexts/odrl.js
  var require_odrl = __commonJS({
    "node_modules/vc-js/lib/contexts/odrl.js"(exports, module) {
      "use strict";
      module.exports = {
        "@context": {
          "odrl": "http://www.w3.org/ns/odrl/2/",
          "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
          "rdfs": "http://www.w3.org/2000/01/rdf-schema#",
          "owl": "http://www.w3.org/2002/07/owl#",
          "skos": "http://www.w3.org/2004/02/skos/core#",
          "dct": "http://purl.org/dc/terms/",
          "xsd": "http://www.w3.org/2001/XMLSchema#",
          "vcard": "http://www.w3.org/2006/vcard/ns#",
          "foaf": "http://xmlns.com/foaf/0.1/",
          "schema": "http://schema.org/",
          "cc": "http://creativecommons.org/ns#",
          "uid": "@id",
          "type": "@type",
          "Policy": "odrl:Policy",
          "Rule": "odrl:Rule",
          "profile": { "@type": "@id", "@id": "odrl:profile" },
          "inheritFrom": { "@type": "@id", "@id": "odrl:inheritFrom" },
          "ConflictTerm": "odrl:ConflictTerm",
          "conflict": { "@type": "@vocab", "@id": "odrl:conflict" },
          "perm": "odrl:perm",
          "prohibit": "odrl:prohibit",
          "invalid": "odrl:invalid",
          "Agreement": "odrl:Agreement",
          "Assertion": "odrl:Assertion",
          "Offer": "odrl:Offer",
          "Privacy": "odrl:Privacy",
          "Request": "odrl:Request",
          "Set": "odrl:Set",
          "Ticket": "odrl:Ticket",
          "Asset": "odrl:Asset",
          "AssetCollection": "odrl:AssetCollection",
          "relation": { "@type": "@id", "@id": "odrl:relation" },
          "hasPolicy": { "@type": "@id", "@id": "odrl:hasPolicy" },
          "target": { "@type": "@id", "@id": "odrl:target" },
          "output": { "@type": "@id", "@id": "odrl:output" },
          "partOf": { "@type": "@id", "@id": "odrl:partOf" },
          "source": { "@type": "@id", "@id": "odrl:source" },
          "Party": "odrl:Party",
          "PartyCollection": "odrl:PartyCollection",
          "function": { "@type": "@vocab", "@id": "odrl:function" },
          "PartyScope": "odrl:PartyScope",
          "assignee": { "@type": "@id", "@id": "odrl:assignee" },
          "assigner": { "@type": "@id", "@id": "odrl:assigner" },
          "assigneeOf": { "@type": "@id", "@id": "odrl:assigneeOf" },
          "assignerOf": { "@type": "@id", "@id": "odrl:assignerOf" },
          "attributedParty": { "@type": "@id", "@id": "odrl:attributedParty" },
          "attributingParty": { "@type": "@id", "@id": "odrl:attributingParty" },
          "compensatedParty": { "@type": "@id", "@id": "odrl:compensatedParty" },
          "compensatingParty": { "@type": "@id", "@id": "odrl:compensatingParty" },
          "consentingParty": { "@type": "@id", "@id": "odrl:consentingParty" },
          "consentedParty": { "@type": "@id", "@id": "odrl:consentedParty" },
          "informedParty": { "@type": "@id", "@id": "odrl:informedParty" },
          "informingParty": { "@type": "@id", "@id": "odrl:informingParty" },
          "trackingParty": { "@type": "@id", "@id": "odrl:trackingParty" },
          "trackedParty": { "@type": "@id", "@id": "odrl:trackedParty" },
          "contractingParty": { "@type": "@id", "@id": "odrl:contractingParty" },
          "contractedParty": { "@type": "@id", "@id": "odrl:contractedParty" },
          "Action": "odrl:Action",
          "action": { "@type": "@vocab", "@id": "odrl:action" },
          "includedIn": { "@type": "@id", "@id": "odrl:includedIn" },
          "implies": { "@type": "@id", "@id": "odrl:implies" },
          "Permission": "odrl:Permission",
          "permission": { "@type": "@id", "@id": "odrl:permission" },
          "Prohibition": "odrl:Prohibition",
          "prohibition": { "@type": "@id", "@id": "odrl:prohibition" },
          "obligation": { "@type": "@id", "@id": "odrl:obligation" },
          "use": "odrl:use",
          "grantUse": "odrl:grantUse",
          "aggregate": "odrl:aggregate",
          "annotate": "odrl:annotate",
          "anonymize": "odrl:anonymize",
          "archive": "odrl:archive",
          "concurrentUse": "odrl:concurrentUse",
          "derive": "odrl:derive",
          "digitize": "odrl:digitize",
          "display": "odrl:display",
          "distribute": "odrl:distribute",
          "execute": "odrl:execute",
          "extract": "odrl:extract",
          "give": "odrl:give",
          "index": "odrl:index",
          "install": "odrl:install",
          "modify": "odrl:modify",
          "move": "odrl:move",
          "play": "odrl:play",
          "present": "odrl:present",
          "print": "odrl:print",
          "read": "odrl:read",
          "reproduce": "odrl:reproduce",
          "sell": "odrl:sell",
          "stream": "odrl:stream",
          "textToSpeech": "odrl:textToSpeech",
          "transfer": "odrl:transfer",
          "transform": "odrl:transform",
          "translate": "odrl:translate",
          "Duty": "odrl:Duty",
          "duty": { "@type": "@id", "@id": "odrl:duty" },
          "consequence": { "@type": "@id", "@id": "odrl:consequence" },
          "remedy": { "@type": "@id", "@id": "odrl:remedy" },
          "acceptTracking": "odrl:acceptTracking",
          "attribute": "odrl:attribute",
          "compensate": "odrl:compensate",
          "delete": "odrl:delete",
          "ensureExclusivity": "odrl:ensureExclusivity",
          "include": "odrl:include",
          "inform": "odrl:inform",
          "nextPolicy": "odrl:nextPolicy",
          "obtainConsent": "odrl:obtainConsent",
          "reviewPolicy": "odrl:reviewPolicy",
          "uninstall": "odrl:uninstall",
          "watermark": "odrl:watermark",
          "Constraint": "odrl:Constraint",
          "LogicalConstraint": "odrl:LogicalConstraint",
          "constraint": { "@type": "@id", "@id": "odrl:constraint" },
          "refinement": { "@type": "@id", "@id": "odrl:refinement" },
          "Operator": "odrl:Operator",
          "operator": { "@type": "@vocab", "@id": "odrl:operator" },
          "RightOperand": "odrl:RightOperand",
          "rightOperand": "odrl:rightOperand",
          "rightOperandReference": { "@type": "xsd:anyURI", "@id": "odrl:rightOperandReference" },
          "LeftOperand": "odrl:LeftOperand",
          "leftOperand": { "@type": "@vocab", "@id": "odrl:leftOperand" },
          "unit": "odrl:unit",
          "dataType": { "@type": "xsd:anyType", "@id": "odrl:datatype" },
          "status": "odrl:status",
          "absolutePosition": "odrl:absolutePosition",
          "absoluteSpatialPosition": "odrl:absoluteSpatialPosition",
          "absoluteTemporalPosition": "odrl:absoluteTemporalPosition",
          "absoluteSize": "odrl:absoluteSize",
          "count": "odrl:count",
          "dateTime": "odrl:dateTime",
          "delayPeriod": "odrl:delayPeriod",
          "deliveryChannel": "odrl:deliveryChannel",
          "elapsedTime": "odrl:elapsedTime",
          "event": "odrl:event",
          "fileFormat": "odrl:fileFormat",
          "industry": "odrl:industry:",
          "language": "odrl:language",
          "media": "odrl:media",
          "meteredTime": "odrl:meteredTime",
          "payAmount": "odrl:payAmount",
          "percentage": "odrl:percentage",
          "product": "odrl:product",
          "purpose": "odrl:purpose",
          "recipient": "odrl:recipient",
          "relativePosition": "odrl:relativePosition",
          "relativeSpatialPosition": "odrl:relativeSpatialPosition",
          "relativeTemporalPosition": "odrl:relativeTemporalPosition",
          "relativeSize": "odrl:relativeSize",
          "resolution": "odrl:resolution",
          "spatial": "odrl:spatial",
          "spatialCoordinates": "odrl:spatialCoordinates",
          "systemDevice": "odrl:systemDevice",
          "timeInterval": "odrl:timeInterval",
          "unitOfCount": "odrl:unitOfCount",
          "version": "odrl:version",
          "virtualLocation": "odrl:virtualLocation",
          "eq": "odrl:eq",
          "gt": "odrl:gt",
          "gteq": "odrl:gteq",
          "lt": "odrl:lt",
          "lteq": "odrl:lteq",
          "neq": "odrl:neg",
          "isA": "odrl:isA",
          "hasPart": "odrl:hasPart",
          "isPartOf": "odrl:isPartOf",
          "isAllOf": "odrl:isAllOf",
          "isAnyOf": "odrl:isAnyOf",
          "isNoneOf": "odrl:isNoneOf",
          "or": "odrl:or",
          "xone": "odrl:xone",
          "and": "odrl:and",
          "andSequence": "odrl:andSequence",
          "policyUsage": "odrl:policyUsage"
        }
      };
    }
  });

  // node_modules/vc-js/lib/contexts/index.js
  var require_contexts3 = __commonJS({
    "node_modules/vc-js/lib/contexts/index.js"(exports, module) {
      "use strict";
      var { contexts, constants: contextConstants } = require_js2();
      var exportedContexts = module.exports = {
        "https://www.w3.org/2018/credentials/examples/v1": require_vc_examples_v1(),
        "https://www.w3.org/ns/odrl.jsonld": require_odrl()
      };
      for (const c in contextConstants) {
        const contextUrl = contextConstants[c];
        exportedContexts[contextUrl] = contexts.get(contextUrl);
      }
    }
  });

  // node_modules/vc-js/lib/documentLoader.js
  var require_documentLoader3 = __commonJS({
    "node_modules/vc-js/lib/documentLoader.js"(exports, module) {
      "use strict";
      var contexts = require_contexts3();
      module.exports = async function documentLoader(url) {
        const context = contexts[url];
        if (context !== void 0) {
          return {
            contextUrl: null,
            documentUrl: url,
            document: context
          };
        }
        throw new Error(`Document loader unable to load URL "${url}".`);
      };
    }
  });

  // node_modules/vc-js/lib/vc.js
  var require_vc = __commonJS({
    "node_modules/vc-js/lib/vc.js"(exports, module) {
      "use strict";
      var jsonld = require_jsonld2();
      var jsigs = require_jsonld_signatures2();
      var { AuthenticationProofPurpose } = require_jsonld_signatures2().purposes;
      var CredentialIssuancePurpose = require_CredentialIssuancePurpose();
      var defaultDocumentLoader = jsigs.extendContextLoader(require_documentLoader3());
      var { constants: { CREDENTIALS_CONTEXT_V1_URL } } = require_js2();
      var dateRegex = new RegExp("^(\\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|(\\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$", "i");
      module.exports = {
        issue,
        createPresentation,
        signPresentation,
        verify,
        verifyCredential,
        CredentialIssuancePurpose,
        defaultDocumentLoader,
        _checkCredential,
        _checkPresentation,
        dateRegex
      };
      async function issue(options = {}) {
        const documentLoader = options.documentLoader || defaultDocumentLoader;
        const { suite } = options;
        const purpose = options.purpose || new CredentialIssuancePurpose();
        if (!suite) {
          throw new TypeError('"suite" parameter is required for issuing.');
        }
        if (!suite.verificationMethod) {
          throw new TypeError('"suite.verificationMethod" property is required.');
        }
        const { credential } = options;
        if (!credential) {
          throw new TypeError('"credential" parameter is required for issuing.');
        }
        _checkCredential(credential);
        return jsigs.sign(credential, { purpose, documentLoader, suite, ...options });
      }
      async function verify(options = {}) {
        const { presentation } = options;
        try {
          if (!presentation) {
            throw new TypeError('A "presentation" property is required for verifying.');
          }
          return _verifyPresentation(options);
        } catch (error) {
          return {
            verified: false,
            results: [{ presentation, verified: false, error }],
            error
          };
        }
      }
      async function verifyCredential(options = {}) {
        const { credential } = options;
        try {
          if (!credential) {
            throw new TypeError('A "credential" property is required for verifying.');
          }
          return _verifyCredential(options);
        } catch (error) {
          return {
            verified: false,
            results: [{ credential, verified: false, error }],
            error
          };
        }
      }
      async function _verifyCredential(options = {}) {
        const { credential, checkStatus } = options;
        _checkCredential(credential);
        if (credential.credentialStatus && typeof options.checkStatus !== "function") {
          throw new TypeError('A "checkStatus" function must be given to verify credentials with "credentialStatus".');
        }
        const documentLoader = options.documentLoader || defaultDocumentLoader;
        const { controller } = options;
        const purpose = options.purpose || new CredentialIssuancePurpose({
          controller
        });
        const result = await jsigs.verify(credential, { purpose, documentLoader, ...options });
        if (!result.verified) {
          return result;
        }
        if (credential.credentialStatus) {
          result.statusResult = await checkStatus(options);
          if (!result.statusResult.verified) {
            result.verified = false;
          }
        }
        return result;
      }
      function createPresentation({ verifiableCredential, id, holder } = {}) {
        const presentation = {
          "@context": [CREDENTIALS_CONTEXT_V1_URL],
          type: ["VerifiablePresentation"]
        };
        if (verifiableCredential) {
          const credentials = [].concat(verifiableCredential);
          for (const credential of credentials) {
            _checkCredential(credential);
          }
          presentation.verifiableCredential = credentials;
        }
        if (id) {
          presentation.id = id;
        }
        if (holder) {
          presentation.holder = holder;
        }
        _checkPresentation(presentation);
        return presentation;
      }
      async function signPresentation(options = {}) {
        const { presentation, domain, challenge } = options;
        const purpose = options.purpose || new AuthenticationProofPurpose({
          domain,
          challenge
        });
        const documentLoader = options.documentLoader || defaultDocumentLoader;
        return jsigs.sign(presentation, { purpose, documentLoader, ...options });
      }
      async function _verifyPresentation(options = {}) {
        const { presentation, unsignedPresentation } = options;
        _checkPresentation(presentation);
        const documentLoader = options.documentLoader || defaultDocumentLoader;
        let credentialResults;
        let verified = true;
        const credentials = jsonld.getValues(presentation, "verifiableCredential");
        if (credentials.length > 0) {
          credentialResults = await Promise.all(credentials.map((credential) => {
            return verifyCredential({ credential, documentLoader, ...options });
          }));
          for (const [i, credentialResult] of credentialResults.entries()) {
            credentialResult.credentialId = credentials[i].id;
          }
          const allCredentialsVerified = credentialResults.every((r) => r.verified);
          if (!allCredentialsVerified) {
            verified = false;
          }
        }
        if (unsignedPresentation) {
          return { verified, results: [presentation], credentialResults };
        }
        const { controller, domain, challenge } = options;
        if (!options.presentationPurpose && !challenge) {
          throw new Error('A "challenge" param is required for AuthenticationProofPurpose.');
        }
        const purpose = options.presentationPurpose || new AuthenticationProofPurpose({ controller, domain, challenge });
        const presentationResult = await jsigs.verify(presentation, { purpose, documentLoader, ...options });
        return {
          presentationResult,
          verified: verified && presentationResult.verified,
          credentialResults,
          error: presentationResult.error
        };
      }
      function _getId(obj) {
        if (typeof obj === "string") {
          return obj;
        }
        if (!("id" in obj)) {
          return;
        }
        return obj.id;
      }
      function _checkPresentation(presentation) {
        const context = Array.isArray(presentation["@context"]) ? presentation["@context"] : [presentation["@context"]];
        if (context[0] !== CREDENTIALS_CONTEXT_V1_URL) {
          throw new Error(`"${CREDENTIALS_CONTEXT_V1_URL}" needs to be first in the list of contexts.`);
        }
        const types = jsonld.getValues(presentation, "type");
        if (!types.includes("VerifiablePresentation")) {
          throw new Error('"type" must include "VerifiablePresentation".');
        }
      }
      function _checkCredential(credential) {
        if (credential["@context"][0] !== CREDENTIALS_CONTEXT_V1_URL) {
          throw new Error(`"${CREDENTIALS_CONTEXT_V1_URL}" needs to be first in the list of contexts.`);
        }
        if (!credential["type"]) {
          throw new Error('"type" property is required.');
        }
        if (!jsonld.getValues(credential, "type").includes("VerifiableCredential")) {
          throw new Error('"type" must include `VerifiableCredential`.');
        }
        if (!credential["credentialSubject"]) {
          throw new Error('"credentialSubject" property is required.');
        }
        if (!credential["issuer"]) {
          throw new Error('"issuer" property is required.');
        }
        if (jsonld.getValues(credential, "issuanceDate").length > 1) {
          throw new Error('"issuanceDate" property can only have one value.');
        }
        if (!credential["issuanceDate"]) {
          throw new Error('"issuanceDate" property is required.');
        }
        if ("issuanceDate" in credential) {
          if (!dateRegex.test(credential.issuanceDate)) {
            throw new Error(`"issuanceDate" must be a valid date: ${credential.issuanceDate}`);
          }
        }
        if (jsonld.getValues(credential, "issuer").length > 1) {
          throw new Error('"issuer" property can only have one value.');
        }
        if ("issuer" in credential) {
          const issuer = _getId(credential.issuer);
          if (!issuer) {
            throw new Error(`"issuer" id is required.`);
          }
          if (!issuer.includes(":")) {
            throw new Error(`"issuer" id must be a URL: ${issuer}`);
          }
        }
        if ("credentialStatus" in credential) {
          if (!credential.credentialStatus.id) {
            throw new Error('"credentialStatus" must include an id.');
          }
          if (!credential.credentialStatus.type) {
            throw new Error('"credentialStatus" must include a type.');
          }
        }
        jsonld.getValues(credential, "evidence").forEach((evidence) => {
          const evidenceId = _getId(evidence);
          if (evidenceId && !evidenceId.includes(":")) {
            throw new Error(`"evidence" id must be a URL: ${evidence}`);
          }
        });
        if ("expirationDate" in credential && !dateRegex.test(credential.expirationDate)) {
          throw new Error(`"expirationDate" must be a valid date: ${credential.expirationDate}`);
        }
      }
    }
  });

  // node_modules/vc-js/lib/index.js
  var require_lib5 = __commonJS({
    "node_modules/vc-js/lib/index.js"(exports, module) {
      module.exports = require_vc();
    }
  });

  // certificate-signer-library/signer.js
  var require_signer = __commonJS({
    "certificate-signer-library/signer.js"(exports, module) {
      var jsigs = require_jsonld_signatures();
      var { RsaSignature2018 } = jsigs.suites;
      var { Ed25519Signature2018 } = jsigs.suites;
      var { Ed25519KeyPair } = require_lib3();
      var { AssertionProofPurpose } = jsigs.purposes;
      var { RSAKeyPair } = require_lib3();
      var { documentLoaders } = require_jsonld2();
      var { node: documentLoader } = documentLoaders;
      var { contexts } = require_js();
      var credentialsv1 = require_credentials();
      var vc = require_lib5();
      var documentLoaderMapping2 = { "https://w3id.org/security/v1": contexts.get("https://w3id.org/security/v1") };
      documentLoaderMapping2["https://www.w3.org/2018/credentials#"] = credentialsv1;
      documentLoaderMapping2["https://www.w3.org/2018/credentials/v1"] = credentialsv1;
      var publicKey = {};
      var controller = {};
      var privateKeyPem = "";
      var maxRetrycount = 0;
      var certificateDID = "";
      var publicKeyBase58 = "";
      var privateKeyBase58 = "";
      var KeyType = {
        RSA: "RSA",
        ED25519: "ED25519"
      };
      var signingKeyType = KeyType.RSA;
      var getPublicKey = (config2) => {
        switch (config2.keyType) {
          case KeyType.RSA:
            return {
              "@context": jsigs.SECURITY_CONTEXT_URL,
              id: config2.CERTIFICATE_DID,
              type: "RsaVerificationKey2018",
              controller: config2.CERTIFICATE_PUBKEY_ID,
              publicKeyPem: config2.publicKeyPem
            };
          case KeyType.ED25519:
            return {
              "@context": jsigs.SECURITY_CONTEXT_URL,
              id: config2.CERTIFICATE_DID,
              type: "Ed25519VerificationKey2018",
              controller: config2.CERTIFICATE_PUBKEY_ID
            };
        }
      };
      var setDocumentLoader = (customLoaderMapping, config2) => {
        privateKeyPem = config2.privateKeyPem;
        maxRetrycount = config2.CERTIFICATE_RETRY_COUNT;
        signingKeyType = config2.keyType || KeyType.RSA;
        publicKey = getPublicKey(config2);
        controller = {
          "@context": jsigs.SECURITY_CONTEXT_URL,
          id: config2.CERTIFICATE_CONTROLLER_ID,
          publicKey: [publicKey],
          assertionMethod: [publicKey.id]
        };
        documentLoaderMapping2[config2.CERTIFICATE_DID] = publicKey;
        documentLoaderMapping2[config2.CERTIFICATE_PUBKEY_ID] = publicKey;
        documentLoaderMapping2 = { ...documentLoaderMapping2, ...customLoaderMapping };
        certificateDID = config2.CERTIFICATE_DID;
        publicKeyBase58 = config2.publicKeyBase58 || "";
        privateKeyBase58 = config2.privateKeyBase58 || "";
      };
      var customLoader = (url) => {
        console.log("checking " + url);
        let context = documentLoaderMapping2[url];
        if (context === void 0) {
          context = contexts[url];
        }
        if (context !== void 0) {
          return {
            contextUrl: null,
            documentUrl: url,
            document: context
          };
        }
        if (url.startsWith("{")) {
          return JSON.parse(url);
        }
        console.log("Fallback url lookup for document :" + url);
        return documentLoader()(url);
      };
      async function signJSON(certificate) {
        let signed = "";
        if (signingKeyType === KeyType.RSA) {
          const key = new RSAKeyPair({ ...publicKey, privateKeyPem });
          signed = await jsigs.sign(certificate, {
            documentLoader: customLoader,
            suite: new RsaSignature2018({ key }),
            purpose: new AssertionProofPurpose({
              controller
            }),
            compactProof: false
          });
        } else if (signingKeyType === KeyType.ED25519) {
          const key = new Ed25519KeyPair({
            publicKeyBase58,
            privateKeyBase58,
            id: certificateDID
          });
          const purpose = new AssertionProofPurpose({
            controller
          });
          signed = await vc.issue({
            credential: certificate,
            suite: new Ed25519Signature2018({ key }),
            purpose,
            documentLoader: customLoader,
            compactProof: false
          });
        }
        console.info("Signed cert " + JSON.stringify(signed));
        return signed;
      }
      async function verifyJSON2(signedJSON) {
        const { AssertionProofPurpose: AssertionProofPurpose2 } = jsigs.purposes;
        let result;
        console.log(signingKeyType, "key type");
        if (signingKeyType === "RSA") {
          const key = new RSAKeyPair({ ...publicKey });
          const { RsaSignature2018: RsaSignature20182 } = jsigs.suites;
          result = await jsigs.verify(signedJSON, {
            suite: new RsaSignature20182({ key }),
            purpose: new AssertionProofPurpose2({ controller }),
            documentLoader: customLoader,
            compactProof: false
          });
        } else if (signingKeyType === "ED25519") {
          const purpose = new AssertionProofPurpose2({
            controller
          });
          const { Ed25519Signature2018: Ed25519Signature20182 } = jsigs.suites;
          const key = new Ed25519KeyPair({
            publicKeyBase58,
            id: certificateDID
          });
          result = await vc.verifyCredential({
            credential: signedJSON,
            suite: new Ed25519Signature20182({ key }),
            purpose,
            documentLoader: customLoader,
            compactProof: false
          });
        }
        return result;
      }
      module.exports = {
        signJSON,
        verifyJSON: verifyJSON2,
        customLoader,
        setDocumentLoader,
        KeyType
      };
    }
  });

  // certificate-signer-library/main.js
  var require_main = __commonJS({
    "certificate-signer-library/main.js"(exports, module) {
      var signer = require_signer();
      var config2 = {};
      var signingPayloadTransformerFunc;
      async function init_signer2(conf, signingPayloadTransformer, documentLoader) {
        config2 = conf;
        signingPayloadTransformerFunc = signingPayloadTransformer;
        signer.setDocumentLoader(documentLoader, conf);
      }
      async function verifyJSON2(signedJSON) {
        return signer.verifyJSON(signedJSON);
      }
      module.exports = {
        init_signer: init_signer2,
        verifyJSON: verifyJSON2
      };
    }
  });

  // index.js
  var { CertificateContext } = require_certificate_context();
  var { verifyJSON, init_signer } = require_main();
  var signingConfig = {
    publicKeyPem: config.certificatePublicKey,
    publicKeyBase58: config.certificatePublicKeyBase58,
    CERTIFICATE_DID,
    CERTIFICATE_PUBKEY_ID,
    CERTIFICATE_CONTROLLER_ID,
    keyType: CERTIFICATE_SIGNED_KEY_TYPE
  };
  var documentLoaderMapping = {
    [CERTIFICATE_NAMESPACE]: CertificateContext
  };
})();
/*!
 * Copyright (c) 2010-2018 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2017-2021 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2018 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2018-2019 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2018-2021 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2019-2020 Digital Bazaar, Inc. All rights reserved.
 */
/*!
 * Copyright (c) 2020 Digital Bazaar, Inc. All rights reserved.
 */
/*!s
 * Copyright (c) 2017-2018 Digital Bazaar, Inc. All rights reserved.
 */
/**
 * A JavaScript implementation of Verifiable Credentials.
 *
 * @author Dave Longley
 * @author David I. Lehn
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2017-2020 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * A JavaScript implementation of the JSON-LD API.
 *
 * @author Dave Longley
 *
 * @license BSD 3-Clause License
 * Copyright (c) 2011-2019 Digital Bazaar, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution.
 *
 * Neither the name of the Digital Bazaar, Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
 * IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/**
 * Removes the @preserve keywords as the last step of the compaction
 * algorithm when it is running on framed output.
 *
 * @param ctx the active context used to compact the input.
 * @param input the framed, compacted output.
 * @param options the compaction options used.
 *
 * @return the resulting output.
 */
/**
 * Removes the @preserve keywords from expanded result of framing.
 *
 * @param input the framed, framed output.
 * @param options the framing options used.
 *
 * @return the resulting output.
 */
// disallow aliasing @context and @preserve
// remove @preserve
// remove @preserve from results
